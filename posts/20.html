<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>c/c++/嵌入式面经 | Z💭</title><meta name="keywords" content="面试题,八股文,面经"><meta name="author" content="Z💭"><meta name="copyright" content="Z💭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="面试题｜八股文｜面经"><meta property="og:type" content="article"><meta property="og:title" content="c&#x2F;c++&#x2F;嵌入式面经"><meta property="og:url" content="https://ze520ze.github.io/posts/20.html"><meta property="og:site_name" content="Z💭"><meta property="og:description" content="面试题｜八股文｜面经"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://npm.elemecdn.com/xianqi-hexo/imgg/20.webp"><meta property="article:published_time" content="2025-04-27T02:40:00.000Z"><meta property="article:modified_time" content="2025-04-27T02:42:05.298Z"><meta property="article:author" content="Z💭"><meta property="article:tag" content="面试题"><meta property="article:tag" content="八股文"><meta property="article:tag" content="面经"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://npm.elemecdn.com/xianqi-hexo/imgg/20.webp"><link rel="shortcut icon" href="https://thirdqq.qlogo.cn/g?b=sdk&nk=2287853439&s=140"><link rel="canonical" href="https://ze520ze.github.io/posts/20"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:230},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"var(--theme-color)",bgDark:"#191919",position:"top-right"},source:{justifiedGallery:{js:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js",css:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"c/c++/嵌入式面经",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-04-27 10:42:05"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Z💭" type="application/atom+xml"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=sdk&amp;nk=2287853439&amp;s=140" onerror='onerror=null,src="/assets/r1.jpg"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Z💭</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg> <span>搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">c/c++/嵌入式面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span> <time class="post-meta-date-created" datetime="2025-04-27T02:40:00.000Z" title="发表于 2025-04-27 10:40:00">2025-04-27</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-27T02:42:05.298Z" title="更新于 2025-04-27 10:42:05">2025-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><i class="fas fa-angle-right post-meta-separator"></i><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a><i class="fas fa-angle-right post-meta-separator"></i><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">4.1w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>127分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="c/c++/嵌入式面经"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>相遇皆是缘分</p><h1>进程和线程</h1><h2 id="线程">线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建线程</span><br><span class="line"><span class="type">pthread_t</span> tid;    <span class="comment">//线程类型</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);  <span class="comment">//线程创建函数     working：指定一个处理函数</span></span><br><span class="line"></span><br><span class="line">thread（幅 ruai 的）</span><br><span class="line">create（亏 A t）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 线程退出</span><br><span class="line"> pthread_exit    <span class="comment">//只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。</span></span><br><span class="line"></span><br><span class="line">exit（爱 克 谁 t）</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>线程回收</span><br><span class="line"><span class="comment">/*这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。*/</span></span><br><span class="line">pthread_join  </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 线程分离</span><br><span class="line">  pthread_detach   <span class="comment">//线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了</span></span><br><span class="line">    </span><br><span class="line">detach（滴他气）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 线程取消</span><br><span class="line">线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：</span><br><span class="line">    在线程A中调用线程取消函数pthread_cancel，指定杀死线程B，这时候线程B是死不了的</span><br><span class="line">    在线程B中进行一次系统调用（从用户区切换到内核区），如何调用？比如说： 用 pthread_self 会系统调用</span><br><span class="line"></span><br><span class="line"> pthread_cancel</span><br><span class="line">cancel（ 康 受 ）</span><br><span class="line">    </span><br><span class="line"> <span class="number">6.</span> 返回当前线程的线程ID</span><br><span class="line"> pthread_self</span><br><span class="line">self（）</span><br></pre></td></tr></table></figure><h2 id="互斥锁">互斥锁</h2><blockquote><p>互斥锁可以锁定一个代码块,被锁定的这个代码块,所有的线程只能顺序执行(不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的,现在只能串行处理。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">互斥锁的类型为<span class="type">pthread_mutex_t</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 初始化互斥锁    </span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>()</span><br><span class="line"><span class="comment">// 释放互斥锁资源  </span></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>() </span><br><span class="line"></span><br><span class="line">thread（幅 ruai 的）</span><br><span class="line">mutex（miu 太 克 s）    </span><br><span class="line">destroy（抵 死 作 以 ）</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span>创建互斥锁 </span><br><span class="line"> <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>上锁阻塞,解锁后解除阻塞</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>解锁  </span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">unlock（昂 洛克）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="死锁">死锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</span><br><span class="line"></span><br><span class="line">造成原因：</span><br><span class="line"><span class="number">1.</span>加锁之后忘记解锁</span><br><span class="line"><span class="number">2.</span>重复加锁, 造成死锁</span><br><span class="line"><span class="number">3.</span>在程序中有多个共享资源, 因此有很多把锁，随意加锁，导致相互被阻塞</span><br><span class="line">    </span><br><span class="line">避免方法：</span><br><span class="line"><span class="number">1.</span>避免多次锁定, 多检查</span><br><span class="line"><span class="number">2.</span>对共享资源访问完毕之后, 一定要解锁，或者在加锁的使用 trylock</span><br><span class="line"><span class="number">3.</span>如果程序中有多把锁, 可以控制对锁的访问顺序(顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。</span><br><span class="line"><span class="number">4.</span>项目程序中可以引入一些专门用于死锁检测的模块</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="读写锁">读写锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">()</span></span>;<span class="number">4</span></span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">thread（幅 ruai 的）</span><br><span class="line">destroy（抵 死 作 以 ）</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>创建读写锁</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>读/写</span><br><span class="line"><span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line"><span class="built_in">pthread_rwlock_wdlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>解锁</span><br><span class="line"><span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">unlock（昂 洛克）</span><br><span class="line"></span><br><span class="line">因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点:</span><br><span class="line"><span class="number">1.</span>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。</span><br><span class="line"><span class="number">2.</span>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。</span><br><span class="line"><span class="number">3.</span>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为写锁比读锁的优先级高。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条件变量">条件变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">条件变量的主要作用是进行线程的阻塞。一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span>创建条件变量</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">destroy（抵 死 作 以 ）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h2 id="信号量">信号量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。</span><br><span class="line">*</span><br><span class="line">* 资源总数为<span class="number">1</span>，不需要琐，不需要线程同步</span><br><span class="line">* 资源总数&gt;<span class="number">1</span>时，需要琐,需要线程同步</span><br><span class="line">*    </span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可     </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">sem（塞母）</span><br><span class="line">destroy（抵 死 作 以 ）</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span>创建信号量</span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>资源就会被消耗<span class="number">1</span>个, 资源数<span class="number">-1</span> (消费者)</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>资源数+<span class="number">1</span> （生产者）</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="进程">进程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>当前进程的进程ID（PID）</span><br><span class="line">    <span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>获取当前进程的父进程 ID（PPID）</span><br><span class="line">    <span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>创建一个新的进程</span><br><span class="line">	<span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">父子进程</span><br><span class="line">   父进程从<span class="built_in">main</span>()函数开始 就是父进程</span><br><span class="line">   子各种从fork()函数之后被创建, 子进程就从fork()之后开始向下执行代码</span><br><span class="line">    </span><br><span class="line">exec族函数中最常用的有两个<span class="built_in">execl</span>()和<span class="built_in">execlp</span>()</span><br><span class="line">    调用这些函数的时候都会先创建一个子进程，在子进程中调用 exec 族函数，子进程的用户区数据被替换掉开始执行新的程序中的代码逻辑，但是父进程不受任何影响仍然可以继续正常工作。</span><br><span class="line">    <span class="built_in">execl</span>()    <span class="comment">//该函数可用于执行任意一个可执行程序，函数需要通过指定的文件路径才能找到这个可执行程序</span></span><br><span class="line">    <span class="built_in">execlp</span>()   <span class="comment">//常用于执行已经设置了环境变量的可执行程序</span></span><br><span class="line">    </span><br><span class="line">    execl（以克 Z 要）</span><br></pre></td></tr></table></figure><h2 id="管道">管道</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个匿名的管道, 得到两个可用的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pipe</span>(派普)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读管道</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 写管道的函数</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">管道的是进程间通信(IPC-InterProcess Communication)的一种方式，管道的本质其实就是内核中的一块内存(或者叫内核缓冲区)，这块缓冲区中的数据存储在一个环形队列中，因为管道在内核里边,因此我们不能直接对其进行任何操作。</span><br><span class="line">其实管道操作就是文件IO操作，通过文件IO的读(read)/写(write)来操作管道的读写</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="消息队列">消息队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取唯一键值</span></span><br><span class="line"> <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;/&quot;</span>,<span class="number">2023</span>);</span><br><span class="line"></span><br><span class="line">ftok（服拓克）</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过key值生成消息队列</span></span><br><span class="line"> <span class="built_in">msgget</span>(key, IPC_CREAT | <span class="number">0666</span> );</span><br><span class="line"></span><br><span class="line">msgget（卖给特）</span><br><span class="line"></span><br><span class="line"><span class="comment">//编辑消息队列信息</span></span><br><span class="line">    MSG _msg;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg,<span class="number">0</span>,<span class="built_in">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">memset（闷谁t）</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受消息</span></span><br><span class="line"><span class="built_in">msgrcv</span>()</span><br><span class="line"><span class="built_in">msgrcv</span>(m s 鸡 k)</span><br><span class="line">    </span><br><span class="line">.消息队列是消息的链表，存放于内存中，内核维护消息队列</span><br><span class="line">管道比较适用于较少进程之间的通信，那么如果想要实现多个进程之前的通信的话，我们需要使用消息队列</span><br></pre></td></tr></table></figure><h2 id="内存映射">内存映射</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建内存映射区</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">munmap</span>(闷卖铺)</span><br><span class="line">    </span><br><span class="line">如果想要实现进程间通信，可以通过函数创建一块内存映射区，和管道不同的是管道对应的内存空间在内核中，而内存映射区对应的内存空间在进程的用户区（用于加载动态库的那个区域），也就是说进程间通信使用的内存映射区不是一块，而是在每个进程内部都有一块。</span><br></pre></td></tr></table></figure><h2 id="共享内存">共享内存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">共享内存不同于内存映射区，它不属于任何进程，并且不受进程生命周期的影响。通过调用Linux提供的系统函数就可得到这块共享内存。使用之前需要让进程和共享内存进行关联，得到共享内存的起始地址之后就可以直接进行读写操作了，进程也可以和这块共享内存解除关联,解除关联之后就不能操作这块共享内存了。在所有进程间通信的方式中共享内存的效率是最高的。</span><br><span class="line">共享内存操作默认不阻塞，如果多个进程同时读写共享内存，可能出现数据混乱，共享内存需要借助其他机制来保证进程间的数据同步，比如:信号量，共享内存内部没有提供这种机制。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个参数作为种子, 生成一个 key_t 类型的数值</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span>创建共享内存</span><br><span class="line"><span class="built_in">shmget</span>(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg);</span><br><span class="line"></span><br><span class="line">shmget（西给t）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>关联</span><br><span class="line">*shmat（）</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>解除</span><br><span class="line">shmdt</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>删除共享内存</span><br><span class="line"> shmctl</span><br><span class="line">    </span><br><span class="line">相关shell命令</span><br><span class="line">使用ipcs 添加参数-m可以查看系统中共享内存的详细信息</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">进程间通信</span><br><span class="line"> <span class="number">1.</span> 调用linux的系统API创建一块共享内存</span><br><span class="line">    - 这块内存不属于任何进程, 默认进程不能对其进行操作</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 准备好进程A, 和进程B, 这两个进程需要和创建的共享内存进行关联</span><br><span class="line">    - 关联操作: 调用linux的 api</span><br><span class="line">    - 关联成功之后, 得到了这块共享内存的起始地址</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span> 在进程A或者进程B中对共享内存进行读写操作</span><br><span class="line">    - 读内存: <span class="built_in">printf</span>() 等;</span><br><span class="line">	- 写内存: <span class="built_in">memcpy</span>() 等;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 通信完成, 可以让进程A和B和共享内存解除关联</span><br><span class="line">    - 解除成功, 进程A和B不能再操作共享内存了</span><br><span class="line">    - 共享内存不受进程生命周期的影响的</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span> 共享内存不在使用之后, 将其删除</span><br><span class="line">    - 调用linux的api函数, 删除之后这块内存被内核回收了</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="shm和mmap的区别">shm和mmap的区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">共享内存和内存映射区都可以实现进程间通信，下面来分析一下二者的区别：</span><br><span class="line"></span><br><span class="line">实现进程间通信的方式</span><br><span class="line"></span><br><span class="line">shm: 多个进程只需要一块共享内存就够了，共享内存不属于进程，需要和进程关联才能使用</span><br><span class="line">内存映射区: 位于每个进程的虚拟地址空间中, 并且需要关联同一个磁盘文件才能实现进程间数据通信</span><br><span class="line">效率:</span><br><span class="line"></span><br><span class="line">shm: 直接对内存操作，效率高</span><br><span class="line">内存映射区: 需要内存和文件之间的数据同步，效率低</span><br><span class="line">生命周期</span><br><span class="line"></span><br><span class="line">内存映射区：进程退出, 内存映射区也就没有了</span><br><span class="line">shm：进程退出对共享内存没有影响，调用相关函数/命令/ 关机才能删除共享内存</span><br><span class="line">数据的完整性 -&gt; 突发状态下数据能不能被保存下来（比如: 突然断电）</span><br><span class="line"></span><br><span class="line">内存映射区：可以完整的保存数据, 内存映射区数据会同步到磁盘文件</span><br><span class="line">shm：数据存储在物理内存中, 断电之后系统关闭, 内存数据也就丢失了</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="信号">信号</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Linux中的信号有三种状态，分别为:产生，未决，递达。</span><br><span class="line">   </span><br><span class="line"><span class="number">1.</span>相关的信号给到对应的进程。</span><br><span class="line">kill/raise/abort</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 定时器</span><br><span class="line">    alarm  只能进行单次定时，定时完成发射出一个信号。</span><br><span class="line">    setitimer   可以进行周期性定时，每触发一次定时器就会发射出一个信号。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>信号集</span><br><span class="line">在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。</span><br><span class="line">信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</span><br><span class="line">信号的“阻塞”是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>信号捕捉</span><br><span class="line">signal</span><br><span class="line">sigaction</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Makefile">Makefile</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">目标文件：依赖文件</span><br><span class="line">    要执行的命令</span><br><span class="line"></span><br><span class="line">test : main.o sub.o </span><br><span class="line">	gcc -o test main.o sub.o  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//要生成test可执行文件的话，先检查main.o和shu.o是否有更新，有更新就执行 gcc -o test main.o sub.o  命令，生成test文件    </span></span><br><span class="line"> </span><br><span class="line">%.o : %.c </span><br><span class="line">	gcc -c -o $@  $&lt;  </span><br><span class="line">clean: </span><br><span class="line">    rm *.o test -f </span><br><span class="line">        </span><br><span class="line">%.o：表示所用的.o文件</span><br><span class="line">%.c：表示所有的.c文件</span><br><span class="line">$@：表示目标</span><br><span class="line">$&lt;：表示第<span class="number">1</span>个依赖文件</span><br><span class="line">$^：表示所有依赖文件</span><br></pre></td></tr></table></figure><h2 id="什么是进程﹖什么是线程">什么是进程﹖什么是线程?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程是资源(CPU、内存等）分配的基本单位，线程是CPU调度和分配的基本单位（程序执行的最小单位)。</span><br></pre></td></tr></table></figure><h2 id="请问进程和线程有什么区别？">请问进程和线程有什么区别？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我理解的进程它其实就是一个APP吧</span><br><span class="line">就比如说我们在电脑上打开任务管理器，然后它里面就会有很多的一个进程列表，比如说一个QQ它就是一个进程比如说一个英雄联盟他就是一个进程，进程他是我们操作系统资源分配的一个基本单位，在一个进程里可以拥有一个或者多个线程，当一个进程里面只有一个线程，我就理解为他们没什么区别，如果一个进程里面有多个线程就不一样了，多个线程它其实是共享进程的一个资源的，然后这就导致了在同一个进程里面某一个线程挂了就有可能会导致其他的线程也会出问题，但是每一个进程之间是相互独立的  线程是CPU调度的一个基本单位</span><br></pre></td></tr></table></figure><h2 id="线程的作用">线程的作用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>CPU调度和分配的基本单位（能独立运行的基本单位）</span><br><span class="line"><span class="number">2.</span>可并发执行：在一个进程中的多个线程之间可以并发执行，甚至允许在一个进程中所有线程都能并发执行</span><br><span class="line"><span class="number">3.</span>共享进程资源：在同一进程中的各个线程，都可以共享该进程所拥有的资源</span><br></pre></td></tr></table></figure><h2 id="何时使用多进程，何时使用多线程">何时使用多进程，何时使用多线程?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安全稳定选进程 , 快速频繁选线程</span><br><span class="line">对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</span><br><span class="line">要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</span><br></pre></td></tr></table></figure><h2 id="进程、线程间通信方式有哪些-有什么优缺点">进程、线程间通信方式有哪些?有什么优缺点?</h2><h2>进程</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87d7dd0e0a243d4016c80.png" alt=""></p><h2>线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">信号量</span><br><span class="line">读写锁</span><br><span class="line">条件变量</span><br><span class="line">互斥锁</span><br><span class="line">自旋锁</span><br></pre></td></tr></table></figure><h2 id="互斥锁与信号量的区别">互斥锁与信号量的区别?</h2><blockquote><p>互斥锁用于线程的互斥，信号量用于线程的同步。<br>这是互斥锁和信号量的根本区别，也就是互斥和同步之间的区别。<br>同时互斥锁的作用域仅仅在于线程，信号量可以作用于线程和进程。</p></blockquote><p>进程有几种状态？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87d7dd0e0a243d4016c81.png" alt=""></p><h2 id="自旋锁-和-信号量-区别">自旋锁 和 信号量 区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自旋锁，顾名思义，我们可以把他理解成厕所门上的一把锁。这个厕所门只有一把钥匙，当我们进去时，把钥匙取下来，进去后反锁。那么当第二个人想进来，必须等我们出去后才可以。当第二个人在外面等待时，可能会一直等待在门口转圈。</span><br><span class="line"></span><br><span class="line">比如，厕所一次只能让一个人进去，当A在里面的时候，B想进去，如果是自旋锁，那么B就会一直在门口傻傻等待。如果是信号量，A就会给B一个信号，你先回去吧，我出来了叫你。这就是一个信号量的例子，B听到A发出的信号后，可以先回去睡觉，等待A出来。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="进程上下文和中断上下文">进程上下文和中断上下文</h2><p>进程上下文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中断上下文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当由硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文就可以理解为硬件传递过来的这些参数和内核需要保存的一些环境，主要是被中断的进程的环境。</span><br></pre></td></tr></table></figure><h2 id="父进程、子进程的关系以及区别">父进程、子进程的关系以及区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子进程从父进程继承的主要有:用户号和用户组号;堆栈;共享内存;目录(当前目录、根目录)﹔打开文件的描述符;</span><br><span class="line">但父进程和子进程拥有独立的地址空间和PID参数、不同的父进程号、自己的文件描述符。</span><br></pre></td></tr></table></figure><h2 id="同步和异步和互斥">同步和异步和互斥</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程同步:每个线程之间按预定的先后次序进行运行，协同、协助、互相配合。</span><br><span class="line">可以理解成<span class="string">&quot;你说完，我再做”。有了线程同步，每个线程才不是自己做自己的事情，而是协同完成某件大事。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">线程互斥:当有若干个线程访问同一块资源时，规定同一时间只有一个线可以得到访问权，其它线程需要等占用资源者释放该资源才可以申请访问。</span></span><br><span class="line"><span class="string">线程互斥可以看成是一种特殊的线程同步。</span></span><br></pre></td></tr></table></figure><h2 id="孤儿进程、僵尸进程、守护进程">孤儿进程、僵尸进程、守护进程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">孤儿进程:当父进程退出后它的子进程还在运行，那么这些子进程就是孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。</span><br><span class="line">僵尸进程:当子进程退出后而父进程并未接收结束子进程(如调用waitpid获取子进程的状态信息)，那么子进程仍停留在系统中，这就是僵尸进程。</span><br><span class="line">守护进程:是在后台运行不受终端控制的进程（如输入、输出等)。网络服务大部分就是守护进程。</span><br></pre></td></tr></table></figure><h2 id="僵尸进程的危害，和解决的方法">僵尸进程的危害，和解决的方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">危害：</span><br><span class="line">进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line">系统规定，子进程退出后，父进程会自动收到SIGCHLD信号。因此我们需要在父进程里重置signal函数。每当子进程退出，父进程都会收到SIGCHLD信号，故通过signal函数，重置信号响应函数。</span><br><span class="line">    </span><br><span class="line">SIGCHLD（塞切的）sigchld</span><br><span class="line">signal（塞格no）</span><br></pre></td></tr></table></figure><h2 id="线程池">线程池</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">线程池的组成主要分为<span class="number">3</span>个部分，这三部分配合工作就可以得到一个完整的线程池：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>任务队列(生产者)，存储需要处理的任务，由工作的线程来处理这些任务</span><br><span class="line">    通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</span><br><span class="line">    已处理的任务会被从任务队列中删除</span><br><span class="line">    线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</span><br><span class="line"><span class="number">2.</span>工作的线程（任务队列任务的消费者） ，N个</span><br><span class="line">    线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理</span><br><span class="line">    工作的线程相当于是任务队列的消费者角色，</span><br><span class="line">    如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量/信号量阻塞)</span><br><span class="line">    如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作</span><br><span class="line"><span class="number">3.</span>管理者线程（不处理任务队列中的任务），<span class="number">1</span>个</span><br><span class="line">    它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</span><br><span class="line">    当任务过多的时候, 可以适当的创建一些新的工作线程</span><br><span class="line">    当任务过少的时候, 可以适当的销毁一些工作的线程</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>网络</h1><h2 id="IO多路复用">IO多路复用</h2><p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p>程序员，可以通过accept、 read… .等函数来监测“监听文件描述符”或“通信文件描述符”的读写缓存区，从而获取或发送数据。<br>I0多路复用，代替了程序员，可以同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了</p><p>​ 平台 检测的连接数 效率</p><p>select 跨平台 有上限（1024） 线性表</p><p>poll linux 无上限（配置越好，越高） 线性表</p><p>epoll linux 无上限（配置越好，越高） 红黑树（高）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">水平(LT)模式 和 边沿（ET)模式区别：</span><br><span class="line">如果收数据的buf缓冲区，定为一个小的容量（比如：<span class="number">5</span>字节)，且需要收大于<span class="number">5</span>字节的数据时</span><br><span class="line">LT ：会不断触发与通知，以每次<span class="number">5</span>字节来读取数据，自动通过N次读取直到读取完毕</span><br><span class="line">ET ：一次<span class="number">5</span>字节来读取数据，其余数据，等下次通知再继续读取未读完的数据，所以需要用循环读取数据</span><br><span class="line">    </span><br><span class="line">综上所述：epoll的边沿模式下 <span class="built_in">epoll_wait</span>()检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高</span><br></pre></td></tr></table></figure><h1>linux</h1><h2 id="两个Linux操作系统之间使用什么命令进行文件的传递">两个Linux操作系统之间使用什么命令进行文件的传递?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">两个Linux操作系统之间可以使用SCP、RSYNC 和 SFTP命令进行文件的传递</span><br><span class="line">    </span><br><span class="line"> SCP（Secure Copy）是一种基于SSH协议的文件传输工具，它可以安全地在两台Linux系统之间复制文件。</span><br><span class="line"> RSYNC 是一种更强大的文件复制工具，它不仅可以用于同步文件和文件夹，还可以通过SSH提供安全的数据传输。</span><br><span class="line"> SFTP（SSH File Transfer Protocol）也是基于SSH的文件传输协议，提供交互式的文件上传和下载功能。</span><br><span class="line">    </span><br><span class="line"><span class="built_in">RSYNC</span>(锐谁克)</span><br></pre></td></tr></table></figure><h2 id="常用指令">常用指令</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 查看当前进程︰ps</span><br><span class="line">执行退出︰ exit</span><br><span class="line">查看当前路径: pwd</span><br><span class="line">列出指定目录中的目录，以及文件:  ls </span><br><span class="line">创建目录 : mkdir</span><br><span class="line">创建文件: vi   touch</span><br><span class="line">显示全部: cat</span><br><span class="line">切换目录: cd</span><br><span class="line">复制文件: cp</span><br><span class="line">移动文件: mv</span><br><span class="line">删除文件: rm</span><br><span class="line">查找文件内容:grep</span><br><span class="line">查找文件: find</span><br><span class="line">gcc指令: gcc test.c -o test</span><br><span class="line"></span><br><span class="line">驱动加载: insmod</span><br><span class="line">驱动卸载: rmmod</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="驱动">驱动</h2><h3 id="Uboot启动流程">Uboot启动流程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一阶段</span><br><span class="line">初始化时钟，关闭看门狗，关中断，启动 ICACHE ，关闭 DCACHE 和 TLB，关闭 MMU，初始化 SDRAM，初始化 NAND FLASH，重定位。</span><br><span class="line">第二阶段</span><br><span class="line">初始化一个串口，检测系统内存映射，将内核映象和根文件系统映象从 Flash 上读到SDRAM空间中，为内核设置启动参数，调用内核。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Uboot如何引导内核启动的">Uboot如何引导内核启动的?</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uboot引导内核启动主要向内核传递三个参数RO，R1,R2，第一个参数RO，默认为<span class="number">0</span>。第二个参数，R1 ，CPU ID，告诉内核板载CPU的型号。第三个参数R2，告诉内核映像文件存在什么地方，板子还剩多少内存空间。这些参数的传递都是以 tag_list 的方式传递的。</span><br></pre></td></tr></table></figure><h3 id="为什么需要Uboot-不用行不行？">为什么需要Uboot?不用行不行？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用uboot的目的是引导内核启动。</span><br><span class="line">我理解的，理论是可以的。把uboot中所做的一些工作写进内核里，板子也能启动。但是很少有人这么做，毕竟内核很庞大，大面积修改难度比较大。</span><br></pre></td></tr></table></figure><h3 id="字符设备有哪些-和块设备有什么区别-如何写一个字符设备驱动">字符设备有哪些?和块设备有什么区别?如何写一个字符设备驱动?</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">字符设备有键盘，鼠标等。</span><br><span class="line">    </span><br><span class="line">字符设备和块设备的区别主要是访问方式不同，访问字符设备是以字符流的方式访问的，访问块设备是以块为单位，并且可以随机访问。</span><br><span class="line">    </span><br><span class="line">以一个LED驱动为例，先定义一个 file_operations 结构体，接着编写 init 函数，在init函数中完成对管脚的映射，register_chrdev 字符设备的注册，class_create 类的注册，class_device_create 在类下面注册一个设备。exit 函数中完成字符设备的卸载，类的卸载，内存空间的释放。在open函数中完成硬件管脚的初始化，在write函数中完成点灯操作。</span><br><span class="line">    </span><br><span class="line"><span class="built_in">file_operations</span> (fai_欧扑锐醒)</span><br><span class="line">register_chrdev （ruai 急死特_磕带屋）</span><br><span class="line">class_create （亏A特）</span><br><span class="line">class_device_create（低畏死_亏A特）</span><br><span class="line"><span class="built_in">exit</span> (挨可谁特)</span><br></pre></td></tr></table></figure><h3 id="什么是内核空间-什么是用户空间">什么是内核空间?什么是用户空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对<span class="number">32</span>位操作系统而言,它的虚拟地址空间为<span class="number">4</span>G，就是说一个进程的最大地址空间为<span class="number">4</span>G。</span><br><span class="line">操作系统将虚拟地址空间划分为内核空间和用户空间，最高的<span class="number">1</span>G字节为内核空间，低的<span class="number">3</span>G字节为用户空间</span><br><span class="line">    </span><br><span class="line">或者说</span><br><span class="line">    </span><br><span class="line">每个进程的<span class="number">4</span>G地址空间中，最高<span class="number">1</span>G都是一样的，即内核空间。只有剩余的<span class="number">3</span>G才归进程自己用。换句话说就是，最高<span class="number">1</span>G的内核空间是被所有进程共享的!</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; 其中copy_to_user()用于将内核数据传送给用户空间;copy_from_user()用于将用户空间的数据传送给内核空间。</span></span><br></pre></td></tr></table></figure><h3 id="用户空间和内核空间的通信方式">用户空间和内核空间的通信方式?</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>API函数，Copy_from_user , get_user等。<span class="number">2.</span>proc文件系统  <span class="number">3.</span>mmap系统调用  <span class="number">4.</span>使用文件</span><br></pre></td></tr></table></figure><h3 id="uboot启动为什么要关闭中断，MMU-DCACHE之类的">uboot启动为什么要关闭中断，MMU,DCACHE之类的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非必须关闭吧。uboot的目的就是引导内核启动，而且uboot启动的话只是把需要的打开了，其他非必须的都可以关闭。当然也可以打开。DCACHE之类的必须要关i闭，因为SDRAM没有初始化，可能会取到错误的数据。</span><br></pre></td></tr></table></figure><h3 id="busybox是什么">busybox是什么?</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缩小版的Unix系统常用命令工具箱。主要包含了一些常用的Linux指令，环境等。</span><br></pre></td></tr></table></figure><h3 id="什么是根文件系统">什么是根文件系统</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根文件系统上是内核启动时所挂载的第一个文件系统，内核代码映像文件保存在根文件系统中。</span><br></pre></td></tr></table></figure><h3 id="uboot启动前还需要做那些事情">uboot启动前还需要做那些事情?</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U-Boot启动前需要完成的主要任务包括确定启动入口、设置环境变量、选择启动介质和参数，以及初始化硬件设备。</span><br></pre></td></tr></table></figure><h2 id="bootloader-第一个阶段为什么要足够的小？">bootloader 第一个阶段为什么要足够的小？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一阶段的Bootloader通常存储在引导扇区中，而引导扇区的大小通常为<span class="number">512</span>字节。因此，第一阶段的Bootloader代码长度必须小于这个限制，以确保能够被完整地加载到内存中。</span><br><span class="line">    </span><br><span class="line"> <span class="built_in">bootloader</span> (布特漏的)</span><br></pre></td></tr></table></figure><h1>网络</h1><h2 id="socket编程的流程">socket编程的流程</h2><blockquote><p>udp : 接收数据 recvfrom(); | 发送数据 sendto(); 不用建立连接 connect() | listen（） | accept</p></blockquote><p>服务器端流程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数 					作用</span><br><span class="line"><span class="built_in">socket</span>()		    创建套接字</span><br><span class="line"><span class="built_in">bind</span>()			绑定本地IP地址和端口号</span><br><span class="line"><span class="built_in">listen</span>()		  设置监听队列长度</span><br><span class="line"><span class="built_in">accept</span>()			 等待连接</span><br><span class="line"><span class="built_in">read</span>()				 接收信息</span><br><span class="line"><span class="built_in">close</span>()				关闭套接字</span><br><span class="line">    </span><br><span class="line">accept（啊克塞pt）</span><br></pre></td></tr></table></figure><p>客户端流程:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数					作用</span><br><span class="line"><span class="built_in">socket</span>()			创建套接字</span><br><span class="line"><span class="built_in">connect</span>()			发送连接请求</span><br><span class="line"><span class="built_in">write</span>()				发送信息</span><br><span class="line"><span class="built_in">close</span>()				关闭套接字</span><br><span class="line"></span><br><span class="line">connect（肯来可特）    </span><br></pre></td></tr></table></figure><h2 id="TCP、UDP-的区别？">TCP、UDP 的区别？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）	TCP是面向连接的，UDP是面向无连接的。</span><br><span class="line">（<span class="number">2</span>）	TCP是面向字节流的，UDP是基于数据报的。</span><br><span class="line">（<span class="number">3</span>）	TCP提供可靠服务（正确性、顺序性），UDP提供不可靠服务。</span><br><span class="line">（<span class="number">4</span>）	TCP程序结构复杂，占用资源多；UDP程序结构简单，占用资源少。</span><br><span class="line">（<span class="number">5</span>）	TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低，适合于实时应用，如IP电话、实时视频会议。</span><br><span class="line">（<span class="number">6</span>）	TCP只支持一对一；UDP支持一对一、一对多、多对一、多对多。</span><br></pre></td></tr></table></figure><h2 id="三次握手的和四次挥手">三次握手的和四次挥手</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先他当然可以设置为更多次数的握手或挥手，每一次的握手、挥手都是传输数据的一个方式，但是他这样会导致更多的资源浪费或更多的开销，这样是并不划算的，所有是要在可行的情况下尽量少的去进行握手和挥手的次数</span><br><span class="line">三次握手就是为保证通信双方的一个接收能力和发送能力，我打个比方，比如：我跟你打电话，我说喂你听得见吗？就相当于一次握手，然后你说我能听见，就确保了我的发送能力和你的接收能力，然后你同时再说一句你有听见吗，我回我能听见，就保证了你的发送能力和我的接受能力，这样的话一共就是<span class="number">3</span>次握手（相当于我发了一个SYN给你然后你回了一个ACK+SYN，这个过程相当于你听到我说你听得到吗，你说我听得到你听得到吗,这两句话其实是在同一时该去说的，所以可以合并为一次握手）</span><br><span class="line">四次挥手，他相当于是我要和你说断开连接，并且你也要和我说断开连接，然后断开连接的请示都是在我们的应用层的代码执行块里面去执行的，然后他的ACK的一个返回，他是在内核态里面去执行的，所以并不能保证我的FIN这个断开连接的请示和ACK是同时发送的，所以他就是一个四次挥手的过程</span><br></pre></td></tr></table></figure><h2 id="TCP-为什么是可靠连接？">TCP 为什么是可靠连接？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为TCP传输的数据满足四大条件：不出错、不丢失、不重复、不乱序，而且拥有窗口机制、拥塞控制机制来提高传输效率。</span><br></pre></td></tr></table></figure><h2 id="OSI-七层-TCP-IP-四层">OSI 七层 TCP/IP 四层</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）	七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</span><br><span class="line">    </span><br><span class="line">（<span class="number">3</span>）	四层划分为：应用层、传输层、网络层、网络接口层（物理层）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TCP粘包问题">TCP粘包问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是指在TCP通信过程中，发送方发送的多个数据包在接收方被粘合成一个数据包的现象。这主要是由于TCP是基于字节流的传输协议，数据没有明确的边界，导致接收方无法准确区分每个数据包的起始和结束位置，从而出现粘包现象‌</span><br><span class="line">    </span><br><span class="line">解决:</span><br><span class="line">（ <span class="number">1</span> ） 通过包头 + 包⻓ + 包体的协议形式，当服务器端获取到指定的包⻓时才说明获取完整。</span><br><span class="line">（ <span class="number">2</span> ） 指定包的结束标识，这样当我们获取到指定的标识时，说明包获取完整。</span><br></pre></td></tr></table></figure><h1>arm</h1><h2 id="寄存器置-0-或-1-的问题">寄存器置 0 或 1 的问题</h2><blockquote><p>GPIO 为一个 8 位寄存器 10010100</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>现要将它的第 <span class="number">3</span> 位（从右开始，第 <span class="number">0</span> 位起始），置为 <span class="number">1</span> ，并保持其他位不变。</span><br><span class="line">    GPIO |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);	<span class="comment">//置 GPIO_3 为 1</span></span><br><span class="line">	原理是 <span class="number">1</span> 左移<span class="number">3</span>位，再或上 GPIO，并不会改变其他位的值。</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span>现要将它的第 <span class="number">2</span> 位，置为 <span class="number">0</span>，并保持其他位不变。   </span><br><span class="line">   GPIO &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">2</span>); <span class="comment">//置 GPIO_2 为 0</span></span><br><span class="line">   原理是先将 <span class="number">1</span> 左移 <span class="number">2</span> 位，再进行取反，最后再与上 GPIO，并不会改变其他位的值。</span><br></pre></td></tr></table></figure><h2 id="arm有几个寄存器？">arm有几个寄存器？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">37</span>个寄存器。</span><br></pre></td></tr></table></figure><h2 id="什么是CPSR，SPSR-什么时候用到">什么是CPSR，SPSR ?什么时候用到?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPSR是当前程序状态寄存器，存储的是当前程序的状态</span><br><span class="line">SPSR为备份的程序状态寄存器，主要是中断发生时用来存储CPSR的值的</span><br></pre></td></tr></table></figure><h2 id="什么是交叉编译">什么是交叉编译?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码</span><br></pre></td></tr></table></figure><h2 id="SPI-模式">SPI 模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPI 是一种串行外围设备接口，主要用于 CPU 与各种外围设备之间的全双工、同步串行通信。</span><br></pre></td></tr></table></figure><h2 id="SPI-有-4-种模式你知道是那-4-种模式吗？">SPI 有 4 种模式你知道是那 4 种模式吗？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">它通过时钟极性（CPOL）和时钟相位（CPHA）的组合来定义四种工作模</span><br><span class="line">模式<span class="number">0</span>（CPOL = <span class="number">0</span>, CPHA = <span class="number">0</span>）‌：空闲时时钟线为低电平，数据在第一个时钟沿（上升沿）采样。</span><br><span class="line">模式<span class="number">1</span>（CPOL = <span class="number">0</span>, CPHA = <span class="number">1</span>）‌：空闲时钟线为低电平，数据在第二个时钟沿（下降沿）采样。</span><br><span class="line">模式<span class="number">2</span>（CPOL = <span class="number">1</span>, CPHA = <span class="number">0</span>）‌：空闲时钟线为高电平，数据在第一个时钟沿（下降沿）采样。</span><br><span class="line">模式<span class="number">3</span>（CPOL = <span class="number">1</span>, CPHA = <span class="number">1</span>）‌：空闲时钟线为高电平，数据在第二个时钟沿（上升沿）采样‌</span><br></pre></td></tr></table></figure><h2 id="SPI-有4条线">SPI 有4条线</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">串行时钟线（SCK）</span><br><span class="line">主机输入/从机输出数据线 MISO</span><br><span class="line">主机输出/从机输入数据线 MOSI</span><br><span class="line">低电平有效的从机选择线 SS</span><br></pre></td></tr></table></figure><h2 id="I2C">I2C</h2><blockquote><p>llc协议是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据,是一个多主机的半双工通信方式</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87f0cd0e0a243d4016cbf.png" alt=""></p><h2 id="如何发送一个数据-IIC时序图画下。IC芯片有哪些">如何发送一个数据? IIC时序图画下。IC芯片有哪些</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单片机-&gt;从机</span><br><span class="line">刚开始主芯片要发出一个start信号，然后发出一个(用来确定是往哪一个芯片写数据)，方向(读/写，<span class="number">0</span>表示写，<span class="number">1</span>表示读)。回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EEPROM存储器芯片</span><br><span class="line">IIC触摸芯片</span><br><span class="line">IIC隔离芯片</span><br></pre></td></tr></table></figure><h1>算法和数据结构</h1><h2 id="实现字符串的库函数">实现字符串的库函数</h2><h3 id="strcpy">strcpy ()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mycpy</span><span class="params">(<span class="type">char</span> *s1,<span class="type">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(*s1++ =*s2++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="strlen">strlen</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my1en</span><span class="params">(<span class="type">char</span> *s1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> *p = s1;</span><br><span class="line"><span class="keyword">while</span>(p++);</span><br><span class="line"><span class="keyword">return</span> p - s <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcat">strcat</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mycat</span><span class="params">(<span class="type">char</span> *s1，<span class="type">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">whi1e</span>(*s1++);</span><br><span class="line">s1--;</span><br><span class="line"><span class="keyword">while</span>(*s1++ = *s2++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法">算法</h2><h3 id="反转字符串中的单词">反转字符串中的单词</h3><blockquote><p>示例1:输入:&quot; Let’s take LeetCode contest &quot;</p><p>输出: &quot; s’teL ekat edoCteeL tsetnoc ”</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> temp = str[start];</span><br><span class="line">        str[start] = str[end];</span><br><span class="line">        str[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">reversewords</span><span class="params">(<span class="type">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;<span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">str1en</span>(s);</span><br><span class="line">    <span class="built_in">whi1e</span>(s[end++]!=<span class="string">&#x27;\0 &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(s[end] == <span class="string">&#x27; &#x27;</span> || s[end] == <span class="string">&#x27;\0 &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s,start,end<span class="number">-1</span>);</span><br><span class="line">            start = end+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个数组，找出和为S的数字">一个数组，找出和为S的数字</h3><p>输入一个<strong>递增排序的数组</strong>和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><blockquote><p>思路： <strong>数组是一个递增排序好的，可以采用双指针法</strong>；可以证明的是，a+b=sum， a和b之间相差越大，a*b就越小。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array, <span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> length = array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 定义双指针</span></span><br><span class="line">    <span class="type">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[first] + array[end] == sum)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(array[first]);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(array[end]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[first] + array[end] &gt; sum)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[first] + array[end] &lt; sum)</span><br><span class="line">            first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序">快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本思想:</span><br><span class="line">快速排序通过选择一个基准元素，将数组分为两部分，一部分小于基准，放左边，一部分大于基准，放右边，然后递归地对这两部分进行快速排序‌</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本思想:</span><br><span class="line">把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置。以此类推</span><br></pre></td></tr></table></figure><h3 id="堆排序">堆排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">具体步骤</span><br><span class="line"><span class="number">1.</span>将待排序序列构造成一个大顶堆。</span><br><span class="line"><span class="number">2.</span>此时，整个序列的最大值就是堆顶的根节点。<span class="number">3.</span>将其与末尾元素进行交换，此时末尾就为最大值。</span><br><span class="line"><span class="number">4.</span>然后将剩余n<span class="number">-1</span>个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列;<span class="number">2.</span>取出下一个元素，在已经排序的元素序列中从后向前扫描;</span><br><span class="line"><span class="number">3.</span>如果该元素（已排序)大于新元素，将该元素移到下—位置﹔<span class="number">4.</span>重复步骤<span class="number">3</span>，直到找到已排序的元素小于或者等于新元素的位置;<span class="number">5.</span>将新元素插入到该位置后;</span><br><span class="line"><span class="number">6.</span>重复步骤<span class="number">2</span>~<span class="number">5</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序">选择排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">具体步骤</span><br><span class="line"><span class="number">1.</span>首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置。</span><br><span class="line"><span class="number">2.</span>再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。</span><br><span class="line"><span class="number">3.</span>重复第二步，直到所有元素均排序完毕。</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87e72d0e0a243d4016c9e.png" alt=""></p><h2 id="数据结构">数据结构</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bb15070047748/article/details/119208588">数据结构：八种数据结构大全-CSDN博客</a></p><h3 id="二叉树">二叉树</h3><h4 id="完满二叉树">完满二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有根节点都会有两个子节点。</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树">平衡二叉树</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87dd0d0e0a243d4016c8c.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树就是左右子树度的高度差值不超过<span class="number">1.</span></span><br></pre></td></tr></table></figure><h4 id="二叉树退化">二叉树退化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。</span><br></pre></td></tr></table></figure><h4 id="完美二叉树">完美二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除了叶子节点之外的每个节点都有两个子节点，并且每一层（包括最后一层）都是完全填满的</span><br></pre></td></tr></table></figure><h4 id="完全二叉树">完全二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐</span><br></pre></td></tr></table></figure><h1>操作系统和计算机组成原理</h1><h2 id="MMU（存储器管理单元）">MMU（存储器管理单元）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用来管理虚拟内存系统的器件本身有少量存储空间存放从虚拟地址到物理地址的匹配表。此表称作<span class="built_in">TLB</span>(转换旁置缓冲区)。所有数据请求都送往MMU，由MMU决定数据是在RAM内还是在大容量存储器设备内。如果数据不在存储空间内，MMU将产生页面错误中断。</span><br><span class="line"></span><br><span class="line"> MMU的两个主要功能是:</span><br><span class="line"><span class="number">1.</span> 将虚地址转换成物理地址。</span><br><span class="line"><span class="number">2.</span> 控制存储器存取允许。MMU关掉时，虚地址直接输出到物理地址总线。</span><br><span class="line">    </span><br><span class="line">MMU的作用有两个：地址翻译和地址保护 软件的职责是配置页表，硬件的职责是根据页表完成地址翻译和保护工作。</span><br></pre></td></tr></table></figure><h2 id="堆和栈的区别">堆和栈的区别?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>申请方式，栈的空间由操作系统自动分配，释放，堆上的空间手动分配，释放。</span><br><span class="line"><span class="number">2.</span>申请大小，堆的可用空间比较大，栈的可用空间比较小，一般是<span class="number">2</span>M。</span><br><span class="line"><span class="number">3.</span>申请效率，栈申请速度比较慢，堆的申请速度比较快。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆和栈">堆和栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收</span><br><span class="line">    </span><br><span class="line">栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等</span><br></pre></td></tr></table></figure><h2 id="栈的空间为什么不连续">栈的空间为什么不连续</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈分配的空间在逻辑地址上是连续的，但在物理地址上是不连续的,因为有 可能相邻的两个字节是在不同的物理分页上</span><br></pre></td></tr></table></figure><h2 id="bin文件和elf文件区别">bin文件和elf文件区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin文件是一种纯粹的二进制文件，它只包含机器码</span><br><span class="line">elf文件则是一种复杂的文件格式，用于存储程序或库的代码和数据</span><br></pre></td></tr></table></figure><h2 id="什么是哈希表，又如何使用">什么是哈希表，又如何使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哈希表本质上就是一个数组，只不过数组存放的是单一的数据，而哈希表中存放的是键值对（key - value pair）。 key 通过哈希函数（hash function）得到数组的索引，进而存取索引位置的值。 不同的 key 通过哈希函数可能得到相同的索引值</span><br></pre></td></tr></table></figure><h2 id="用户栈和内核栈是同一个区域吗-有什么区别">用户栈和内核栈是同一个区域吗?有什么区别?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不是。用户栈和内核栈是两个独立的区域。内核栈保存的是内核态程序运行的时候相关寄存器信息，用户栈保存的是用户态的内容</span><br></pre></td></tr></table></figure><h2 id="中断的响应执行流程-听过顶半部和底半部吗-讲讲">中断的响应执行流程?听过顶半部和底半部吗?讲讲</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半部-&gt;恢复中断上下文。</span><br><span class="line">    </span><br><span class="line">顶半部执行一般都是比较紧急的任务，比如清中断。下半部执行的是一些不太紧急的任务，可以节省中断处理的时间。</span><br></pre></td></tr></table></figure><h2 id="uboot启动时使用的是物理地址还是虚拟地址-MMU要开启吗">uboot启动时使用的是物理地址还是虚拟地址? MMU要开启吗?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在uboot阶段并不是必须要开启<span class="built_in">MMU</span>(内存管理单元),在没开启MMU前使用的是物理地址,开启MMU后使用的是虚拟地址</span><br></pre></td></tr></table></figure><h1>C</h1><h2 id="c-五个分区-内存分配">c++ 五个分区(内存分配)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存分配情况 堆区、栈区、静态（全局）区、常量区、代码区</span><br><span class="line">    		</span><br></pre></td></tr></table></figure><h2 id="指针与引用区别">指针与引用区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">指针：指针变量是用来存放内存地址的变量</span><br><span class="line">引用：不是新定义一个变量,而是给已存在变量取一个别名,编译器不会为引用变量开辟内存空间,它和它引用的变量共用同一块内存空间.</span><br><span class="line">	<span class="number">1.</span>初始化:引用在定义时必须初始化,指针则没有要求(尽量初始化,防止野指针)</span><br><span class="line">	引用可以做的事,指针都可以做，引用体现了最小特权原则，指针能够毫无约束的操作内存中的任何东西,尽管功能强大,但是非常危险</span><br></pre></td></tr></table></figure><h2 id="重载-重写-隐藏（重定义）">重载 重写 隐藏（重定义）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重载: 是相同的函数名，但量它的参数不一样，根据传入不同的参数，去执行不同的函数</span><br><span class="line">    </span><br><span class="line">重写：指在子类中重新定义从父类继承的函数，以改变其行为。重写的前提是父类的函数必须是虚函数（在 C++ 中使用 <span class="keyword">virtual</span> 关键字），子类通过相同的函数签名（包括函数名、参数和返回类型）来重新实现该函数</span><br><span class="line">动态多态性：通过指向父类的指针或引用来调用重写的函数时，执行的是子类的实现</span><br><span class="line">    </span><br><span class="line">隐藏（重定义）：</span><br><span class="line">继承关系：同样发生在继承关系中，但与重写不同的是，父类的函数不是虚函数，或者子类定义的函数与父类函数签名不同。</span><br><span class="line">同名但不覆盖：子类的函数与父类的同名函数不会相互覆盖，而是隐藏父类的函数。</span><br><span class="line">静态绑定：根据对象的静态类型调用函数，而不是动态类型。</span><br></pre></td></tr></table></figure><h2 id="volatile">volatile</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">防止对寄存器进行优化，使得每条指令都要按照我们写的进行运行</span><br><span class="line"></span><br><span class="line"> (我 里 太 要)</span><br></pre></td></tr></table></figure><h2 id="static">static</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰变量的话，这个变量的作用域只是本函数,而且如果多次调用函数的话，这个变量只会被初始化—次。修饰函数的话，函数的作用域只是在本文件内。</span><br><span class="line"></span><br><span class="line">(s它踢k)</span><br></pre></td></tr></table></figure><h2 id="死循环有几种方式来写">死循环有几种方式来写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;<span class="number">1</span>;)&#123;&#125;</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line"><span class="function"><span class="keyword">do</span> <span class="title">while</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="左值和右值">左值和右值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左值可写，右值可读。通常，左值可以作为右值，但是右值不一定是左值。</span><br></pre></td></tr></table></figure><h2 id="数组名和指针区别">数组名和指针区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组名对应的是一块内存的地址，指针是指向一块内存地址。数组名对应的内存地址不可以修改，指针指向的内存地址可以修改，更加灵活。数组存放的是数据内容，指针存储的是地址。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编程题︰指针函数，函数的参数为in-t-，返回值为字符指针">编程题︰指针函数，函数的参数为in t ，返回值为字符指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *((*p)(<span class="type">int</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="宏定义求最大数">宏定义求最大数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAx(a, b) (a)&gt;(b)?a:b</span></span><br></pre></td></tr></table></figure><h2 id="typedef-和-define-有什么区别">typedef 和 define 有什么区别?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">typedef</span>在编译时处理，具有类型检查的功能; define在预编译时展开，不会进行错误的检查，只是字符的替换。</span><br><span class="line"><span class="number">2.</span>define没有作用域的限制，<span class="keyword">typedef</span>有自己的作用域。</span><br><span class="line"><span class="number">3.</span><span class="keyword">typedef</span>定义指针的别名时，别名可以连续定义两个指针变量。define定义指针的别名时，使用这个别名连续定义两个指针变量会报错。</span><br><span class="line"></span><br><span class="line"><span class="built_in">typedef</span> (态个打夫)</span><br></pre></td></tr></table></figure><h2 id="函数指针和指针函数有什么区别">函数指针和指针函数有什么区别?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。</span><br><span class="line">而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</span><br><span class="line"><span class="built_in">int</span>(*p)(<span class="type">int</span>，<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">首先它是一个函数，只不过这个函数的返回值是一个地址值.</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">pfun</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="野指针是什么-如何避免野指针">野指针是什么?如何避免野指针?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">野指针是指向不可用内存的指针</span><br><span class="line">当指针被 free 或 <span class="keyword">delete</span> 释放掉时，如果没有把指针设置为<span class="literal">NULL</span>，则会产生野指针</span><br><span class="line">第三个造成野指针的原因是指针操作超越了变量的作用范围。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对指针进行初始化。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="int-a-5-1-2-3-4-5-sizeof-a">int a[5]={1,2,3,4,5},sizeof(a)= ?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a是一个包含<span class="number">5</span>个整数的数组。每个整数在<span class="number">32</span>位系统中通常是<span class="number">4</span>字节（即<span class="number">32</span>位）  <span class="number">4</span>*<span class="number">5</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="数组和链表的区别">数组和链表的区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组：数据顺序存储，固定大小；  </span><br><span class="line">链表：链式存储结构, 数据可以随机存储，大小可动态改变</span><br></pre></td></tr></table></figure><h2 id="const">const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（<span class="number">1</span>）可以定义 <span class="type">const</span> 常量</span><br><span class="line">（<span class="number">2</span>）<span class="type">const</span> 可以修饰函数的参数、返回值，甚至函数的定义体。被 <span class="type">const</span> 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</span><br><span class="line"><span class="type">const</span>意味着<span class="string">&quot;只读&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="什么是智能指针？如何解决其内存泄漏问题？">什么是智能指针？如何解决其内存泄漏问题？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">智能指针是一个类，用来存储指针(指向动态分配对象的指针)。使用智能指针能更好的管理堆内存。</span><br><span class="line">    </span><br><span class="line">引入了弱指针<span class="function">weak_ptr</span></span><br><span class="line"><span class="function"><span class="title">weak_ptr</span><span class="params">(为可_戳)</span></span></span><br></pre></td></tr></table></figure><h2 id="extern-C-”-和-extern-的作用是什么">extern&quot;C&quot;” 和 extern 的作用是什么?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>后，会指示编译器这部分代码按c语言的进行编译，而不是C++的。</span><br><span class="line"><span class="keyword">extern</span> 用于声明全局变量或函数，以便在其他文件中使用</span><br><span class="line">    </span><br><span class="line"><span class="built_in">extern</span>(爱ks等)</span><br></pre></td></tr></table></figure><h2 id="C-语言字节对齐的规则，为什么要字节对齐？">C 语言字节对齐的规则，为什么要字节对齐？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据在内存中的地址对齐到特定的边界,以提高内存访问的效率</span><br></pre></td></tr></table></figure><h2 id="C-为什么有指针还要引用？">C++为什么有指针还要引用？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了支持运算符重载。顺便提一句，既然C++引入了引用，那为什么C++不和Java一样抛弃指针呢？答：为了兼容C语言。</span><br></pre></td></tr></table></figure><h2 id="C-了解吗？C-11-新特性用的多吗">C++了解吗？C++11 新特性用的多吗</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">会的不多，但也有使用，比如：</span><br><span class="line"> <span class="number">1.</span> <span class="literal">nullptr</span> 出现的目的是为了替代 <span class="literal">NULL</span>。</span><br><span class="line"> <span class="number">2.</span> 区间迭代 - 基于范围的 <span class="keyword">for</span> 循环</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> i : arr) &#123;    </span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">auto</span> 能用于推导函数的返回类型（自动辨别变量类型）</span><br><span class="line">    </span><br><span class="line"> <span class="literal">nullptr</span>（no 婆）    <span class="keyword">auto</span>（窝头）</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87e72d0e0a243d4016c9c.png" alt=""></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87e73d0e0a243d4016c9f.png" alt=""></p><h2 id="什么是虚函数">什么是虚函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指向基类的指针在操作它的多态类对象时，可以根据指向的不同类对象调用其相应的函数，这个函数就是虚函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="c-多态">c++ 多态</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实现多态两个必要条件： <span class="number">1.</span>必须指针或者引用调用虚函数。  <span class="number">2.</span>被调用的函数必须是虚函数。</span><br><span class="line">    </span><br><span class="line">通俗来说，多态就是多种形态。多态分为编译时多态（静态多态）和运行时多态（动态多态）</span><br><span class="line">比如买票这个行为，当普通人买票时，是全价买票；学生买票时，是优惠买票（<span class="number">5</span>折或<span class="number">75</span>折）。再比如，同样是动物叫的⼀个行为，传猫对象过去，就是<span class="string">&quot;(&gt;ω&lt;)喵&quot;</span>，传狗对象过去，就是<span class="string">&quot;汪汪&quot;</span>。</span><br></pre></td></tr></table></figure><h2 id="virtual">virtual</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类成员函数前面加<span class="keyword">virtual</span>修饰，那么这个成员函数被称为虚函数。注意非成员函数不能加<span class="keyword">virtual</span>修饰。</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">virtual</span>( w额 挤了)</span><br></pre></td></tr></table></figure><h2 id="智能指针">智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</span><br><span class="line">    </span><br><span class="line"> auto_ptr、unique_ptr、shared_ptr、<span class="built_in">weak_ptr</span>(?)</span><br><span class="line">    	    u尼克       谢的</span><br><span class="line"> shared_ptr往往用的比较多，他与传统指针的区别是，</span><br><span class="line"> 对象a析构了之后，对象b又去调用那个指针，它就会发生断错误之类的，就是会报错，但对于智能指针就没这个问题，智能指针在<span class="keyword">delete</span>之后，它不会马上<span class="keyword">delete</span>,它内部有一个引用计数器，如果引用计数器不为零，它就永远不会<span class="keyword">delete</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="运算符重载">运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义： <span class="keyword">operator</span> 运算符符号</span><br><span class="line"><span class="keyword">operator</span> （欧扑锐特）</span><br></pre></td></tr></table></figure><h2 id="STL">STL</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87dd0d0e0a243d4016c8a.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;容器</span></span><br><span class="line"><span class="string">    1)顺序容器</span></span><br><span class="line"><span class="string">    vector, deque（带克）,list</span></span><br><span class="line"><span class="string">    【vector】  </span></span><br><span class="line"><span class="string">    头文件 &lt;vector&gt;</span></span><br><span class="line"><span class="string">    动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能（大部分情况下是常数时间）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    【deque】</span></span><br><span class="line"><span class="string">    头文件 &lt;deque&gt;    </span></span><br><span class="line"><span class="string">    双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（但次于vector)。在两端增删元素具有较佳的性能(大部分情况下是常数时间）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    【list】</span></span><br><span class="line"><span class="string">    头文件 &lt;list&gt;</span></span><br><span class="line"><span class="string">    双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    2)关联容器</span></span><br><span class="line"><span class="string">    set, multiset（mou t）, map, multimap（mou t）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    【set/multiset】</span></span><br><span class="line"><span class="string">    头文件 &lt;set&gt;</span></span><br><span class="line"><span class="string">    set 即集合。set中不允许相同元素，multiset 中允许存在相同的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    multiset（mou t）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    【map/multimap】</span></span><br><span class="line"><span class="string">    头文件 &lt;map&gt;</span></span><br><span class="line"><span class="string">    map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。</span></span><br><span class="line"><span class="string">    map同multimap的不同在于是否允许相同first值的元素。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;</span>迭代器:</span><br><span class="line">	iterator 类似于指针，可以用来遍历容器中的元素。</span><br><span class="line">    </span><br><span class="line">    iterator（一特锐特）</span><br><span class="line">        </span><br><span class="line"><span class="string">&#x27;函数：</span></span><br><span class="line"><span class="string">    提供了一些函数对象和仿函数，用于实现自定义的算法行为</span></span><br><span class="line"><span class="string">    greater 仿函数 </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;</span>适配器:</span><br><span class="line">	<span class="built_in">stack</span>, <span class="built_in">queue</span>(Q), <span class="built_in">priority_queue</span></span><br><span class="line">    </span><br><span class="line">    【<span class="built_in">stack</span>】</span><br><span class="line">    栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。<span class="string">&quot;后进先出&quot;</span>。</span><br><span class="line">                                                           </span><br><span class="line">                   出栈         入栈                                 </span><br><span class="line">    			   ↖	    ↗</span><br><span class="line">                       \    /                                    </span><br><span class="line">                    ___________</span><br><span class="line">         top——&gt;     |   an    |</span><br><span class="line">                    ———————————                                                       </span><br><span class="line">                    |   ...   |   </span><br><span class="line">                    ———————————                                          </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">      bottom——&gt;     |    a1   |   </span><br><span class="line">                    ———————————       </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span> 是后进先出的数据结构，只能插入，删除，访问栈顶的元素。</span><br><span class="line">    可用 <span class="built_in">vector</span>,  <span class="built_in">list</span>, <span class="built_in">deque</span>来实现。</span><br><span class="line">    </span><br><span class="line">    【<span class="built_in">queue</span>(Q)】</span><br><span class="line">    头文件 &lt;<span class="built_in">queue</span>&gt;</span><br><span class="line">    队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。<span class="string">&quot;先进先出&quot;</span>。</span><br><span class="line"></span><br><span class="line">                        入队                                       </span><br><span class="line">                        \	    </span><br><span class="line">                           ↘                                      </span><br><span class="line">                        ___________</span><br><span class="line">             rear——&gt;    |   an    |</span><br><span class="line">                        ———————————                                                       </span><br><span class="line">                        |   ...   |   </span><br><span class="line">                        ———————————                                          </span><br><span class="line">                        |   ...   |</span><br><span class="line">                        ———————————    </span><br><span class="line">                        |   ...   |</span><br><span class="line">                        ———————————    </span><br><span class="line">           front——&gt;     |    a1   |   </span><br><span class="line">                        ———————————  </span><br><span class="line">                             \</span><br><span class="line">                              ↘   </span><br><span class="line">                                出队                 </span><br><span class="line"></span><br><span class="line">    和<span class="built_in">stack</span> 基本类似，可以用 <span class="built_in">list</span>和<span class="built_in">deque</span>实现。缺省情况下用<span class="built_in">deque</span>实现。</span><br><span class="line">    同样也有push, pop, top函数。但是push发生在队尾；pop, top发生在队头。先进先出。</span><br><span class="line">    有 back 成员函数可以返回队尾元素的引用   </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    【<span class="built_in">priority_queue</span>(拍我瑞踢_Q)】      </span><br><span class="line">    头文件 &lt;<span class="built_in">queue</span>&gt;</span><br><span class="line">    优先级队列。最高优先级元素总是第一个出列</span><br><span class="line">    <span class="built_in">priority_queue</span>()</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;分配器:</span></span><br><span class="line"><span class="string">	负责管理内存的分配和释放，可以自定义来满足特定需求。</span></span><br></pre></td></tr></table></figure><h2 id="类是什么">类是什么</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">类是一种数据类型，用于存储数据和定义行为</span><br><span class="line">    </span><br><span class="line">类的主要特征</span><br><span class="line">封装,继承,多态</span><br><span class="line">    </span><br><span class="line">类的结构：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>（拍我特）: 私有成员，只能在成员函数内访问,可以通过 set , get 来更改</span><br><span class="line">    <span class="keyword">public</span>: 公有成员，可以在任何地方访问</span><br><span class="line">    <span class="built_in">protected</span>(扑太克踢的): 保护成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象是什么">对象是什么</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是类（<span class="keyword">class</span>）的实例，具有类的所有属性和方法</span><br></pre></td></tr></table></figure><h2 id="类（class）与结构体（struct-s抓克t-）和‌-联合体-的区别是什么">类（class）与结构体（struct(s抓克t)）和‌ 联合体 的区别是什么</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">‌C++中类（<span class="keyword">class</span>）与结构体（<span class="keyword">struct</span>）的主要区别在于默认访问权限、继承和多态性等方面。</span><br><span class="line">    默认访问权限</span><br><span class="line">        类：的默认访问修饰符是私有（<span class="keyword">private</span>）</span><br><span class="line">        结构体：默认的访问修饰符是公开（<span class="keyword">public</span>）</span><br><span class="line">    继承</span><br><span class="line">        类‌：类支持继承，并且可以控制继承的访问权限（<span class="keyword">public</span>、<span class="keyword">protected</span>、<span class="keyword">private</span>）</span><br><span class="line">        结构体‌：结构体也可以继承，但继承默认是公有的，且一般在设计上较少用于复杂继承结构‌</span><br><span class="line">    多态性</span><br><span class="line">   		类‌：类支持多态性</span><br><span class="line">    	结构体‌：结构体不支持多态性，</span><br><span class="line">    </span><br><span class="line">联合体：其所有成员共享同一块内存空间。这意味着联合体的每个成员都会覆盖前一个成员的内容，因此联合体只能保存最后一个被赋值的成员的值。</span><br></pre></td></tr></table></figure><h2 id="new-和-malloc">new 和 malloc</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">new</span>操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</span><br><span class="line">  <span class="keyword">new</span>内存分配失败时报错，malloc分配内存失败时返回 <span class="literal">NULL</span> 。</span><br><span class="line">  <span class="keyword">new</span>操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</span><br><span class="line">     </span><br><span class="line">malloc（马楼克）</span><br></pre></td></tr></table></figure><h2 id="new-实现需要类型转换吗">new 实现需要类型转换吗?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‌在C++中使用<span class="keyword">new</span>操作符时，通常不需要进行类型转换，因为<span class="keyword">new</span>操作符本身就负责分配内存并返回正确的类型。</span><br></pre></td></tr></table></figure><h2 id="new-底层是用什么实现的">new 底层是用什么实现的?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span>操作符在底层调用的是 <span class="keyword">operator</span> <span class="keyword">new</span>全局函数，而<span class="keyword">delete</span>操作符在底层调用的是<span class="keyword">operator</span> <span class="keyword">delete</span>全局函数。<span class="keyword">operator</span> <span class="keyword">new</span>函数实际上是对malloc的封装，当内存申请失败时，它会抛出异常而不是返回 <span class="literal">NULL</span>。类似地，<span class="keyword">operator</span> <span class="keyword">delete</span>函数是对 free 的封装‌</span><br><span class="line">      </span><br><span class="line"><span class="built_in">new</span>(拗)     </span><br><span class="line"><span class="built_in">operator</span>(欧扑锐特)</span><br><span class="line">free（福锐）</span><br></pre></td></tr></table></figure><h2 id="构造函数和析构函数能被声明为虚函数吗，为什么">构造函数和析构函数能被声明为虚函数吗，为什么?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造函数：</span><br><span class="line">只有基类指针指向子类对象时，虚函数才用意义。当一个基类指针指向子类对象时，子类对象已经构造好了，已经没有动态绑定的必要了，所以构造函数不能是虚函数。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">析构函数：</span><br><span class="line">析构函数被调用时，对象的构造已经完成，VPTR（虚指针） 和 VTABLE（虚函数表） 也已被正确初始化，因此虚析构函数在实现上是可能的。</span><br><span class="line">且类有继承时，析构函数常常必须为虚函数。</span><br></pre></td></tr></table></figure><h2 id="C-多态，以及怎么实现-虚函数指针-虚函数表">C++多态，以及怎么实现? 虚函数指针 虚函数表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">提到多态，就不得不提到虚函数，因为虚函数是实现多态的基石</span><br><span class="line">虚函数是用<span class="keyword">virtual</span>声明类的成员函数，称之为虚函数。</span><br><span class="line">实现多态的三大步：</span><br><span class="line"><span class="number">1.</span>存在继承关系 子类继承父类</span><br><span class="line"><span class="number">2.</span>子类重写父类的<span class="keyword">virtual</span> function</span><br><span class="line"><span class="number">3.</span>子类以父类的指针或者是引用的身份出现</span><br><span class="line">    </span><br><span class="line">虚函数的实现原理</span><br><span class="line">其中的关键就是两点：虚函数表指针 、虚函数表</span><br><span class="line">    </span><br><span class="line">通俗来说，多态就是多种形态。多态分为编译时多态（静态多态）和运行时多态（动态多态）</span><br><span class="line">比如买票这个行为，当普通人买票时，是全价买票；学生买票时，是优惠买票（<span class="number">5</span>折或<span class="number">75</span>折）。再比如，同样是动物叫的⼀个行为，传猫对象过去，就是<span class="string">&quot;(&gt;ω&lt;)喵&quot;</span>，传狗对象过去，就是<span class="string">&quot;汪汪&quot;</span>。</span><br><span class="line">    </span><br><span class="line">虚函数表？</span><br><span class="line"><span class="number">1.</span>对于每一个有虚函数的类，编译的时候都会生成一个虚函数表。注意，这个虚函数表是在编译的时候都已经生成。</span><br><span class="line"><span class="number">2.</span>虚函数表里面是一组地址的数组（函数指针数组）,他所在的位置就是虚函数表指针里面所存储的地址，它里面所包含的地址就是我们重写了父类的虚函数的地址（没有重写父类的虚函数那么默认的就是父类的函数地址）</span><br><span class="line">    </span><br><span class="line">内存布局 ：   </span><br><span class="line">子类不重写父类虚函数的内存布局</span><br><span class="line">此时子类继承了父类的虚函数，但是没有重写，因此子类的虚函数指针指向的表中依然存放的父类的虚函数，因此也可以看到，里面的地址都是一样的</span><br><span class="line">子类重写父类虚函数的内存布局</span><br><span class="line">这个局部变量中可以看到，重写的函数虚函数表中的地址变了，没重写的函数，在虚函数表中的地址依然没变。</span><br><span class="line">    </span><br><span class="line">虚表指针？</span><br><span class="line"><span class="number">1.</span>每个有虚函数的类的实例里面都有虚表指针。一个有虚函数的类的实例里面有一个或者多个虚表指针，数量取决于有多少个基类是有虚表的。</span><br><span class="line"><span class="number">2.</span>我们把对象首地址开始的<span class="number">4</span>个字节或<span class="number">8</span>个字节，这个位置我们称之为虚函数表指针（可以添加点属性看看位置）。它里面包含一个地址指向的就是虚函数表的地址</span><br><span class="line">    </span><br><span class="line">虚函数表指针和虚函数表的关系</span><br><span class="line">当类中有虚函数时，就会自动产生一个虚函数表指针，这个指针指向一个虚函数表，表中就存放类中定义的虚函数</span><br></pre></td></tr></table></figure><h2 id="红黑树">红黑树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">红黑树是一种自平衡的二叉查找树</span><br><span class="line">    </span><br><span class="line">红黑树主要用于实现高效的查找和排序，如 Linux 内核中的进程调度和空闲内存的管理，C++ STL库中的 map 和 set 容器等均使用了红黑树实现</span><br></pre></td></tr></table></figure><h2 id="hashmap">hashmap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当需要频繁查找数据时,适合用于缓存、索引.</span><br><span class="line">    </span><br><span class="line">冲突：</span><br><span class="line"> 当多个键映射到同一个索引时，就会发生冲突。HashMap使用链表或红黑树来处理冲突。初始时，冲突的元素会以链表的形式存储，当链表长度超过阈值时，会转换为红黑树以提高查找效率。</span><br></pre></td></tr></table></figure><h2 id="哈希">哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">两个或多个不同的键（Key）被哈希函数映射到同一个位置的情况</span><br><span class="line"> </span><br><span class="line">哈希冲突：    </span><br><span class="line"><span class="number">1.</span>开放寻址</span><br><span class="line">  ‌线性探测‌：当发生冲突时，逐个检查下一个位置，直到找到一个空位置。</span><br><span class="line">  二次探测‌：通过平方步长来查找下一个位置，例如<span class="number">1</span>、<span class="number">4</span>、<span class="number">9</span>、<span class="number">16</span>等。</span><br><span class="line">  伪随机探测‌：使用伪随机数生成器来确定下一个位置。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>链式地址法（拉链法）‌</span><br><span class="line">   每个哈希值对应一个链表，冲突的元素插入到对应链表的末尾。</span><br></pre></td></tr></table></figure><h2 id="Linux线程并发时，如何改进锁的使用，减少开销">Linux线程并发时，如何改进锁的使用，减少开销?</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用轻量级锁（如果可能，且适用于多处理器系统）。</span><br><span class="line"></span><br><span class="line">避免在锁保护下执行长时间操作。</span><br><span class="line"></span><br><span class="line">使用读写锁来允许多个线程同时读取数据，而只有一个线程可以修改数据。</span><br><span class="line"></span><br><span class="line">使用原子操作来避免使用锁进行简单的计数等操作。</span><br><span class="line"></span><br><span class="line">使用无锁算法（例如CAS操作）来避免使用传统的互斥锁。</span><br></pre></td></tr></table></figure><h2 id="设计模式">设计模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">创建型模式</span><br><span class="line">	‌单例模式‌：确保一个类只有一个实例，并提供一个全局访问点‌ | 适用于需要全局唯一对象的情况，如全局状态管理器、全局配置对象等‌</span><br><span class="line">    	  饿汉式‌：在类加载时初始化实例，线程安全，但不支持懒加载。</span><br><span class="line">		  懒汉式‌：</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    简单工厂模式：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常有共同的父类。适用于产品类型相对较少且不太可能经常变动的场景</span><br><span class="line">    工厂模式‌：定义一个创建对象的接口，由子类决定实例化哪个类。适用于创建不同类型的对象，如不同类型的组件、数据请求等‌</span><br><span class="line">	抽象工厂模式‌：提供一个创建一系列相关或依赖对象的接口。适用于创建一组相互关联的对象，如UI组件‌</span><br><span class="line">    ‌建造者模式‌：将复杂对象的构建过程与其表示分离，适用于构建复杂对象，如复杂的表单、图表等‌</span><br><span class="line">    </span><br><span class="line">行为型模式</span><br><span class="line">    状态模式‌：允许一个对象在其内部状态改变时改变它的行为‌</span><br><span class="line">	中介者模式‌：用一个中介对象来封装一系列对象的交互‌</span><br><span class="line">    观察者模式:当一个对象状态发生变化时，所有依赖于它的对象都得到通知并被自动更新‌</span><br><span class="line">    策略模式‌：定义一系列算法，并将每一个算法封装起来，使它们可以相互替换‌</span><br></pre></td></tr></table></figure><h2 id="拷贝构造">拷贝构造</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">2024</span> ,<span class="type">int</span> month = <span class="number">3</span> ,<span class="type">int</span> day = <span class="number">13</span>)    <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d)      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		_year = d._year;</span><br><span class="line">		_month = d._month;</span><br><span class="line">		_day = d._day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;今天的日期是 ：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; _year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; _month &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Date</span>()                        <span class="comment">// 析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		_year = <span class="number">0</span>;</span><br><span class="line">		_month = <span class="number">0</span>;</span><br><span class="line">		_day = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Date d1;</span><br><span class="line">	d1.<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 创建一个与已存在对象一某一样的新对象</span></span><br><span class="line">	<span class="function">Date <span class="title">d2</span><span class="params">(d1)</span></span>;   <span class="comment">// 拷贝构造</span></span><br><span class="line">	d2.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">概念：创建一个与已存在对象一某一样的新对象</span><br><span class="line">	 其唯一的形参必须是引用，但并不限制为<span class="type">const</span>，一般普遍的会加上<span class="type">const</span>限制。</span><br><span class="line">    </span><br><span class="line">问题<span class="number">1</span>：为什么形参一定要是引用呢？</span><br><span class="line">     如果拷贝构造函数中的参数不是一个引用，那么就相当于采用了传值的方式，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用 | 为了防止无限制的内存拷贝</span><br><span class="line">    </span><br><span class="line">问题<span class="number">2</span>：可不可以不用<span class="type">const</span></span><br><span class="line">      用 <span class="type">const</span> 是为了：  <span class="number">1.</span>防止误操作将原对象内容修改   <span class="number">2.</span>防止传入<span class="type">const</span>对象造成【权限放大】</span><br><span class="line">    </span><br><span class="line">浅拷贝：</span><br><span class="line">     浅拷贝会把指针变量的地址复制</span><br><span class="line">深拷贝：</span><br><span class="line">     深拷贝会重新开辟内存空间。  		malloc（马楼克）：开辟内存空间</span><br><span class="line">     当数据成员中有指针时，必须要用深拷贝。</span><br><span class="line">    </span><br><span class="line">你可以观察在当前这这个类中是否存在显式的析构函数，若是存在的话，表示当前这个类涉及资源管理了【资源管理指得就是去堆中申请空间了】，此时你一定要自己去是实现拷贝构造以达到一个深拷贝；</span><br><span class="line">若是不涉及资源管理的话，直接使用编译器自动生成的进行浅拷贝就可以了</span><br><span class="line">像Date日期类这种只存在【年】、【月】、【日】这种内置类型的浅拷贝就可以了；</span><br><span class="line">像是复杂一些的，例如：链表、二叉树、哈希表这些都会涉及资源的管理，就要考虑到深拷贝了</span><br></pre></td></tr></table></figure><h2 id="移动构造函数">移动构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">移动构造函数使用右值引用作为参数，并且我们将原始对象的资源直接转移到新对象中，而不是进行复制。这就如同快递员将家具从旧的房子搬到新的房子中，节省了时间和空间开销。</span><br><span class="line"></span><br><span class="line">总的来说：可以理解为快速的拷贝构造函数</span><br><span class="line">    </span><br><span class="line">格式：</span><br><span class="line">	在构造函数后面写 <span class="keyword">noexcept</span>（no易克死 塞pt）</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">C++基础知识</span><br><span class="line"><span class="number">0</span>、基础  基本类型<span class="type">int</span>、<span class="type">long</span>、数组，控制循环<span class="keyword">for</span> <span class="keyword">if</span> <span class="keyword">while</span> swtich， <span class="keyword">continue</span> 与 <span class="keyword">break</span> 区别</span><br><span class="line"><span class="number">1</span>、c++面向对象，三大特性的理解 继承 封装 多态（一个接口多种实现）</span><br><span class="line"><span class="number">2</span>、c++与c的区别（面向对象与面向过程差异）</span><br><span class="line"><span class="number">3</span>、c++三种继承的特点，<span class="keyword">public</span>、protect、<span class="keyword">private</span> 类型</span><br><span class="line"><span class="number">4</span>、c++重载、重写、重定义（动态） 、模板（静态） </span><br><span class="line"> https:<span class="comment">//blog.csdn.net/qq_37018534/article/details/121330896</span></span><br><span class="line"><span class="number">5</span>、构造函数、析构函数、拷贝构造、赋值运算符等   六种默认函数</span><br><span class="line"><span class="number">6</span>、继承中构造函数与析构函数的调用顺序</span><br><span class="line"><span class="number">7</span>、浅拷贝、深拷贝  </span><br><span class="line"><span class="number">8</span>、虚函数与纯虚函数的区别、以及析构函数为啥继承时须要定义为虚析构函数  </span><br><span class="line"> https:<span class="comment">//blog.csdn.net/qq_42247231/article/details/105109709</span></span><br><span class="line"><span class="number">9</span>、c++ stl库有那些vector、list、set、queue、array、set、deque以及各自的优缺点</span><br><span class="line"><span class="number">10</span>、c++<span class="number">11</span> c++<span class="number">14</span> c++<span class="number">17</span>有那些新特性，至少要把c++<span class="number">11</span> <span class="number">14</span>中的新特性了解下</span><br><span class="line"><span class="number">11</span>、c++四种智能指针，为何会出现智能指针 auto_ptr、unique_ptr、shared_ptr、<span class="built_in">weak_ptr</span>(?)</span><br><span class="line"><span class="number">12</span>、c++四种类型转换 <span class="keyword">static_cast</span>、<span class="keyword">dynamic_cast</span>、<span class="keyword">const_cast</span>、<span class="keyword">reinterpret_cast</span></span><br><span class="line"> https:<span class="comment">//blog.csdn.net/weixin_52983138/article/details/125909103</span></span><br><span class="line"><span class="number">13</span>、RAII原则用法 </span><br><span class="line"><span class="number">12</span>、内存分配情况 堆区、栈区、全局区、文字常量区、代码区</span><br><span class="line"><span class="number">13</span>、指针与引用区别 https:<span class="comment">//blog.csdn.net/HUAERBUSHI521/article/details/118368696</span></span><br><span class="line"></span><br><span class="line">指针：指针变量是用来存放内存地址的变量</span><br><span class="line">引用：不是新定义一个变量,而是给已存在变量取一个别名,编译器不会为引用变量开辟内存空间,它和它引用的变量共用同一块内存空间.</span><br><span class="line">	<span class="number">1.</span>初始化:引用在定义时必须初始化,指针则没有要求(尽量初始化,防止野指针)</span><br><span class="line">	引用可以做的事,指针都可以做，引用体现了最小特权原则，指针能够毫无约束的操作内存中的任何东西,尽管功能强大,但是非常危险</span><br><span class="line">        </span><br><span class="line"><span class="number">14</span>、堆栈的区别，先进先出，后进后出等</span><br><span class="line"><span class="number">15</span>、<span class="type">const</span>、<span class="type">static</span>的用法与区别，比如<span class="type">const</span> <span class="type">char</span>* 与<span class="type">char</span> *<span class="type">const</span> 与 <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> 区别？<span class="built_in">func</span>()<span class="type">const</span>作用是什么？</span><br><span class="line"><span class="number">16</span>、右值、右值引用、左值、左值引用   </span><br><span class="line"><span class="number">17</span>、c++完美转发  </span><br><span class="line">   所谓完美转发就是不改变值原本属性进行转发。右值引用时是为了提高效率</span><br><span class="line"><span class="number">18</span>、C++程序中如何调用被C编译器编译后的函数 <span class="keyword">extern</span> C</span><br><span class="line"><span class="number">19</span>、虚函数表、虚指针关系  （虚析构函数+虚构造函数？）</span><br><span class="line"><span class="number">20</span>、模板与泛型编程<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;与<span class="keyword">template</span>&lt;clasa A,<span class="keyword">class</span> <span class="title class_">B</span>&gt; </span><br><span class="line"><span class="number">21</span>、多种排序算法，如冒泡、二分查找、选择排序、插入排序、快速排序等 时间复杂度 </span><br><span class="line"><span class="number">22</span>、<span class="keyword">sizeof</span>与strlen区别，<span class="keyword">enum</span>与<span class="keyword">struct</span>区别？ <span class="keyword">class</span>与<span class="keyword">struct</span>区别？<span class="type">const</span>与<span class="meta">#<span class="keyword">define</span>有何优点?typedef 和 <span class="keyword">define</span> 有什么区别?strcpy、memcpy的区别</span></span><br><span class="line"><span class="number">23</span>、大小端问题与判定系统大小端，tcp的分包拆包原理</span><br><span class="line"><span class="number">24</span>、可执行程序、动态库、静态库编译的过程 so，a，exe, makefile 了解下或者dll exe,动态库与静态库区别等</span><br><span class="line"><span class="number">25</span>、多线程编程、互斥、同步等，生产者与消费者队列原理加深对锁、信号量、条件变量的理解</span><br><span class="line"><span class="number">26</span>、什么是死锁问题如何解决、什么是内存泄漏如何解决</span><br></pre></td></tr></table></figure><h2 id="内存泄露">内存泄露</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67c46427d0e0a243d40a2ca3.png" alt=""></p><h1>QT</h1><h2 id="Qt信号槽-几种连接方式-connect函数">Qt信号槽?几种连接方式? connect函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">以下是 connect 函数的五个参数及其含义：</span><br><span class="line">第一个参数：发送信号的对象</span><br><span class="line">第二个参数：发送信号的信号名</span><br><span class="line">第三个参数：接收信号的对象</span><br><span class="line">第四个参数：接收信号的槽名</span><br><span class="line">第五个参数：连接类型(ConnectionType)</span><br><span class="line"></span><br><span class="line">连接类型：</span><br><span class="line"> 默认连接‌：如果是在同一线程等价于直连，在不同线程等价于队列连接。</span><br><span class="line">‌直连‌：信号在哪，在哪个线程执行。最好只在同一线程中使用‌。</span><br><span class="line">‌队列连接‌：槽在哪就在哪个线程执行。槽函数不会立刻执行，等到接收者的当前执行的函数执行完才会执行槽函数‌<span class="number">1</span>。</span><br><span class="line">‌阻塞队列连接‌：在槽函数返回之前，槽函数所在的线程都会被阻塞。</span><br><span class="line">‌唯一连接‌：和直连方式相同，但是只能一对一连接。</span><br></pre></td></tr></table></figure><h2 id="为什么用Qt">为什么用Qt</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">跨平台开</span><br><span class="line">高性能和稳定性</span><br><span class="line">丰富的API和工具</span><br><span class="line">灵活的UI设计</span><br><span class="line">多线程编程和国际化支持</span><br></pre></td></tr></table></figure><h2 id="Qt控件，自定义控件">Qt控件，自定义控件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建一个新的类，该类必须继承自 QWidget</span><br><span class="line"><span class="number">2.</span>并在构造函数中设置了控件的样式</span><br><span class="line"><span class="number">3.</span>重写 paintEvent、mousePressEvent 等方法来实现更多的功能</span><br><span class="line">  比如：重写 paintEvent 函数，你可以对控件的外观进行自定义</span><br><span class="line">        重写 mousePressEvent 函数来处理鼠标点击事件，改变控件的状态或外观</span><br><span class="line"><span class="built_in">paintEvent</span>(盆特 一问特)</span><br><span class="line">mousePressEvent（猫死 扑ruai死 一问特）</span><br><span class="line">Widget：威几特</span><br></pre></td></tr></table></figure><h2 id="PV操作">PV操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一种实现进程互斥与同步的有效方法。‌它通过信号量机制来控制对共享资源的访问，确保在任意时刻只有一个进程可以访问该资源.</span><br><span class="line">在生产者-消费者问题中，PV操作可以用来控制生产者和消费者对共享缓冲区的访问，确保在缓冲区满时生产者等待，缓冲区空时消费者等待。</span><br></pre></td></tr></table></figure><h2 id="对QT的理解">对QT的理解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">QT的核心是槽函数与信号，你不用考虑它像windons那样什么时候调用，你只需要知识那个是接口那个是信号，把它们连接起来，当信号被触发这个动作就会被执行，相比标准的C++需要设置回调函数，qt只需要一个connect，并且有一个父类包含所有的类，就可以在这个类里进行所有的connect</span><br><span class="line"></span><br><span class="line">如何调试</span><br><span class="line">断点调试，输出debug日志</span><br><span class="line">    </span><br><span class="line">比如说，qt程序崩溃了</span><br><span class="line">    可能是调用了不该调用的值，就是空指针这种访问了不访访问的内存 经常是这种问题</span><br><span class="line">    我那个点餐系统的项目我就遇到过，崩溃的点是在调用空指针那里，你需要定位到那个初始化实例那时，定位的话，是用那个函数的调用栈来回溯看一下是哪里调用过来的（qt下面框那里有的选择），然后往上看，发现是实例没有初始化成功，再看为什么没有初始化成功，输入的参数要包含一些插件，然后检查文件，发现文件下面确实没有放那些插件和库，然后把它装上去之后（就是拷贝到运行目录下之后就正常了）</span><br><span class="line">    </span><br><span class="line">qt卡死一直转圈圈（界面卡死）</span><br><span class="line">    可能是进到了一个死循环，检查一下最近做了什么操作，去对应的响应函数里去找</span><br><span class="line">    如果找到，如何解决？</span><br><span class="line">    首先把响应的逻辑盘清楚，之后再对那些关键的循环条件进行一个输出，每次输出一下，就可以知道是不是条件有问题，条件有问题，改一下就可以了</span><br><span class="line">    </span><br><span class="line">    假设有一个界面，必须要这个逻辑等数字界面化之后，它就是同步的，该怎么搞？</span><br><span class="line">    	可以新建一个线程，有后台初始化，然后界面的话是不会卡的，但是还是要等，要等它初始化完</span><br><span class="line">    </span><br><span class="line">qt版本问题（版本<span class="number">5</span>与版本<span class="number">6</span>的区别）</span><br><span class="line">    我用的<span class="number">6.4</span><span class="number">.0</span>，<span class="number">5.8</span><span class="number">.2</span>也用过，</span><br><span class="line">    区别很大，qt5为了兼容windows的一些库，但是qt6就已经进行了一个大型的重构，已经没有那种库了，</span><br><span class="line">    如果你用qt6是根本不能够运行qt5的项目的，想要编译就必须去qt maintain tools里面把qt5给安装然后在项目里更改使用qt5</span><br><span class="line">    </span><br><span class="line">多线程下qt的信号与槽分别是在那个线程执行是怎么控制</span><br><span class="line">    connect后面有个参数，有个queen（愧），可以去帮助文档里找到那个枚举，你把它改成quee,就是专门用来加入队列的多线程的，这样就不会有那种多线程的问题，如果是单线程，让它默认就好</span><br><span class="line">    </span><br><span class="line">QSS</span><br><span class="line">    是样式设计嘛，我美术功底一般，就了解不多</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="qt界面开发和json使用方面的经验">qt界面开发和json使用方面的经验</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">qt</span><br><span class="line"><span class="number">1.1</span>界面开发:</span><br><span class="line">使用Qt Designer：Qt Designer是一个可视化工具，可以快速设计UI。通过拖放控件，生成.ui文件，再通过uic工具将其转换为C++代码。</span><br><span class="line">布局管理：使用布局管理器（如QVBoxLayout、QHBoxLayout、QGridLayout）来管理控件的位置和大小，确保界面在不同分辨率下自适应。</span><br><span class="line">信号与槽机制：Qt的信号与槽机制是处理事件的核心。通过 connect 函数将信号与槽连接，实现控件之间的交互。</span><br><span class="line"><span class="number">1.2</span> 自定义控件</span><br><span class="line">继承QWidget：如果需要自定义控件，可以继承QWidget或其它Qt控件，重写paintEvent等方法来实现自定义绘制。</span><br><span class="line">样式表：使用Qt的样式表（QSS）可以轻松定制控件的外观，类似于CSS。</span><br><span class="line"><span class="number">1.3</span> 多线程</span><br><span class="line">QThread：对于耗时操作，使用QThread来避免界面卡顿。注意线程间的通信，确保线程安全。</span><br><span class="line">信号与槽跨线程：Qt的信号与槽机制支持跨线程通信，但要注意线程间的数据共享问题。</span><br><span class="line">    </span><br><span class="line">Designer: 滴rai了    Layout: 累奥特     widget: 威几特</span><br><span class="line">    </span><br><span class="line">JSON使用经验‌：</span><br><span class="line">‌数据交换格式‌：JSON作为一种轻量级的数据交换格式，在Qt开发中得到了广泛应用。它易于人阅读和编写，同时也易于机器解析和生成，非常适合用于网络传输和配置文件。</span><br><span class="line">‌Qt中的JSON支持‌：Qt提供了丰富的API来解析、修改和保存JSON数据。主要使用的类包括QJsonDocument、QJsonArray、QJsonObject和QJsonValue等。这些类提供了便捷的方法来操作JSON数据，如读取、写入、遍历和修改等。</span><br><span class="line">‌数据解析与生成‌：在使用JSON时，经常需要将JSON字符串解析为Qt对象（如QJsonObject、QJsonArray等），或者将Qt对象序列化为JSON字符串。</span><br><span class="line">    </span><br><span class="line">    Document：多克门的   Array：额为    </span><br></pre></td></tr></table></figure><h2 id="信号槽机制">信号槽机制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你不用考虑它像windons那样什么时候调用，你只需要知识那个是接口那个是信号，把它们连接起来，当信号被触发这个动作就会被执行，相比标准的C++需要设置回调函数，qt只需要一个connect，并且有一个父类包含所有的类，就可以在这个类里进行所有的connect.以“基于imx6ull的智能家居项目”中的灯光控制为例，在Qt界面中，当用户点击控制LED灯的按钮时，按钮对象会发出一个信号，灯光控制模块连接了按钮的点击信号到一个槽函数上。这个槽函数的职责是根据信号携带的信息（如LED灯应该打开还是关闭）来改变LED灯的实际状态。</span><br></pre></td></tr></table></figure><h2 id="事件">事件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Qt将系统产生的信号转换成Qt事件，并且将事件封装成类,所以说QT程序是事件驱动的</span><br><span class="line">    </span><br><span class="line">常见的QT事件类型？</span><br><span class="line">键盘事件: 按键按下和松开 </span><br><span class="line">鼠标事件: 鼠标移动,鼠标按键的按下和松开</span><br><span class="line">拖放事件: 用鼠标进行拖放 滚轮事件: 鼠标滚轮滚动</span><br><span class="line">绘屏事件: 重绘屏幕的某些部分 定时事件: 定时器到时</span><br><span class="line">焦点事件: 键盘焦点移动 进入和离开事件: 鼠标移入widget之内,或是移出</span><br><span class="line">    </span><br><span class="line">QT事件机制有几种级别的事件过滤</span><br><span class="line"> 从弱到强</span><br><span class="line"> 重写特定事件处理函数.</span><br><span class="line"> 重写<span class="built_in">event</span>()函数</span><br><span class="line"> 在Qt对象上安装事件过滤器</span><br><span class="line"> 给QAppliction对象安装事件过滤器.</span><br><span class="line"> 继承QApplication类,并重写<span class="built_in">notify</span>()函数.</span><br></pre></td></tr></table></figure><h2 id="Qt三大核心机制">Qt三大核心机制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Qt三大核心机制：信号槽、元对象系统、事件模型</span><br><span class="line">  元对象系统：三大类（QObject类、Q_OBJECT宏和元对象编译器moc）</span><br><span class="line">    			QObject是所有Qt对象的基类</span><br><span class="line">    			Q_OBJECT宏是每个Qt对象类必须使用的宏</span><br><span class="line">    			元对象编译器moc为 QObject的子类实现元对象特性提供必要的代码。</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/issue/tutorial?tutorialId=93&amp;uuid=f982cd252694499181bcf1bb83780cad">【C++工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网 (nowcoder.com)</a></p><h1>自我介绍</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自我介绍:面试官你好，我叫***，来自湖北，我的技术栈是C++，熟悉linux的C++/arm开发，熟悉QT有比较丰富的项目经验。所以我想找一份C++开发的工作，非常开心认识您，在这里也提前感谢您接下来的面试，谢谢。</span><br></pre></td></tr></table></figure><h1>实习</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67bc3aa1d0e0a243d4036c8b.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">在实习期间，我参与了实验数据综合处理平台软件的开发工作。该项目是一个军工合作项目，旨在实现实验数据的收集、处理和可视化功能。我的主要贡献包括：</span><br><span class="line">在该项目中，我主要负责了系统数据结构的设计，使用多线程并发实现了多种类型和数据格式的文件导入与解析，处理数据量超过<span class="number">5</span>万条。我还采用了模块化设计来提高软件的可扩展性，并使用全局事件处理机制实现模块间的信号槽连接。此外，你还基于原始数据或处理后的数据实现了数据可视化功能，支持多种绘图方式和文件导出。技术栈方面，我使用了C++、Qt和 Matlab（妈头不）。</span><br><span class="line">通过这些工作，我不仅提升了自己的编程能力，还学会了如何在团队中协作，确保项目按时交付。</span><br><span class="line">    </span><br><span class="line"> Matlab：   主要用于矩阵运算、科学计算和可视化。‌</span><br><span class="line">核心功能与特性‌</span><br><span class="line">‌矩阵计算‌：以矩阵为基本运算单元，支持高效的数值计算与符号运算，简化线性代数、微积分等数学操作‌<span class="number">13</span>。</span><br><span class="line">‌可视化与绘图‌：提供丰富的二维/三维图形绘制功能，支持曲面图、动态仿真、数据拟合等复杂场景的可视化‌<span class="number">45</span>。</span><br><span class="line">‌工具箱扩展‌：内置‌<span class="number">60</span>+领域专用工具箱‌（如信号处理、深度学习、控制系统等），覆盖工程、金融、生物医学等多学科需求‌<span class="number">16</span>。</span><br><span class="line">‌跨语言集成‌：支持与C/C++、Java、Python等语言交互，便于复杂系统的联合开发‌</span><br><span class="line">    </span><br><span class="line">### 模拟面试官提问及回答 </span><br><span class="line"> </span><br><span class="line">#### <span class="number">1.</span> **技术细节**</span><br><span class="line">**提问：**  </span><br><span class="line">你在项目中使用了哪些技术？能否详细说明你在多线程处理中的具体实现？</span><br><span class="line"> </span><br><span class="line">**回答：**  </span><br><span class="line">在该项目中，我主要使用了C++、Qt和Matlab等技术栈。在多线程处理方面，我利用Qt的QThread类实现了多线程并发机制。具体来说，我针对<span class="number">9</span>种不同类型和<span class="number">3</span>种格式的数据文件设计了独立的线程来负责数据的导入与解析。通过这种方式，我们能够同时处理多个数据文件，显著提高了数据处理的效率。此外，我还采用了信号与槽机制来实现线程之间的通信，确保主线程能够及时获取子线程的处理结果。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">2.</span> **模块化设计**</span><br><span class="line">**提问：**  </span><br><span class="line">你提到采用了模块化设计，请问这种设计带来了哪些好处？你是如何实现模块间通信的？</span><br><span class="line"> </span><br><span class="line">**回答：**  </span><br><span class="line">模块化设计的主要好处在于提高了软件的可扩展性和维护性。通过将不同的功能模块分离，我们可以独立开发和测试每个模块，从而减少了耦合度，提高了代码的复用性。在实现模块间通信时，我采用了全局事件处理机制。具体来说，每个模块都会注册到一个全局事件总线上，并通过信号槽机制与其他模块进行交互。这种设计不仅简化了模块间的通信，还使得系统的扩展变得更加灵活。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">3.</span> **数据可视化**</span><br><span class="line">**提问：**  </span><br><span class="line">在数据可视化部分，你们支持了多种绘图方式，请问具体有哪些方式？在实现过程中遇到了哪些挑战？</span><br><span class="line"> </span><br><span class="line">**回答：**  </span><br><span class="line">在数据可视化部分，我们支持了包括折线图、柱状图、散点图等多种绘图方式。用户可以通过绘图菜单对图像的属性进行编辑，并支持<span class="number">5</span>种格式的绘图文件导出。此外，用户还可以将导出的绘图数据重新导入以生成新的图像。</span><br><span class="line"> </span><br><span class="line">在实现过程中，最大的挑战是如何确保数据可视化功能的高效性和稳定性。由于数据量较大，我们需要优化绘图算法以减少渲染时间。为此，我采用了分层渲染的技术，并对绘图数据进行了预处理，从而显著提升了绘图性能。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">4.</span> **项目管理与沟通**</span><br><span class="line">**提问：**  </span><br><span class="line">作为实习生，你是如何与项目经理和客户进行沟通的？能否分享一次印象深刻的沟通经历？</span><br><span class="line"> </span><br><span class="line">**回答：**  </span><br><span class="line">在项目管理方面，我主要协助项目经理与客户进行需求沟通和技术交流。我通过定期参加项目会议、编写项目文档等方式，确保项目进展与客户需求保持一致。印象最深刻的一次沟通经历是在项目中期评审时，客户提出了一个新的需求，要求增加对某种新型数据格式的支持。当时距离项目交付仅剩两周时间，我迅速与团队成员讨论解决方案，并向项目经理汇报了可行性分析。最终，我们通过加班加点的努力，在规定时间内完成了新功能的开发和测试，并顺利通过了客户的验收。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">5.</span> **问题解决**</span><br><span class="line">**提问：**  </span><br><span class="line">在项目实施过程中，你遇到了哪些困难？你是如何解决的？</span><br><span class="line"> </span><br><span class="line">**回答：**  </span><br><span class="line">在项目实施过程中，最大的困难是如何在有限的时间内完成对多种数据格式的支持。由于每种数据格式都有其独特的解析规则，我们需要逐一攻克这些技术难点。为了解决这个问题，我采取了以下措施：</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> **需求分析**：首先对每种数据格式的需求进行详细分析，明确解析规则和数据结构。</span><br><span class="line"><span class="number">2.</span> **模块化开发**：针对每种数据格式设计独立的解析模块，并通过统一的接口进行调用。</span><br><span class="line"><span class="number">3.</span> **自动化测试**：编写自动化测试脚本，对每种数据格式的解析结果进行验证，确保准确性。</span><br><span class="line"><span class="number">4.</span> **团队协作**：与团队成员密切配合，分工合作，共同解决问题。</span><br><span class="line"> </span><br><span class="line">通过以上措施，我们成功在规定时间内完成了所有数据格式的支持，并确保了系统的稳定性和可靠性。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">6.</span> **个人贡献**</span><br><span class="line">**提问：**  </span><br><span class="line">在整个项目中，你的个人贡献是什么？你认为自己最大的亮点在哪里？</span><br><span class="line"> </span><br><span class="line">**回答：**  </span><br><span class="line">在整个项目中，我的个人贡献主要体现在以下几个方面：</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> **核心功能开发**：我负责了系统数据结构的设计以及多线程数据导入与解析模块的开发，为项目的顺利推进奠定了基础。</span><br><span class="line"><span class="number">2.</span> **模块化设计与通信机制**：我主导了模块化设计的实现，并通过全局事件处理机制确保了模块间的高效通信。</span><br><span class="line"><span class="number">3.</span> **数据可视化功能实现**：我完成了多种绘图方式的支持，并优化了绘图性能，提升了用户体验。</span><br><span class="line"><span class="number">4.</span> **项目文档撰写与沟通支持**：我协助完成了项目开发文档的撰写，并参与了与项目经理和客户的沟通工作。</span><br><span class="line"> </span><br><span class="line">我认为自己最大的亮点在于能够将理论知识与实际项目相结合，并在实践中不断学习和创新。无论是面对技术难题还是项目管理挑战，我都能够保持积极的态度并找到有效的解决方案。</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 总结 </span><br><span class="line">通过以上模拟面试提问与回答，可以看出我在项目中的技术能力、团队协作能力和问题解决能力。我相信这些经验将为未来的职业发展奠定坚实的基础。</span><br><span class="line"></span><br><span class="line">‎Z  <span class="number">16</span>:<span class="number">11</span>:<span class="number">49</span></span><br><span class="line">多线程处理是提升程序性能的重要手段，但如何进一步优化多线程的效率和稳定性是一个复杂且关键的问题。以下从多个角度详细探讨多线程处理的优化方法：</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 一、**性能优化**</span><br><span class="line"> </span><br><span class="line">#### <span class="number">1.</span> **减少锁竞争**</span><br><span class="line">- **锁粒度细化**：尽量减小锁的范围，避免将过多的操作包含在同一个锁中。例如，可以将一个大锁拆分为多个小锁，分别保护不同的资源。</span><br><span class="line">- **无锁算法**：在某些场景下，可以使用无锁算法（如CAS操作）替代传统的互斥锁，减少锁带来的性能开销。</span><br><span class="line">- **读写锁**：对于频繁读取但较少修改的场景，可以使用读写锁（如`<span class="type">pthread_rwlock_t</span>`），允许多个线程同时读取，但写入时独占锁。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">2.</span> **任务划分与负载均衡**</span><br><span class="line">- **细粒度任务划分**：将任务分解为尽可能小的子任务，确保每个线程都能高效执行。</span><br><span class="line">- **动态负载均衡**：根据线程的执行速度和任务的复杂度动态调整任务分配，避免某些线程空闲而其他线程过载。</span><br><span class="line">- **工作窃取（Work Stealing）**：当某个线程完成任务后，可以从其他线程的任务队列中“窃取”任务执行，平衡整体负载。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">3.</span> **减少上下文切换**</span><br><span class="line">- **绑定CPU核**：通过绑定线程到特定的CPU核（如使用`pthread_setaffinity_np`），减少线程在不同CPU核之间切换的开销。</span><br><span class="line">- **避免频繁创建和销毁线程**：线程的创建和销毁会有较大的开销，建议使用线程池来复用线程。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">4.</span> **利用现代处理器特性**</span><br><span class="line">- **SIMD指令**：在多线程处理中结合SIMD（单指令多数据）指令（如AVX、NEON），加速向量化计算。</span><br><span class="line">- **缓存友好设计**：尽量让数据访问模式符合CPU缓存的工作原理，减少缓存未命中。</span><br><span class="line">- **内存屏障**：合理使用内存屏障（Memory Barrier）确保多线程之间的内存可见性，避免不必要的性能损失。</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 二、**资源管理优化**</span><br><span class="line"> </span><br><span class="line">#### <span class="number">1.</span> **内存管理**</span><br><span class="line">- **共享内存池**：为多个线程提供共享的内存池，减少内存分配和释放的开销。</span><br><span class="line">- **避免频繁malloc/free**：使用内存池或对象池技术，复用内存块，减少动态内存管理的开销。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">2.</span> **I/O操作优化**</span><br><span class="line">- **异步I/O**：对于I/O密集型任务，使用异步I/O（如 epoll、aio）代替同步阻塞操作，避免阻塞线程。</span><br><span class="line">- **零拷贝技术**：在处理大量数据传输时，使用零拷贝技术（如`mmap`或`sendfile`）减少数据复制的次数。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">3.</span> **数据库与网络操作**</span><br><span class="line">- **连接池**：对于数据库或网络操作，使用连接池复用连接资源，避免频繁建立和释放连接。</span><br><span class="line">- **批量处理**：将多个操作合并为一个批量请求，减少网络往返次数。</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 三、**代码结构优化**</span><br><span class="line"> </span><br><span class="line">#### <span class="number">1.</span> **模块化设计**</span><br><span class="line">- 将多线程相关的代码封装为独立的模块，便于维护和扩展。</span><br><span class="line">- 使用接口或抽象类定义线程的行为，提高代码的可测试性和可替换性。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">2.</span> **避免竞态条件**</span><br><span class="line">- 竞态条件是多线程程序中最常见的问题之一。可以通过以下方式避免：</span><br><span class="line">  - 使用原子操作（Atomic Operations）处理共享变量。</span><br><span class="line">  - 将共享资源的访问限制在单一线程中。</span><br><span class="line">  - 使用不可变对象减少共享状态的复杂性。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">3.</span> **异常处理**</span><br><span class="line">- 在多线程环境中，异常处理尤为重要。确保每个线程都有完善的异常捕获机制，并能够优雅地退出或重试任务。</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 四、**调试与测试优化**</span><br><span class="line"> </span><br><span class="line">#### <span class="number">1.</span> **多线程调试工具**</span><br><span class="line">- 使用专业的调试工具（如Valgrind、Helgrind、Intel Inspector）检测死锁、竞态条件等问题。</span><br><span class="line">- 使用性能分析工具（如Intel VTune、Google Benchmark）定位多线程程序中的性能瓶颈。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">2.</span> **单元测试与集成测试**</span><br><span class="line">- 编写单元测试验证每个线程的功能是否正确。</span><br><span class="line">- 进行集成测试，确保多个线程协同工作时不会出现逻辑错误或性能下降。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">3.</span> **压力测试**</span><br><span class="line">- 在高负载场景下测试程序的稳定性，观察是否存在资源泄漏或性能退化问题。</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 五、**扩展性优化**</span><br><span class="line"> </span><br><span class="line">#### <span class="number">1.</span> **支持动态扩展**</span><br><span class="line">- 设计一个多线程框架时，应支持动态调整线程数量。例如，可以根据系统的负载自动增加或减少线程数。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">2.</span> **跨平台兼容性**</span><br><span class="line">- 如果程序需要运行在不同的操作系统上，可以使用跨平台的多线程库（如 pthread、boost.thread、Qt Concurrent）。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">3.</span> **分布式扩展**</span><br><span class="line">- 对于非常大的任务规模，可以考虑将多线程处理扩展到分布式系统中（如使用 MPI、Akka、gRPC）。</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 六、**实际案例中的优化实践**</span><br><span class="line"> </span><br><span class="line">#### <span class="number">1.</span> **数据导入与解析优化**</span><br><span class="line">- 在你的项目中，针对<span class="number">9</span>种类型、<span class="number">3</span>种格式的数据文件导入与解析，可以尝试以下优化：</span><br><span class="line">  - 使用内存映射文件（mmap）加速文件读取。</span><br><span class="line">  - 将数据解析逻辑拆分为独立的任务，利用线程池进行并行处理。</span><br><span class="line">  - 对解析后的数据进行缓存，避免重复计算。</span><br><span class="line"> </span><br><span class="line">#### <span class="number">2.</span> **绘图功能优化**</span><br><span class="line">- 在数据可视化部分，可以尝试以下优化：</span><br><span class="line">  - 使用GPU加速绘图（如OpenGL、Vulkan）。</span><br><span class="line">  - 对绘图数据进行压缩存储，减少内存占用。</span><br><span class="line">  - 实现懒加载机制，按需加载绘图数据。</span><br><span class="line"> </span><br><span class="line">---</span><br><span class="line"> </span><br><span class="line">### 总结 </span><br><span class="line"> </span><br><span class="line">多线程处理的优化是一个系统性的工程，需要从性能、资源管理、代码结构、调试测试等多个角度综合考虑。通过合理的任务划分、高效的锁机制、充分的资源管理和完善的测试手段，可以显著提升多线程程序的性能和稳定性。在实际开发中，还需要结合具体场景选择合适的优化策略，并通过持续的性能分析和调优来达到最佳效果。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>基于imx6ull的智能家居项目</h1><blockquote><p>本项目针对智能家居领域，利用IMX6ULL开发板为核心，构建了一套集温湿度监测、远程控制、报警于一体的智能家居解决方案。通过集成DHT11温湿度传感器，SR501红外模块，以及蜂鸣器等硬件组件，实现了环境温湿度的实时监测与展示，并且与应用端通过MQTT协议联动，使用户能够远程查看数据、控制开发板上的LED开关，同时具备高温报警功能，增强家居安全意识。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line">板子上：服务羰				Linux qt环境下：客户端</span><br><span class="line"></span><br><span class="line">传输数据： </span><br><span class="line">用的 TCPsocket, 创建了一个模块结构体，里面都是<span class="type">char</span>类型数据，用于存放获取的模块相应数据。里面有一个 name变量 是存放模块名(也是一个标签名)，用于判断，传输过来的数据是那个模块的，比如：dht11模块可以获得温度和湿度的数据，传输过来的数据，我们接受，判断结构体.name 是否等于dht11，等于，我们就取出温度和湿度,数据发送和接受都是用 QByteArray（额瑞）      vector（vai k t）容器</span><br><span class="line"></span><br><span class="line">客户端：</span><br><span class="line">有一个登陆界面，输出IP和端口，与服务器端连接，服务端（就是板子上），有两个按钮（一个打开服务器按钮，一个关闭服务器按钮），先要打开服务器按钮， 有tcpServer-&gt;listen 监听我们给定的IP和端口，客户羰，点击登陆，被客户端监听到，会触发 connected（康来kt） 信号,对应的信号槽函数，就隐藏登陆界面，跳转到主界面，主界面就是一些，获取到模块的数据后进行显示的界面，其中有两个按钮，一个是灯开关按钮，一个是温湿度表按钮，灯开关按钮，点击后，TCPsocket-&gt;write,发送开关的数据，比如：<span class="number">1</span>表示开，<span class="number">0</span>表示关。我们也会接收服务器端发过来的数据，TCPsocket-&gt;readall,接收后判断name标签名是否等于led,等于，我们就拿数据，同步，开关的状态。如果name=dht11，取的数据就是温湿度的，将数据存到sql文件，用的是mysql, 函数是: db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>), db.<span class="built_in">setHostName</span>(IP),db.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>); db.<span class="built_in">setPassword</span>(<span class="string">&quot;520520&quot;</span>); db.<span class="built_in">setPort</span>(<span class="number">3306</span>); db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;ordering_system&quot;</span>); mysql配置好了， 使用的话，<span class="function">QSqlQuery <span class="title">query</span><span class="params">(db)</span></span>; query.<span class="built_in">exec</span>(<span class="string">&quot;sql语句&quot;</span>)，读取sql表数据，select * from 表名，写入sql数据 insert into 表名 values...， 然后是一个温湿度表按钮，点击后，当前界面隐藏，切换到，一个温湿度表界面，读取sql表里的数据展示 setcolumncount（阔伦靠特） 设置列数   ，setRowCount（肉靠特 ）行，用query.<span class="built_in">next</span>()将sql表每一列数据读出，显示到表格中</span><br><span class="line"></span><br><span class="line">服务器端：</span><br><span class="line">创建一个用于运行定时器和函数的线程类，写一个构造函数初始化，重写虚函数run,通过run启动线程，timer.<span class="built_in">setInterval</span>(因特 w额)，按指定的周期调用函数，timr.start 启动定时器, exec 进入事件循环，保持线程运行，用它创建了三个定时器线程对象，dth11,sr501，irda，分别每隔<span class="number">5</span>秒<span class="number">1</span>秒<span class="number">2</span>秒执行一次，触发信号并执行三个对应的槽函数</span><br><span class="line">   sg90是变量，在 mainWindow 构造函数里，创建tcpServer和tcpSocket对象，用于tpc连接和数据传输，执行三个open1，<span class="number">2</span>，<span class="number">3</span>函数，用来判断各个模块的设备文件是否打开， open1 里，判断dth11和sg90 ,open2里 ，open2判断sr501和sr04,open3里红外控制和<span class="built_in">motor</span>(步进电机)，为什么分成三份，因为环境监测与调控的功能：sg90是dth11温湿度超过阈值，就自动开启转动，所以它俩我放一个open,智能安防功能：是sr501检测到人了才开启sr04超声波测距的。led灯是与开关按钮关联的</span><br><span class="line">    </span><br><span class="line">gpio驱动    </span><br><span class="line">led</span><br><span class="line">先定义一个 file_operations 结构体，接着编写init函数，在init函数中完成率对管脚的映射，gpio_request 申请引脚，gpio_direction_output 设置方向-输出 ，register_chrdev 字符设备注册， class_create 类的注册，device_create 在类下面创建一个设备 ，exit函数中完成率字符设备卸载，类的卸载，设备号，引脚号的释放，在open函数中完成硬件管脚的初始化，在write函数中完成点灯操作。</span><br><span class="line"></span><br><span class="line">sr04  超声波</span><br><span class="line">先定义一个 file_operations 结构体， 接着编写init函数，在init函数中完成率对管脚的映射，我们需要去看文档 sr04原理比较简单我记得，超声波测距模块工作原理:一个控制口发一个<span class="number">10U</span>S以上的高电平，就可以在接收口等待高电平输出。一有输出就可以开定时器计时，当此口变为低电平时就可以读定时器的值，此时就为此次测距的时间，方可算出距离。超声波测试距离公式=(高电平时间*声速(<span class="number">340</span>M/S))/<span class="number">2</span>。通过原理，在init的函数中， gpio_request 申请引脚 ，gpio_direction_output 先让引脚输出平常为低电平 ，gpio_to_irq 确定中断号， request_irq 申请中断 ，中断会执行中断函数，中断后，设置定时器 setup_timer，执行定时器函数，中断函数里， gpio_get_value 读取引脚值，判断引脚的电平，上升沿就记录起始时间 ktime_get_ns 获得内核精确的时间 ，错过上升沿就返回， del_timer 中断正常停止定时器，下降记录起始时间,并计算时间差, put_key  时间差存到环形缓冲区， register_chrdev 字符设备注册， class_create 类的注册，device_create 在类下面创建一个设备 ，exit 函数中完成字符设备卸载，类的卸载，设备号，引脚号的释放，在read函数中 get_key 从按键缓冲区中读取按键值（就是时间差），copy_to_user 内核空间的数据复制到用户空间 ，应用层，read函数 读取时间差值，用公式计算得到距离</span><br><span class="line"></span><br><span class="line">以一个LED驱动为例，先定义一个 file_operations 结构体，接着编写 init 函数，在init函数中完成对管脚的映射，register_chrdev 字符设备的注册，class_create 类的注册，class_device_create 在类下面注册一个设备。exit 函数中完成字符设备的卸载，类的卸载，内存空间的释放。在open函数中完成硬件管脚的初始化，在write函数中完成点灯操作。</span><br><span class="line"><span class="built_in">file_operations</span> (fai_欧扑锐醒)</span><br><span class="line">register_chrdev （ruai 急死特_磕带屋）</span><br><span class="line">class_create （亏A特）</span><br><span class="line">class_device_create（低畏死_亏A特）</span><br><span class="line"><span class="built_in">exit</span> (挨可谁特)</span><br><span class="line">    </span><br><span class="line"> 项目采用了C/S架构，利用TCP协议进行通信，通过 MySQL数据库来储存温湿度数据，创建一个用于运行定时器和函数的线程类，用它创建了三个定时器线程对象，dth11,sr501，irda，分别每隔<span class="number">5</span>秒<span class="number">1</span>秒<span class="number">2</span>秒执行一次，触发信号并执行三个对应的槽函数，三个对应的槽函数，对应着温湿度监测功能，红外监测功能等。与这三个定时器线程对象与之对应的有三个open1、<span class="number">2</span>、<span class="number">3</span>函数，他们是判断各个驱动模块是否加载成功。</span><br><span class="line">    还有各模块的驱动编写，主要用 gpio子系统和字符设备 完成驱动编写</span><br><span class="line">    还有关于qt移植，需要将qt移植到板子上运行，第一步：准备 qt 库文件和 tslib 库（触摸屏），第二步：交叉编译链，将 qt 和 tslib 设置为自己arm 板子编译工具链 第三步：配置arm板子qt 和 tslib 环境 第四步：qt软件配置，在ubantu 安装qt软件后，进行arm编译环境配置 。然后将qt程序编译后，将该文件复制到板子上，执行即可。   </span><br><span class="line">    rm板子挂载nfs文件系统就可以和ubantu 共享这个文件夹</span><br><span class="line">    </span><br><span class="line">    遇到的问题：qt移植后，发现在板子上qt文件在运行有问题，是因为ubantu的编译工具链和arm板子编译工具链不一样，我在ubantu qt软件配置的是ubantu的编译工具链，改成 arm板子编译工具链 再 执行编译qt即可</span><br><span class="line">    </span><br><span class="line">    ‌模拟技术面试问答‌</span><br><span class="line">‌<span class="string">&#x27;1. 你能简要介绍一下这个智能家居项目的整体架构吗？特别是你提到的C/S架构是如何实现的？</span></span><br><span class="line"><span class="string">回答示例：</span></span><br><span class="line"><span class="string">这个项目的整体架构是基于C/S（客户端/服务器）架构的。IMX6ULL开发板作为服务器端，负责采集传感器数据（如温湿度、红外感应等），并通过TCP/Socket或MQTT协议将数据发送到客户端（如手机应用或PC端）。客户端可以远程查看环境数据，并发送控制指令（如开关LED灯）到服务器端。服务器端接收到指令后，执行相应的操作（如控制LED灯的开关），并将执行结果反馈给客户端。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">‌二、功能实现细节‌</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌Q2‌：在灯光控制功能中，你是如何实现硬件按钮和Qt界面按钮的同步状态更新的？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌参考回答‌：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌硬件按钮状态更新‌：通过GPIO中断检测物理按钮的按下事件，在驱动中更新LED的状态，并将状态信息写入共享内存或通过网络发送至客户端。</span></span><br><span class="line"><span class="string">‌Qt界面按钮同步‌：Qt客户端定时轮询服务端的状态信息，或者接收服务端主动推送的状态更新信号。当收到状态更新时，界面上的按钮状态会相应地进行更新。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌Q3‌：在环境监测与调控功能中，你是如何从DHT11模块获取温湿度数据，并在数据到达阈值时开启风扇的？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌参考回答‌：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌数据获取‌：通过I2C或GPIO接口与DHT11模块进行通信，读取温湿度数据。</span></span><br><span class="line"><span class="string">‌阈值判断与风扇控制‌：在服务端程序中设置温湿度阈值，当读取到的数据超过阈值时，通过GPIO控制SG90舵机模拟风扇的开启和关闭。同时，为了避免频繁启停，可以设计迟滞阈值和时间窗口判断逻辑。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌Q4‌：在智能安防功能中，你是如何协同SR501和SR04模块实现安防检测的？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌参考回答‌：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌协同逻辑‌：当SR501人体红外传感器触发后，启动SR04超声波传感器进行距离测量。通过连续测量多次并剔除异常值后取均值，判断是否有入侵者。若距离持续缩小且低于阈值，则判定为入侵，触发声光报警并记录日志。</span></span><br><span class="line"><span class="string">‌误报处理‌：通过距离变化速率和环境干扰过滤等机制来减少误报。</span></span><br><span class="line"><span class="string">‌三、驱动开发与系统移植‌</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌Q5‌：在驱动代码编写方面，你主要编写了哪些驱动，并遇到了哪些挑战？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌参考回答‌：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌编写的驱动‌：主要包括LED、SR04、DHT11、SR501等硬件模块的驱动。</span></span><br><span class="line"><span class="string">‌遇到的挑战‌：在驱动开发过程中，主要遇到了硬件兼容性、中断处理、时序控制等方面的挑战。通过查阅硬件手册、调试工具和反复测试，最终成功编写了稳定可靠的驱动代码。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌Q6‌：在将Qt界面移植到imx6ull板子时，你遇到了哪些挑战，并如何解决的？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌参考回答‌：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌遇到的挑战‌：主要包括交叉编译环境配置、显示驱动适配、触摸屏校准等方面。</span></span><br><span class="line"><span class="string">‌解决方法‌：通过配置Buildroot定制文件系统来解决Qt库依赖冲突问题；启用Framebuffer并关闭桌面环境，直接使用linuxfb插件来适配显示驱动；使用tslib进行触摸屏校准，并通过硬件加速提升渲染效率。</span></span><br><span class="line"><span class="string">‌四、技术收获与后续应用‌</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌Q7‌：请谈谈你在这个项目中的最大技术收获，并说明如何将这些收获应用到后续的开发中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌参考回答‌：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">‌技术收获‌：掌握了Linux驱动开发的全流程（编写、加载、调试），深入理解了硬件与内核的交互机制；熟练使用了Qt信号槽机制和ARM平台的移植技巧。</span></span><br><span class="line"><span class="string">‌后续应用‌：在后续的开发中，可以将这些收获应用到工业物联网项目中，通过复现驱动开发经验来快速实现硬件控制功能；同时，利用Qt快速构建嵌入式GUI界面，提高开发效率。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">好的，我们现在开始模拟面试。我会根据你提供的项目经历，特别是基于IMX6ULL的智能家居项目，提出一些问题。请你尽量详细地回答，展示你的技术能力和项目经验。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 1. **你能简要介绍一下这个智能家居项目的整体架构吗？特别是你提到的C/S架构是如何实现的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">这个项目的整体架构是基于C/S（客户端/服务器）架构的。IMX6ULL开发板作为服务器端，负责采集传感器数据（如温湿度、红外感应等），并通过TCP/Socket或MQTT协议将数据发送到客户端（如手机应用或PC端）。客户端可以远程查看环境数据，并发送控制指令（如开关LED灯）到服务器端。服务器端接收到指令后，执行相应的操作（如控制LED灯的开关），并将执行结果反馈给客户端。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 2. **你提到使用了DHT11传感器来采集温湿度数据，能否介绍一下DHT11的工作原理？你是如何将传感器数据读取并传输到客户端的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">DHT11是一种数字温湿度传感器，它通过单总线协议与主控芯片通信。传感器内部集成了湿度和温度检测元件，并将模拟信号转换为数字信号输出。主控芯片通过发送特定的时序信号来触发DHT11的数据采集，DHT11随后会返回40位的数据包，其中包含湿度和温度的测量值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在项目中，我通过IMX6ULL的GPIO引脚与DHT11进行通信。首先，我编写了驱动代码来初始化GPIO引脚，并通过定时器来精确控制时序信号。当DHT11返回数据后，我解析数据包，提取出温湿度值，并通过TCP/Socket或MQTT协议将这些数据发送到客户端。客户端接收到数据后，可以在界面上实时显示温湿度信息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3. **你提到使用了SR501红外模块来实现智能安防功能，能否详细介绍一下这个模块的工作原理以及你在项目中是如何使用它的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">SR501是一种基于红外感应的运动检测模块。它通过检测人体发出的红外辐射来感知是否有人进入监测区域。当检测到人体移动时，SR501会输出高电平信号，否则输出低电平信号。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在项目中，我将SR501的输出引脚连接到IMX6ULL的GPIO输入引脚，并通过编写驱动代码来实时监测SR501的输出状态。当检测到有人进入监测区域时，IMX6ULL会通过TCP/Socket或MQTT协议向客户端发送报警信息，同时触发蜂鸣器发出警报声。这样可以有效增强家居的安全性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 4. **你在项目中使用了Qt来制作交互界面，能否介绍一下你是如何将Qt与IMX6ULL开发板进行集成的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我使用Qt框架来开发客户端的交互界面。Qt提供了丰富的UI组件和跨平台支持，使得开发过程更加高效。为了将Qt与IMX6ULL开发板集成，我首先在开发板上搭建了Linux操作系统，并安装了Qt的开发环境。然后，我通过交叉编译工具链将Qt应用程序编译为适用于ARM架构的可执行文件，并将其部署到IMX6ULL开发板上。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在开发过程中，我使用了Qt的信号与槽机制来实现界面与后端逻辑的交互。例如，当用户点击界面上的按钮时，界面会发送信号，后端逻辑通过槽函数接收信号并执行相应的操作（如控制LED灯的开关）。同时，Qt的网络模块也帮助我实现了与TCP/Socket或MQTT协议的集成，使得客户端能够实时接收和发送数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 5. **你在项目中使用了TCP/Socket通信，能否详细介绍一下你是如何实现客户端与服务器端之间的通信的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我使用了TCP/Socket通信来实现客户端与服务器端之间的数据传输。具体来说，IMX6ULL开发板作为服务器端，监听特定的端口，等待客户端的连接请求。客户端通过Socket连接到服务器端后，双方可以通过TCP协议进行双向通信。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了实现这一功能，我首先在IMX6ULL上编写了服务器端的Socket程序，使用`bind()`、`listen()`和`accept()`等系统调用来处理客户端的连接请求。一旦连接建立，服务器端就可以通过`send()`和`recv()`函数与客户端进行数据交换。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在客户端，我使用Qt的网络模块来实现Socket通信。通过Qt的`QTcpSocket`类，客户端可以方便地连接到服务器端，并发送和接收数据。例如，当用户点击界面上的按钮时，客户端会通过Socket发送控制指令到服务器端，服务器端接收到指令后执行相应的操作，并将执行结果返回给客户端。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 6. **你在项目中使用了定时器，能否介绍一下定时器在项目中的具体应用场景？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，定时器主要用于以下几个方面：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **传感器数据采集**：为了定期采集DHT11传感器的温湿度数据，我使用了定时器来定时触发数据采集任务。例如，每隔5秒钟，定时器会触发一次数据采集，确保客户端能够实时获取最新的环境数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **任务调度**：在智能安防模块中，定时器用于定期检查SR501红外模块的输出状态。例如，每隔1秒钟，定时器会触发一次状态检查，确保能够及时检测到有人进入监测区域。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **网络通信**：在TCP/Socket通信中，定时器用于检测连接状态。例如，如果客户端长时间没有发送数据，定时器会触发超时处理，关闭连接并释放资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过合理使用定时器，我能够确保系统的各个模块能够高效、稳定地运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 7. **你在项目中提到了环境监测与调控功能，能否详细介绍一下这个功能的实现过程？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">环境监测与调控功能是通过DHT11传感器采集的温湿度数据来实现的。当温度或湿度超过预设的阈值时，系统会触发相应的调控操作。具体实现过程如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **数据采集**：通过DHT11传感器定期采集环境温湿度数据，并将数据存储在IMX6ULL的内存中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **阈值判断**：在服务器端，我设置了温度和湿度的阈值（例如温度30°C，湿度70%）。每次采集到新的温湿度数据后，系统会将其与阈值进行比较。如果温度或湿度超过阈值，系统会触发调控操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **调控操作**：当温度超过阈值时，系统会通过控制SG90舵机来开启风扇，降低环境温度。当湿度超过阈值时，系统会触发报警，提醒用户当前湿度过高。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过这一功能，用户可以及时了解环境温湿度的变化，并采取相应的措施，确保家居环境的舒适性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 8. **你在项目中使用了MySQL数据库，能否介绍一下你是如何使用数据库的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我使用MySQL数据库来存储系统的配置数据和历史记录。具体来说，我主要做了以下几方面的工作：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **数据库设计**：首先，我设计了数据库的表结构。例如，我创建了一个`environment_data`表来存储温湿度数据，表结构包括`id`、`timestamp`、`temperature`和`humidity`等字段。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **数据库连接**：在Qt应用程序中，我使用了Qt的数据库模块（如QSqlDatabase）来连接MySQL数据库。通过配置数据库的连接参数（如主机名、用户名、密码等），我能够成功连接到MySQL数据库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **数据操作**：在Qt应用程序中，我使用了QSqlQuery类来执行SQL语句。例如，当DHT11传感器采集到新的温湿度数据时，我使用`INSERT`语句将数据插入到`environment_data`表中。当客户端需要查询历史数据时，我使用`SELECT`语句从数据库中读取数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **错误处理**：在数据库操作中，我实现了错误处理机制。例如，当数据库连接失败时，系统会记录错误日志，并尝试重新连接。通过错误处理，我能够确保系统在异常情况下能够正常运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过以上措施，我能够有效地使用MySQL数据库来存储和管理系统的数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 9. **你在项目中使用了SR04超声波模块，能否介绍一下这个模块的工作原理以及你在项目中是如何使用它的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">SR04是一种超声波测距模块，它通过发射超声波并接收反射波来测量物体与模块之间的距离。模块的工作原理是通过计算超声波从发射到接收的时间差，结合声速来计算距离。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在项目中，我将SR04模块用于智能安防功能。具体来说，SR04模块用于检测是否有人靠近。当检测到有人靠近时，SR04会输出距离数据，我通过IMX6ULL的GPIO引脚读取这些数据，并通过TCP/Socket或MQTT协议将数据发送到客户端。客户端接收到数据后，可以在界面上显示距离信息，并触发报警功能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 10. **你在项目中使用了Qt的信号与槽机制，能否详细介绍一下你是如何使用这一机制来实现模块间的通信的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">Qt的信号与槽机制是一种强大的事件处理机制，允许对象之间进行松耦合的通信。在项目中，我使用信号与槽机制来实现界面与后端逻辑之间的交互。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">例如，在智能家居项目中，当用户点击界面上的按钮时，按钮会发出一个`clicked()`信号。我通过`connect()`函数将这个信号连接到一个槽函数，槽函数中包含了控制LED灯开关的逻辑。当按钮被点击时，槽函数会被自动调用，执行相应的操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此外，我还使用信号与槽机制来处理网络通信。例如，当客户端接收到服务器端发送的数据时，`QTcpSocket`会发出一个`readyRead()`信号。我通过将这个信号连接到一个槽函数，实现了数据的实时处理和显示。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过合理使用信号与槽机制，我能够确保系统的各个模块之间能够高效、灵活地进行通信。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 11. **你在项目中使用了IMX6ULL开发板，能否介绍一下你是如何进行硬件驱动测试的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我使用了多种方法来进行硬件驱动测试，主要包括：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **单元测试**：在编写驱动代码时，我首先对每个模块进行单元测试。例如，对于LED驱动，我编写了测试代码来验证GPIO引脚的初始化和控制功能。通过单元测试，我能够确保每个模块的功能正常。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **集成测试**：在完成各个模块的驱动代码后，我进行了集成测试。例如，我将DHT11传感器、SR501红外模块和蜂鸣器连接到IMX6ULL开发板上，并编写测试代码来验证它们之间的协同工作。通过集成测试，我能够确保系统的各个模块能够正常交互。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **硬件调试工具**：在测试过程中，我使用了万用表和示波器等硬件调试工具来监测信号的电平和波形。例如，我使用示波器来监测DHT11传感器的时序信号，确保其符合数据手册中的要求。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过以上测试方法，我能够确保硬件驱动的正确性和稳定性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 12. **你在项目中使用了Linux系统编程，能否介绍一下你在项目中编写了哪些驱动代码？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我编写了多个硬件模块的驱动代码，主要包括：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **LED驱动**：通过GPIO子系统控制开发板上的LED灯。我编写了驱动代码来初始化GPIO引脚，并通过读写寄存器来控制LED的开关。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **DHT11驱动**：通过单总线协议与DHT11传感器通信。我编写了驱动代码来初始化GPIO引脚，并通过定时器来精确控制时序信号，确保能够正确读取温湿度数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **SR501驱动**：通过GPIO输入引脚读取SR501红外模块的输出状态。我编写了驱动代码来实时监测SR501的输出信号，并在检测到人体移动时触发报警。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **SR04驱动**：通过GPIO引脚控制SR04超声波模块的测距功能。我编写了驱动代码来初始化GPIO引脚，并通过定时器来精确控制超声波的发射和接收。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过编写这些驱动代码，我能够有效地控制硬件模块，并实现智能家居系统的各项功能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 13. **你在项目中使用了Linux命令，能否介绍一下你在项目中常用的Linux命令有哪些？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我经常使用以下Linux命令：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **文件操作**：`ls`（列出目录内容）、`cd`（切换目录）、`cp`（复制文件）、`mv`（移动文件）、`rm`（删除文件）等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **进程管理**：`ps`（查看进程状态）、`kill`（终止进程）、`top`（实时查看系统资源使用情况）等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **网络配置**：`ifconfig`（配置网络接口）、`ping`（测试网络连接）、`netstat`（查看网络状态）等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **系统调试**：`dmesg`（查看内核日志）、`strace`（跟踪系统调用）、`gdb`（调试程序）等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5. **软件安装**：`apt-get`（安装软件包）、`dpkg`（管理Debian软件包）等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过熟练使用这些Linux命令，我能够高效地进行系统配置、调试和管理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 14. **你在项目中使用了TCP/多线程等技术，能否介绍一下你是如何确保系统的稳定性和性能的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我通过以下几种方式来确保系统的稳定性和性能：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **多线程编程**：为了提高系统的并发处理能力，我使用了多线程技术。例如，在数据采集模块中，我创建了单独的线程来处理DHT11传感器的数据采集，避免阻塞主线程的执行。通过合理使用多线程，我能够确保系统的各个模块能够并行运行，提高系统的响应速度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **线程同步**：在多线程编程中，我使用了互斥锁（mutex）和条件变量（condition variable）来实现线程间的同步。例如，在数据共享时，我使用互斥锁来保护共享资源，避免数据竞争。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **错误处理**：在TCP/Socket通信中，我实现了完善的错误处理机制。例如，当网络连接中断时，系统会自动重连，并记录错误日志。通过错误处理，我能够确保系统在异常情况下能够正常运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **性能优化**：在系统设计时，我考虑了性能优化。例如，在数据采集模块中，我使用了定时器来定期采集数据，避免频繁的传感器访问。通过性能优化，我能够确保系统在高负载情况下仍能保持稳定运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过以上措施，我能够确保系统的稳定性和性能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 15. **你在项目中使用了Qt的UI设计，能否介绍一下你是如何设计用户界面的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我使用Qt Designer来设计用户界面。Qt Designer是一个可视化的UI设计工具，允许我通过拖拽组件的方式来快速构建界面。在设计过程中，我主要考虑了以下几个方面：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **界面布局**：我使用了Qt的布局管理器（如QVBoxLayout、QHBoxLayout等）来管理界面组件的布局。通过合理使用布局管理器，我能够确保界面在不同分辨率下都能正常显示。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **组件选择**：根据项目需求，我选择了合适的Qt组件来构建界面。例如，我使用了QPushButton来实现按钮功能，使用了QLabel来显示文本信息，使用了QLineEdit来接收用户输入等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **信号与槽机制**：在界面设计中，我使用了Qt的信号与槽机制来实现界面与后端逻辑的交互。例如，当用户点击按钮时，按钮会发出`clicked()`信号，我通过`connect()`函数将这个信号连接到一个槽函数，槽函数中包含了控制LED灯开关的逻辑。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **界面美化**：为了提高用户体验，我对界面进行了美化。例如，我使用了Qt的样式表（QSS）来设置组件的颜色、字体和边框等属性，使界面更加美观。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过以上设计，我能够构建出一个功能完善、易于使用的用户界面。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 16. **你在项目中使用了MySQL数据库，能否介绍一下你是如何使用数据库的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我使用MySQL数据库来存储系统的配置数据和历史记录。具体来说，我主要做了以下几方面的工作：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **数据库设计**：首先，我设计了数据库的表结构。例如，我创建了一个`environment_data`表来存储温湿度数据，表结构包括`id`、`timestamp`、`temperature`和`humidity`等字段。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **数据库连接**：在Qt应用程序中，我使用了Qt的数据库模块（如QSqlDatabase）来连接MySQL数据库。通过配置数据库的连接参数（如主机名、用户名、密码等），我能够成功连接到MySQL数据库。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **数据操作**：在Qt应用程序中，我使用了QSqlQuery类来执行SQL语句。例如，当DHT11传感器采集到新的温湿度数据时，我使用`INSERT`语句将数据插入到`environment_data`表中。当客户端需要查询历史数据时，我使用`SELECT`语句从数据库中读取数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **错误处理**：在数据库操作中，我实现了错误处理机制。例如，当数据库连接失败时，系统会记录错误日志，并尝试重新连接。通过错误处理，我能够确保系统在异常情况下能够正常运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过以上措施，我能够有效地使用MySQL数据库来存储和管理系统的数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 17. **你在项目中使用了Linux系统编程，能否介绍一下你是如何进行进程间通信的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">在项目中，我使用了多种进程间通信（IPC）机制来实现不同进程之间的数据交换，主要包括：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **管道（Pipe）**：管道是一种半双工的通信机制，适用于父子进程之间的通信。在项目中，我使用管道来实现进程间的简单数据传递。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **消息队列（Message Queue）**：消息队列是一种全双工的通信机制，适用于多个进程之间的通信。在项目中，我使用消息队列来实现进程间的异步通信。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **共享内存（Shared Memory）**：共享内存是一种高效的通信机制，适用于需要频繁交换大量数据的进程。在项目中，我使用共享内存来实现进程间的快速数据交换。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **信号（Signal）**：信号是一种异步通信机制，适用于进程间的简单通知。在项目中，我使用信号来实现进程间的简单通信，例如通知某个进程执行特定的操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过以上IPC机制，我能够确保系统的各个进程之间能够高效、稳定地进行通信。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 18. **你在项目中使用了Qt移植到ARM的过程，能否详细介绍一下你是如何完成这一过程的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答示例：**</span></span><br><span class="line"><span class="string">将Qt移植到ARM架构的IMX6ULL开发板的过程主要包括以下几个步骤：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. **搭建交叉编译环境**：首先，我在PC上安装了交叉编译工具链（如arm-linux-gnueabihf），用于将Qt应用程序编译为适用于ARM架构的可执行文件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. **配置Qt源码**：接下来，我下载了Qt的源码，并使用`configure`脚本进行配置。在配置过程中，我指定了交叉编译工具链和目标平台（ARM），并启用了必要的模块（如Qt Core、Qt GUI、Qt Network等）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. **编译Qt库**：配置完成后，我使用`make`命令编译Qt库。编译过程可能需要较长时间，具体取决于PC的性能和Qt的版本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. **部署到开发板**：编译完成后，我将生成的Qt库和应用程序部署到IMX6ULL开发板上。为了确保应用程序能够正常运行，</span></span><br></pre></td></tr></table></figure><h1>基于Linux、QT、C++的点餐系统</h1><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/G1842965496/article/details/119736304">基于Linux、QT、C++的点餐系统_基于qt的点餐系统-CSDN博客</a> 对图内容更好理解</p><p>碰到项目中的问题就说内存泄露<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87e72d0e0a243d4016c9d.jpg" alt=""></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、项目采用 C/S 架构，利用 TCP 协议进行通信，采用了多线程的方法解决服务端与多个客服端的通信。</span><br><span class="line"><span class="number">2</span>、通过 vector 容器来存放顾客的订单信息，顾客提交订单时，将容器发送给管理端和厨房。</span><br><span class="line"><span class="number">3</span>、通过 MySQL数据库来储存用户信息、菜单信息、账单信息，及厨房待做餐品清单。</span><br><span class="line"><span class="number">4</span>、采用中介者模式和状态模式，实现不同客服端间的信息交互。</span><br><span class="line"><span class="number">5</span>、顾客提交订单后可随时进行加餐，对未上餐品可进行催餐和退餐。</span><br><span class="line"><span class="number">6</span>、收银员可查询相应桌号的消费详情和消费总额并进行结账。</span><br><span class="line"><span class="number">7</span>、管理员可进行对用户信息和菜单信息的修改、添加和删除，并可查看账单及账单详情。</span><br><span class="line">    </span><br><span class="line">    顾客端（客户端）：提供用户点餐界面，餐品信息，未上餐品信息，已上餐品信息</span><br><span class="line">    厨房端（客户端）：在顾客端用户提交的点餐的订单，就是待做的餐品信息</span><br><span class="line">    收银端（客户端）：登录后，餐桌使用情况（某号餐桌是否有人使用中），使用的某餐桌的用餐的费用情况，可选择是否要结账</span><br><span class="line">    管理端（服务端）：登录后，管理用户账号，查看账单情况，菜单管理情况，饮品管理情况</span><br><span class="line">    </span><br><span class="line">mysql</span><br><span class="line">MySQL数据库用于储存用户信息、菜单信息、账单信息等。</span><br><span class="line">QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>); 添加数据库 ，setHostName ip名，setUserName用户名，setPassword 密码，setPort 端口 setDatabaseName 数据库名，就连接到数据库了 使用的话，还需要  QSqlQuery query; 比如：query.<span class="built_in">exec</span>(<span class="string">&quot;sql语句&quot;</span>)，要选择数据的话，sql语句 select ... from 表名，如果是要写入数据的话，sql语句 insert into ... 表名。 query.<span class="built_in">next</span>() 读取下一行信息，query.<span class="built_in">value</span>(“字段名”) 就相当于键值对的获取方法</span><br><span class="line">    </span><br><span class="line"> 多线程</span><br><span class="line">  根据新的客户端连接的个数，来创建</span><br><span class="line">  <span class="keyword">new</span> QTcpServer 新建监听的套接字 , listen 监听 ，connect 信号与槽函数，信号是 newConnection 有新的连接，我们就新建新的套接字：客服端套接字，nextPendingConnection 拿到新的套接字，将新套接字当作参数创建线程 <span class="keyword">new</span> mythread, thread-&gt;<span class="built_in">start</span>() 开启进程， 进程文件 mythread , run函数，信号与槽函数， read信号，读数据，QByteArray 接收 <span class="built_in">readall</span>() 所以的数组，再将 QByteArray 接收 的变量，作为参数传给一个函数，该函数是客户端信息标志位判断，该函数中，先用，定义的容器结构体去接收数据，strcmp 字符串比较函数，拿容器数据里的标志位对比，等于<span class="number">0</span>，我们就执行对应的函数，如果标志位是厨房端或收银端，还需要将新的套接字tcpsocket给厨房端或收银端。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">数据</span><br><span class="line">结构体，一个餐桌结构体 FoodInfo ， 一个菜单结构体MenuInfo , vector 容器来存储数据，MenuVec 菜单容器和 <span class="number">2</span>个Foodvec订单容器，其中一个是数组类型 ，还有定义的两个对应的 菜单结构体 和 订单结构体，是一个头部，用tcp read和write读写时会用到， 存储数据的时候方法是一样的，比如是菜单相关的数据，用 QByteArray 接收数据，可以先将数据转成字符流 toLocal8Bit 再接收，再用 memcpy 将 QByteArray 变量.<span class="built_in">tata</span>(),它的数据复制给 定义的 <span class="type">char</span> 字符变量，再用strcpy，将 存放在字符变量中的数据，再次复制给 菜单结构，再用 push_back 将菜单结构添加到 MenuVec 菜单容器，这样，我们在用TCP写数据传递时，直接把 相应的容器 传过去</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">界面数据显示</span><br><span class="line">tablewidget 操作</span><br><span class="line">QStringList  表标题，  setColumnCount 列表设置为和表标题列相等  ， setRowCount 列表行为<span class="number">0</span> 由多少条数据决定 HorizontalHeaderLabels 插入表头 ，<span class="keyword">while</span>( query.<span class="built_in">next</span>()) 读取下一行信息, <span class="keyword">new</span> QTableWidgetItem（<span class="string">&quot;&quot;</span>） 参数为id,获取就都是id列数列，就可以指定某列的数据，限制内容，再用 ui-&gt;tableWidget-&gt;setItem ，指定某行某行数据，就可以完成数据内容以表的形式显示</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">### 面试官提问与求职者解答</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; 1. **请简要介绍一下你在“基于Linux、QT、C++的点餐系统”项目中的角色和职责。**</span></span><br><span class="line"><span class="string">   - **求职者回答**：  </span></span><br><span class="line"><span class="string">     在这个项目中，我主要负责了系统的整体架构设计和部分功能模块的开发。具体来说，我负责了管理端、订单端、收银端和厨房端的功能实现。管理端包括用户管理、菜单管理、账单管理等功能；订单端负责点餐、加餐、退餐等操作；收银端负责餐桌状态管理和结账功能；厨房端则负责待做餐品的管理和上菜操作。此外，我还参与了数据库的设计和TCP通信模块的开发。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span> <span class="number">2.</span> **你提到项目采用了C/S架构，能否详细说明一下客户端和服务端之间的通信机制？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     项目采用了C/S架构，客户端和服务端之间通过TCP协议进行通信。服务端使用多线程来处理多个客户端的请求，确保并发访问时的稳定性和响应速度。客户端通过TCP套接字与服务端建立连接，发送请求并接收服务端的响应。我们使用了Qt的信号与槽机制来处理异步通信，确保界面操作的流畅性。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; 3. **你在项目中使用了多线程，能否详细说明一下多线程的应用场景以及你是如何解决多线程并发问题的？**</span></span><br><span class="line"><span class="string">   - **求职者回答**：  </span></span><br><span class="line"><span class="string">     在项目中，多线程主要用于处理服务端与多个客户端的并发通信。每个客户端连接都会创建一个独立的线程来处理其请求，这样可以避免阻塞主线程，确保系统的响应速度。为了处理多线程并发问题，我们使用了Qt的`QMutex`和`QWaitCondition`来进行线程同步，确保共享资源（如订单信息、菜单信息等）的线程安全。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span> <span class="number">4.</span> **你提到使用了中介者模式和状态模式，能否详细说明一下这两种设计模式在项目中的应用？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     中介者模式主要用于不同客户端之间的信息交互。我们设计了一个中介者类，负责协调管理端、订单端、收银端和厨房端之间的通信。通过中介者模式，各个客户端不需要直接相互通信，而是通过中介者来传递消息，降低了模块之间的耦合度。  </span><br><span class="line">     状态模式则用于处理订单的状态转换。例如，订单从“待处理”到“已处理”再到“已完成”的状态转换。我们为每个状态设计了一个状态类，订单对象根据当前状态调用不同的行为，从而简化了状态管理的复杂性。</span><br><span class="line"></span><br><span class="line">#### <span class="number">5.</span> **你在项目中使用了MySQL数据库，能否详细说明一下数据库的设计以及你是如何优化数据库操作的？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     数据库设计方面，我们主要设计了用户表、菜单表、订单表和账单表。用户表存储用户信息，菜单表存储菜品信息，订单表存储顾客的点餐信息，账单表存储每笔交易的详细信息。  </span><br><span class="line">     为了优化数据库操作，我们使用了索引来加速查询操作，特别是在账单查询和菜单查询时。此外，我们还使用了事务处理来确保数据的完整性，特别是在订单提交和账单结算时，确保多个操作要么全部成功，要么全部失败。</span><br><span class="line"></span><br><span class="line">#### <span class="number">6.</span> **你在项目中使用了STL容器，能否详细说明一下你是如何使用`vector`容器来管理订单信息的？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     在项目中，我们使用`vector`容器来存储顾客的订单信息。每当顾客提交订单时，订单信息会被添加到`vector`容器中。然后，我们将这个容器发送给管理端和厨房端，以便他们能够实时更新订单状态。`vector`容器的动态数组特性使得我们可以方便地进行订单的添加、删除和修改操作。此外，我们还使用了迭代器来遍历`vector`容器，确保订单信息的准确传递。</span><br><span class="line"></span><br><span class="line">#### <span class="number">7.</span> **你在项目中如何处理顾客的加餐、退餐和催餐操作？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     对于加餐操作，顾客可以在订单提交后继续添加菜品，系统会实时更新订单信息并通知厨房端。对于退餐操作，顾客可以选择未上菜的菜品进行退餐，系统会更新订单状态并通知厨房端取消相应的菜品。催餐操作则是通过向厨房端发送催餐请求，厨房端会根据当前订单状态优先处理该订单。这些操作都通过TCP通信实时同步到各个客户端，确保数据的一致性。</span><br><span class="line"></span><br><span class="line">#### <span class="number">8.</span> **你在项目中如何处理收银端的结账功能？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     收银端的结账功能主要包括查询餐桌的消费详情和消费总额。当顾客准备结账时，收银员可以选择相应的餐桌号，系统会从数据库中查询该餐桌的所有订单信息，并计算出总消费金额。收银员确认后，系统会更新账单表，并将餐桌状态设置为“空闲”，以便下一批顾客使用。结账过程中，我们使用了事务处理来确保账单数据的准确性和一致性。</span><br><span class="line"></span><br><span class="line">#### <span class="number">9.</span> **你在项目中如何处理管理端的用户管理和菜单管理功能？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     管理端的用户管理功能包括用户的添加、修改、删除和查询。管理员可以通过界面操作对用户信息进行管理，所有的操作都会实时更新到数据库中。菜单管理功能类似，管理员可以添加、修改、删除菜品信息，并实时更新到菜单表中。我们还为管理员提供了账单查询功能，管理员可以查看所有账单的详细信息，包括每笔交易的消费明细。</span><br><span class="line"></span><br><span class="line">#### <span class="number">10.</span> **你在项目中遇到的最大挑战是什么？你是如何解决的？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     项目中最大的挑战是处理多个客户端之间的实时通信和数据同步。由于系统涉及多个客户端（管理端、订单端、收银端、厨房端），如何确保各个客户端之间的数据一致性是一个难题。我们通过使用中介者模式和TCP通信机制来解决这个问题。中介者模式负责协调各个客户端之间的通信，而TCP通信确保了数据的实时同步。此外，我们还使用了数据库事务处理来确保数据的完整性，最终成功解决了这个问题。</span><br><span class="line"></span><br><span class="line">#### <span class="number">11.</span> **你在项目中有没有进行性能优化？如果有，你是如何进行的？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     是的，我们在项目中进行了一些性能优化。首先，我们对数据库查询进行了优化，使用了索引来加速查询操作，特别是在账单查询和菜单查询时。其次，我们对TCP通信进行了优化，使用了多线程来处理多个客户端的并发请求，确保系统的响应速度。此外，我们还对界面进行了优化，使用了Qt的信号与槽机制来处理异步操作，确保界面操作的流畅性。</span><br><span class="line"></span><br><span class="line">#### <span class="number">12.</span> **你在项目中使用了哪些Qt的特性？能否详细说明一下？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     在项目中，我们主要使用了Qt的信号与槽机制、多线程支持和界面设计工具。信号与槽机制用于处理界面事件和异步通信，确保界面操作的流畅性。多线程支持用于处理服务端与多个客户端的并发通信，确保系统的响应速度。界面设计工具则用于设计各个客户端的用户界面，确保界面的美观和易用性。此外，我们还使用了Qt的数据库模块来连接和操作MySQL数据库。</span><br><span class="line"></span><br><span class="line">#### <span class="number">13.</span> **你在项目中有没有进行过错误处理？如果有，你是如何处理的？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     是的，我们在项目中进行了错误处理。首先，我们对数据库操作进行了错误处理，使用了事务处理来确保数据的完整性。如果某个操作失败，系统会回滚事务，确保数据的一致性。其次，我们对TCP通信进行了错误处理，使用了Qt的错误处理机制来捕获和处理通信过程中的异常情况。此外，我们还对用户输入进行了验证，确保用户输入的数据符合预期格式，避免因错误输入导致的系统异常。</span><br><span class="line"></span><br><span class="line">#### <span class="number">14.</span> **你在项目中有没有进行过测试？如果有，你是如何进行测试的？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     是的，我们在项目中进行了一系列的测试。首先，我们进行了单元测试，对每个功能模块进行了单独的测试，确保每个模块的功能正常。其次，我们进行了集成测试，测试各个模块之间的交互是否正常。最后，我们进行了系统测试，模拟实际使用场景，测试整个系统的稳定性和性能。我们还使用了Qt的测试框架来进行自动化测试，确保测试的全面性和准确性。</span><br><span class="line"></span><br><span class="line">#### <span class="number">15.</span> **你在项目中学到了哪些新的技术或技能？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     在这个项目中，我学到了很多新的技术和技能。首先，我深入理解了C/S架构的设计和实现，特别是TCP通信和多线程编程。其次，我学会了如何使用Qt进行界面设计和事件处理。此外，我还学会了如何使用MySQL数据库进行数据存储和管理，以及如何进行数据库优化和事务处理。最后，我还学会了如何使用设计模式（如中介者模式和状态模式）来解决复杂的系统设计问题。</span><br><span class="line"></span><br><span class="line">#### <span class="number">16.</span> **如果你有机会重新做这个项目，你会做出哪些改进？**</span><br><span class="line">   - **求职者回答**：  </span><br><span class="line">     如果我有机会重新做这个项目，我会考虑以下几点改进：  </span><br><span class="line">     <span class="number">1.</span> **引入更高级的负载均衡机制**：目前的系统在处理大量并发请求时可能会遇到性能瓶颈，未来可以考虑引入负载均衡机制来分担服务端的压力。  </span><br><span class="line">     <span class="number">2.</span> **增加更多的错误处理和日志记录**：虽然我们已经进行了一些错误处理，但未来可以增加更多的错误处理机制和日志记录，以便更好地排查和解决问题。  </span><br><span class="line">     <span class="number">3.</span> **优化数据库设计**：虽然我们已经对数据库进行了优化，但未来可以考虑引入更多的数据库优化技术，如分表、分区等，以进一步提高数据库的性能。  </span><br><span class="line">     <span class="number">4.</span> **引入更多的自动化测试**：虽然我们已经进行了一些自动化测试，但未来可以引入更多的自动化测试工具和框架，确保系统的稳定性和可靠性。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 总结：</span><br><span class="line">通过这些问题和回答，面试官可以全面了解求职者在“基于Linux、QT、C++的点餐系统”项目中的技术能力、问题解决能力以及项目经验。求职者在回答中展示了扎实的编程基础、良好的系统设计能力以及对多线程、数据库、设计模式等技术的深入理解。</span><br></pre></td></tr></table></figure><h1>动量轮平衡自行车</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87d7dd0e0a243d4016c82.png" alt=""></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87d7ed0e0a243d4016c83.png" alt=""></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87d7ed0e0a243d4016c84.png" alt=""></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/67b87dd0d0e0a243d4016c89.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">采用stm32f103c8t6作为主控芯片，通过MPU6050获取姿态参数，通过PID参数调节，直立环输出pwm控制电机驱动驱动电机，电机带动动量轮，实现自主平衡，有OLED显示屏作为显示模块,N20直流减速电机 ,TB6612FNG电机驱动模块、舵机、HC<span class="number">-06</span>蓝牙模块、HC-RS04超声波模块、</span><br><span class="line"></span><br><span class="line">PID：</span><br><span class="line">假设我们要对无人机进行PID参数调试</span><br><span class="line">KP的越大，螺旋桨转的越快，向上的力就越大，误差也越大，响应速度也越快，产生的震荡幅度也越大.</span><br><span class="line">KD, 会抵消部分KP的升力（也就是向上的力），让其震荡幅度变小</span><br><span class="line">KI, 无人机的误差存在，无人机的升力也一定存在，当无人机接近目标的高度时，最终会和重力平衡，此时无人机将不会再上升，为了解决这个问题，我们需要累积这个误差值，如果长时间无人机得不到修正，我们需要给无人机提供更大的升力，让无人机上升与目标高度一致</span><br></pre></td></tr></table></figure><h1>整体面试流程</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; 面试问题 1: </span></span><br><span class="line"><span class="string">**你在广州飞进信息科技有限公司的实习经历中，提到了使用多线程并发处理数据。你能详细解释一下你是如何实现多线程并发的吗？特别是在处理3种类型、3种格式数据文件时，如何确保线程安全和数据一致性？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答:**</span></span><br><span class="line"><span class="string">在项目中，我使用了Qt的QThread类来实现多线程并发。具体来说，我为每种类型的数据文件创建了一个独立的线程来处理数据的导入和解析。为了确保线程安全，我使用了Qt的信号与槽机制来进行线程间的通信，避免了直接共享数据。此外，我还使用了QMutex来保护共享资源，确保在同一时间只有一个线程可以访问和修改这些资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">对于数据一致性，我在每个线程中使用了局部变量来处理数据，只有在数据完全处理完毕后才通过信号与槽机制将结果传递到主线程。这样可以避免在数据处理过程中出现数据不一致的情况。同时，我还使用了QWaitCondition来协调线程的执行顺序，确保数据处理的顺序性和一致性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span> 面试问题 <span class="number">2</span>:</span><br><span class="line">**你在基于Linux的Qt点餐系统项目中提到了使用TCP/多线程/Socket通信。你能详细说明一下你是如何设计这个系统的通信机制的吗？特别是在多客户端的情况下，如何确保通信的稳定性和效率？**</span><br><span class="line"></span><br><span class="line">**回答:**</span><br><span class="line">在这个项目中，我采用了C/S架构，服务器端使用Qt的QTcpServer类来监听客户端的连接请求，并为每个连接的客户端创建一个独立的QTcpSocket对象来处理通信。为了支持多客户端并发，我使用了多线程技术，每个客户端的通信都在一个独立的线程中进行，避免了阻塞主线程。</span><br><span class="line"></span><br><span class="line">为了确保通信的稳定性，我实现了心跳机制，定期检查客户端与服务器的连接状态。如果发现连接断开，服务器会尝试重新连接或通知系统管理员。此外，我还使用了Qt的信号与槽机制来处理异步通信，确保数据的及时传输和处理。</span><br><span class="line"></span><br><span class="line">为了提高通信效率，我使用了数据包的分片和重组技术，将大数据包分成多个小数据包进行传输，减少了网络延迟的影响。同时，我还使用了Qt的QDataStream类来进行数据的序列化和反序列化，确保数据的高效传输和解析。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; 面试问题 3:</span></span><br><span class="line"><span class="string">**你在基于imx6ul的智能家居项目中提到了驱动代码的编写。你能详细说明一下你是如何编写和调试这些驱动的吗？特别是在Qt移植到ARM平台时，遇到了哪些挑战，你是如何解决的？**</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">以一个LED驱动为例，先定义一个 file_operations 结构体，接着编写 init 函数，在init函数中完成对管脚的映射，register_chrdev 字符设备的注册，class_create 类的注册，class_device_create 在类下面注册一个设备。exit 函数中完成字符设备的卸载，类的卸载，内存空间的释放。在open函数中完成硬件管脚的初始化，在write函数中完成点灯操作。</span></span><br><span class="line"><span class="string">file_operations (fai_欧扑锐醒)</span></span><br><span class="line"><span class="string">register_chrdev （ruai 急死特_磕带屋）</span></span><br><span class="line"><span class="string">class_create （亏A特）</span></span><br><span class="line"><span class="string">class_device_create（低畏死_亏A特）</span></span><br><span class="line"><span class="string">exit (挨可谁特)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答:**</span></span><br><span class="line"><span class="string">在智能家居项目中，我负责编写了LED、SR04、DHT11、SR501等硬件模块的驱动代码。首先，我参考了imx6ul开发板的硬件手册和Linux内核文档，了解了每个硬件模块的寄存器配置和通信协议。然后，我使用C语言编写了这些模块的驱动代码，并通过Linux内核模块的方式加载到系统中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在调试过程中，我使用了printk函数在内核日志中输出调试信息，帮助我定位和解决问题。此外，我还使用了示波器和逻辑分析仪来检查硬件信号的正确性，确保驱动代码与硬件模块的正常通信。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在将Qt移植到ARM平台时，我遇到的主要挑战是交叉编译环境的搭建和Qt库的依赖问题。为了解决这些问题，我首先在Ubuntu上搭建了交叉编译工具链，并配置了Qt的编译选项。然后，我逐步解决了Qt库的依赖问题，确保所有必要的库都能在ARM平台上正确运行。最终，我成功将Qt应用程序移植到了imx6ul开发板上，并实现了预期的功能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span> 面试问题 <span class="number">4</span>:</span><br><span class="line">**你在动量轮平衡自行车项目中提到了PID算法的调试。你能详细说明一下你是如何调试PID参数的，以及在调试过程中遇到了哪些问题，你是如何解决的？**</span><br><span class="line">    </span><br><span class="line">PID：</span><br><span class="line">假设我们要对无人机进行PID参数调试</span><br><span class="line">KP的越大，螺旋桨转的越快，向上的力就越大，误差也越大，响应速度也越快，产生的震荡幅度也越大.</span><br><span class="line">KD, 会抵消部分KP的升力（也就是向上的力），让其震荡幅度变小</span><br><span class="line">KI, 无人机的误差存在，无人机的升力也一定存在，当无人机接近目标的高度时，最终会和重力平衡，此时无人机将不会再上升，为了解决这个问题，我们需要累积这个误差值，如果长时间无人机得不到修正，我们需要给无人机提供更大的升力，让无人机上升与目标高度一致</span><br><span class="line"></span><br><span class="line">**回答:**</span><br><span class="line">在动量轮平衡自行车项目中，我使用了PID算法来控制无刷电机，通过调节动量轮的转速来实现小车的自主平衡。在调试PID参数时，我首先根据经验设置了一组初始参数，然后通过实验逐步调整这些参数，直到系统达到稳定的平衡状态。</span><br><span class="line"></span><br><span class="line">在调试过程中，我遇到的主要问题是系统的振荡和不稳定。为了解决这个问题，我首先调整了比例系数（P），减少了系统的振荡。然后，我逐步增加了积分系数（I），以消除系统的静态误差。最后，我调整了微分系数（D），以提高系统的响应速度和稳定性。</span><br><span class="line"></span><br><span class="line">为了更直观地观察系统的响应，我使用了串口通信将传感器的实时数据发送到PC端，并使用MATLAB绘制了系统的响应曲线。通过这些曲线，我可以更准确地调整PID参数，最终实现了小车的稳定平衡。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; 面试问题 5:</span></span><br><span class="line"><span class="string">**你在简历中提到了熟悉SPI、IIC等总线协议。你能详细说明一下你在项目中是如何使用这些总线协议的吗？特别是在硬件与软件交互时，如何确保通信的可靠性？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答:**</span></span><br><span class="line"><span class="string">在项目中，我使用了SPI和IIC总线协议来实现硬件模块与主控芯片之间的通信。例如，在智能家居项目中，我使用IIC总线与DHT11温湿度传感器进行通信，获取环境数据。在动量轮平衡自行车项目中，我使用SPI总线与MPU6050陀螺仪进行通信，获取小车的姿态数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了确保通信的可靠性，我首先在硬件设计上确保了信号线的正确连接和屏蔽，减少了电磁干扰的影响。在软件层面，我使用了硬件提供的库函数或自行编写了通信协议，确保数据的正确传输和解析。此外，我还实现了错误检测和重传机制，如果在通信过程中出现错误，系统会自动重传数据，确保数据的完整性和可靠性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在调试过程中，我使用了逻辑分析仪来捕获总线上的信号，检查通信时序和数据是否正确。通过这些手段，我确保了硬件与软件之间的可靠通信。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span> 面试问题 <span class="number">6</span>:</span><br><span class="line">**你在简历中提到了熟悉Linux系统编程和常见的模块驱动编写。你能详细说明一下你在Linux环境下是如何编写和调试驱动的吗？特别是在设备树的使用上，你是如何操作的？**</span><br><span class="line"></span><br><span class="line">**回答:**</span><br><span class="line">在Linux环境下，我通常使用C语言编写设备驱动。首先，我会根据硬件模块的规格书和Linux内核的文档，了解设备的寄存器配置和通信协议。然后，我会编写驱动代码，并将其编译为内核模块，通过insmod命令加载到系统中。</span><br><span class="line"></span><br><span class="line">在调试驱动时，我通常会使用printk函数在内核日志中输出调试信息，帮助我定位问题。此外，我还会使用dmesg命令查看内核日志，检查驱动的加载和运行情况。</span><br><span class="line"></span><br><span class="line">在设备树的使用上，我首先会在设备树源文件（.dts）中定义设备的硬件信息，例如寄存器地址、中断号等。然后，我会使用设备树编译器（dtc）将.dts文件编译为设备树二进制文件（.dtb），并将其加载到内核中。通过设备树，内核可以自动识别和配置硬件设备，减少了手动配置的工作量。</span><br><span class="line"></span><br><span class="line">在调试设备树时，我通常会使用of_*系列函数来解析设备树中的节点和属性，确保驱动能够正确获取硬件信息。通过这些方法，我能够高效地编写和调试Linux驱动。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; 面试问题 7:</span></span><br><span class="line"><span class="string">**你在简历中提到了熟悉Qt、Vscode、虚拟机等工具的使用。你能详细说明一下你在项目开发中是如何使用这些工具来提高开发效率的吗？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答:**</span></span><br><span class="line"><span class="string">在项目开发中，我通常会使用Qt Creator进行Qt应用程序的开发。Qt Creator提供了强大的代码编辑、调试和界面设计功能，能够大大提高开发效率。特别是在界面设计上，Qt Creator的拖拽式设计工具让我能够快速构建用户界面，并通过信号与槽机制实现界面与逻辑的分离。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">对于代码编辑，我通常会使用VSCode作为辅助工具。VSCode提供了丰富的插件支持，例如C/C++插件、Git插件等，能够帮助我更好地管理代码和版本控制。此外，VSCode的智能提示和代码格式化功能也大大提高了我的编码效率。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在开发嵌入式系统时，我通常会使用虚拟机来搭建交叉编译环境。通过在虚拟机中安装Ubuntu系统，我可以在同一台机器上进行开发和测试，避免了频繁切换操作系统的麻烦。此外，虚拟机还提供了快照功能，能够帮助我快速恢复到之前的开发状态，减少了调试时间。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过这些工具的使用，我能够更高效地进行项目开发，确保项目的按时交付。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span> 面试问题 <span class="number">8</span>:</span><br><span class="line">**你在简历中提到了熟悉ARM裸机开发。你能详细说明一下你在裸机开发中的经验吗？特别是在没有操作系统的情况下，你是如何管理硬件资源和实现功能的？**</span><br><span class="line"></span><br><span class="line">**回答:**</span><br><span class="line">在ARM裸机开发中，我通常会直接操作硬件寄存器来控制外设。例如，在动量轮平衡自行车项目中，我使用STM32F103C8T6作为主控芯片，直接操作GPIO寄存器来控制LED、电机等外设。</span><br><span class="line"></span><br><span class="line">在没有操作系统的情况下，我通常会编写一个简单的主循环来管理任务的执行。例如，在主循环中，我会定期读取传感器的数据，并根据这些数据调整电机的转速，实现小车的平衡控制。为了确保系统的实时性，我通常会使用定时器中断来处理时间敏感的任务，例如PWM信号的生成和传感器的数据采集。</span><br><span class="line"></span><br><span class="line">在资源管理上，我会手动分配和管理内存，避免内存泄漏和碎片化。此外，我还会使用状态机来管理系统的状态转换，确保系统的稳定运行。</span><br><span class="line"></span><br><span class="line">通过这些方法，我能够在裸机环境下高效地管理硬件资源，并实现复杂的功能。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; 面试问题 9:</span></span><br><span class="line"><span class="string">**你在简历中提到了熟悉Linux命令和网络编程。你能详细说明一下你在项目开发中是如何使用这些技能的吗？特别是在网络编程中，你是如何处理高并发和网络延迟的？**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**回答:**</span></span><br><span class="line"><span class="string">在项目开发中，我经常使用Linux命令来进行系统管理和调试。例如，我会使用grep命令查找日志文件中的关键信息，使用ps命令查看进程状态，使用netstat命令检查网络连接等。这些命令帮助我快速定位和解决问题，提高了开发效率。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在网络编程中，我通常会使用TCP/IP协议来实现客户端与服务器之间的通信。为了处理高并发，我使用了多线程技术，为每个客户端连接创建一个独立的线程来处理通信。此外，我还使用了线程池技术，避免了频繁创建和销毁线程的开销，提高了系统的性能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了减少网络延迟的影响，我使用了非阻塞I/O和异步通信技术。例如，在Qt中，我使用了QTcpSocket的非阻塞模式来处理网络通信，确保系统能够及时响应网络事件。此外，我还使用了数据压缩和分片技术，减少了网络传输的数据量，进一步降低了网络延迟。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过这些方法，我能够有效地处理高并发和网络延迟，确保系统的稳定性和响应速度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span> 面试问题 <span class="number">10</span>:</span><br><span class="line">**你在简历中提到了熟悉万能表、示波器的使用。你能详细说明一下你在硬件调试中是如何使用这些工具的吗？特别是在调试复杂的电路时，你是如何定位和解决问题的？**</span><br><span class="line"></span><br><span class="line">**回答:**</span><br><span class="line">在硬件调试中，我通常会使用万用表来测量电路中的电压、电流和电阻值，确保电路的正常工作。例如，在动量轮平衡自行车项目中，我使用万用表检查了电源模块的输出电压，确保电机和传感器能够正常工作。</span><br><span class="line"></span><br><span class="line">对于复杂的电路调试，我通常会使用示波器来观察信号的波形。例如，在调试SPI或IIC通信时，我使用示波器捕获总线上的信号，检查通信时序和数据是否正确。通过观察波形，我可以快速定位通信问题，例如信号抖动、噪声干扰等。</span><br><span class="line"></span><br><span class="line">在调试过程中，我还会使用逻辑分析仪来捕获和分析数字信号。例如，在调试嵌入式系统时，我使用逻辑分析仪捕获GPIO引脚的电平变化，检查系统的状态转换是否正确。通过这些工具的使用，我能够快速定位和解决硬件问题，确保系统的稳定运行。</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;面试问题 11</span></span><br><span class="line"><span class="string">你在简历中提到熟悉数据库操作，能否举例说明你在项目中如何使用MySQL数据库？</span></span><br><span class="line"><span class="string">回答:</span></span><br><span class="line"><span class="string">在基于Linux的Qt点餐系统项目中，我使用了MySQL数据库来存储用户信息、菜单信息和订单信息。</span></span><br><span class="line"><span class="string">数据库设计：</span></span><br><span class="line"><span class="string">我设计了多个数据库表，包括用户表、菜单表、订单表等，确保数据的结构化存储。</span></span><br><span class="line"><span class="string">在用户表中，我存储了用户的ID、姓名、权限等信息；在菜单表中，我存储了菜品的ID、名称、价格等信息；在订单表中，我存储了订单的ID、用户ID、菜品ID、订单状态等信息。</span></span><br><span class="line"><span class="string">数据库操作：</span></span><br><span class="line"><span class="string">在Qt应用程序中，我使用QSqlDatabase类连接到MySQL数据库，并通过QSqlQuery类执行SQL语句。</span></span><br><span class="line"><span class="string">例如，在用户管理页面中，我使用INSERT语句添加新用户，使用UPDATE语句修改用户信息，使用DELETE语句删除用户，使用SELECT语句查询用户信息。</span></span><br><span class="line"><span class="string">通过这些工作，我熟悉了MySQL数据库的基本操作，并能够在实际项目中实现数据的增删改查功能。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;</span>面试问题 <span class="number">12</span></span><br><span class="line">你在简历中提到熟悉Qt移植到ARM的过程，能否详细说明你在项目中如何将Qt应用程序移植到imx6ul开发板上？</span><br><span class="line">还有关于qt移植，需要将qt移植到板子上运行，第一步：准备 qt 库文件和 tslib 库（触摸屏），</span><br><span class="line">    </span><br><span class="line">交叉编译环境搭建：</span><br><span class="line">    首先，我在Ubuntu主机上搭建了交叉编译环境，安装了ARM架构的交叉编译工具链（如arm-linux-gnueabihf-gcc）。</span><br><span class="line">    然后，我下载并编译了Qt的源码，配置了交叉编译选项，确保生成的Qt库可以在imx6ul开发板上运行。</span><br><span class="line">Qt应用程序编译：</span><br><span class="line">    在主机上，我使用交叉编译工具链编译Qt应用程序，生成ARM架构的可执行文件。</span><br><span class="line">    编译过程中，我确保所有的依赖库（如Qt库、第三方库等）都正确链接。</span><br><span class="line">移植到开发板：</span><br><span class="line">    将编译好的Qt应用程序和依赖库通过TFTP或NFS等方式传输到imx6ul开发板上。</span><br><span class="line">    在开发板上，我设置了环境变量（如LD_LIBRARY_PATH），确保应用程序能够正确找到依赖库。</span><br><span class="line">    最后，我通过命令行运行Qt应用程序，确保其能够在开发板上正常运行。</span><br><span class="line">    通过这些步骤，我成功将Qt应用程序移植到了imx6ul开发板上，并实现了智能家居系统的交互界面。</span><br><span class="line">    </span><br><span class="line">rm板子挂载nfs文件系统就可以和ubantu 共享这个文件夹</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>c/c++/嵌入式面经</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ze520ze.github.io/posts/20.html">https://ze520ze.github.io/posts/20.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Z💭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-04-27</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-04-27</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>面试题</a><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>八股文</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>面经</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://npm.elemecdn.com/xianqi-hexo/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/img/reward/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/xianqi-hexo/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/img/reward/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/21.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/imgg/21.webp" onerror='onerror=null,src="/assets/r2.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">c++</div></div></a></div><div class="next-post pull-right"><a href="/posts/19.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/imgg/19.webp" onerror='onerror=null,src="/assets/r2.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">嵌入式基础面试题</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:700">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-text">内存映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shm%E5%92%8Cmmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">shm和mmap的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-text">信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Makefile"><span class="toc-text">Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%B9%96%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-text">什么是进程﹖什么是线程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E9%97%AE%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">请问进程和线程有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">线程的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">何时使用多进程，何时使用多线程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">进程、线程间通信方式有哪些?有什么优缺点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">互斥锁与信号量的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-%E5%92%8C-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%8C%BA%E5%88%AB"><span class="toc-text">自旋锁 和 信号量 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">进程上下文和中断上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-text">父进程、子进程的关系以及区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="toc-text">同步和异步和互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">孤儿进程、僵尸进程、守护进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%B1%E5%AE%B3%EF%BC%8C%E5%92%8C%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">僵尸进程的危害，和解决的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">IO多路复用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">两个Linux操作系统之间使用什么命令进行文件的传递?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8"><span class="toc-text">驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Uboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">Uboot启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uboot%E5%A6%82%E4%BD%95%E5%BC%95%E5%AF%BC%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E7%9A%84"><span class="toc-text">Uboot如何引导内核启动的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Uboot-%E4%B8%8D%E7%94%A8%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F"><span class="toc-text">为什么需要Uboot?不用行不行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%92%8C%E5%9D%97%E8%AE%BE%E5%A4%87%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-text">字符设备有哪些?和块设备有什么区别?如何写一个字符设备驱动?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4-%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-text">什么是内核空间?什么是用户空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">用户空间和内核空间的通信方式?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uboot%E5%90%AF%E5%8A%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E9%97%AD%E4%B8%AD%E6%96%AD%EF%BC%8CMMU-DCACHE%E4%B9%8B%E7%B1%BB%E7%9A%84"><span class="toc-text">uboot启动为什么要关闭中断，MMU,DCACHE之类的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#busybox%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">busybox是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">什么是根文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uboot%E5%90%AF%E5%8A%A8%E5%89%8D%E8%BF%98%E9%9C%80%E8%A6%81%E5%81%9A%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-text">uboot启动前还需要做那些事情?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bootloader-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B6%B3%E5%A4%9F%E7%9A%84%E5%B0%8F%EF%BC%9F"><span class="toc-text">bootloader 第一个阶段为什么要足够的小？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E7%BC%96%E7%A8%8B%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">socket编程的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E3%80%81UDP-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">TCP、UDP 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">三次握手的和四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%9D%A0%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">TCP 为什么是可靠连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82-TCP-IP-%E5%9B%9B%E5%B1%82"><span class="toc-text">OSI 七层 TCP&#x2F;IP 四层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">TCP粘包问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">arm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BD%AE-0-%E6%88%96-1-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">寄存器置 0 或 1 的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arm%E6%9C%89%E5%87%A0%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9F"><span class="toc-text">arm有几个寄存器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCPSR%EF%BC%8CSPSR-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0"><span class="toc-text">什么是CPSR，SPSR ?什么时候用到?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-text">什么是交叉编译?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI-%E6%A8%A1%E5%BC%8F"><span class="toc-text">SPI 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI-%E6%9C%89-4-%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%BD%A0%E7%9F%A5%E9%81%93%E6%98%AF%E9%82%A3-4-%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%90%97%EF%BC%9F"><span class="toc-text">SPI 有 4 种模式你知道是那 4 种模式吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI-%E6%9C%894%E6%9D%A1%E7%BA%BF"><span class="toc-text">SPI 有4条线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C"><span class="toc-text">I2C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE-IIC%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%94%BB%E4%B8%8B%E3%80%82IC%E8%8A%AF%E7%89%87%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">如何发送一个数据? IIC时序图画下。IC芯片有哪些</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">算法和数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">实现字符串的库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#strcpy"><span class="toc-text">strcpy ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen"><span class="toc-text">strlen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcat"><span class="toc-text">strcat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">反转字符串中的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BAS%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">一个数组，找出和为S的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%80%E5%8C%96"><span class="toc-text">二叉树退化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完美二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完全二叉树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">操作系统和计算机组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MMU%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83%EF%BC%89"><span class="toc-text">MMU（存储器管理单元）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">堆和栈的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-text">堆和栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E7%A9%BA%E9%97%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%BF%9E%E7%BB%AD"><span class="toc-text">栈的空间为什么不连续</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin%E6%96%87%E4%BB%B6%E5%92%8Celf%E6%96%87%E4%BB%B6%E5%8C%BA%E5%88%AB"><span class="toc-text">bin文件和elf文件区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%8F%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">什么是哈希表，又如何使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A0%88%E5%92%8C%E5%86%85%E6%A0%B8%E6%A0%88%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9F%9F%E5%90%97-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">用户栈和内核栈是同一个区域吗?有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E5%90%AC%E8%BF%87%E9%A1%B6%E5%8D%8A%E9%83%A8%E5%92%8C%E5%BA%95%E5%8D%8A%E9%83%A8%E5%90%97-%E8%AE%B2%E8%AE%B2"><span class="toc-text">中断的响应执行流程?听过顶半部和底半部吗?讲讲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uboot%E5%90%AF%E5%8A%A8%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%BF%98%E6%98%AF%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-MMU%E8%A6%81%E5%BC%80%E5%90%AF%E5%90%97"><span class="toc-text">uboot启动时使用的是物理地址还是虚拟地址? MMU要开启吗?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">C</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">c++ 五个分区(内存分配)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="toc-text">指针与引用区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99-%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-text">重载 重写 隐藏（重定义）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%86%99"><span class="toc-text">死循环有几种方式来写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-text">左值和右值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%E5%8C%BA%E5%88%AB"><span class="toc-text">数组名和指针区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98%EF%B8%B0%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%BAin-t-%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88"><span class="toc-text">编程题︰指针函数，函数的参数为in t ，返回值为字符指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%B1%82%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-text">宏定义求最大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef-%E5%92%8C-define-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">typedef 和 define 有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">函数指针和指针函数有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-text">野指针是什么?如何避免野指针?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-a-5-1-2-3-4-5-sizeof-a"><span class="toc-text">int a[5]&#x3D;{1,2,3,4,5},sizeof(a)&#x3D; ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">数组和链表的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%85%B6%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">什么是智能指针？如何解决其内存泄漏问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-C-%E2%80%9D-%E5%92%8C-extern-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">extern&quot;C&quot;” 和 extern 的作用是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-text">C 语言字节对齐的规则，为什么要字节对齐？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%8C%87%E9%92%88%E8%BF%98%E8%A6%81%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">C++为什么有指针还要引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9FC-11-%E6%96%B0%E7%89%B9%E6%80%A7%E7%94%A8%E7%9A%84%E5%A4%9A%E5%90%97"><span class="toc-text">C++了解吗？C++11 新特性用的多吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">什么是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E5%A4%9A%E6%80%81"><span class="toc-text">c++ 多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual"><span class="toc-text">virtual</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">类是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">对象是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%EF%BC%88class%EF%BC%89%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88struct-s%E6%8A%93%E5%85%8Bt-%EF%BC%89%E5%92%8C%E2%80%8C-%E8%81%94%E5%90%88%E4%BD%93-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">类（class）与结构体（struct(s抓克t)）和‌ 联合体 的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E5%92%8C-malloc"><span class="toc-text">new 和 malloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E5%AE%9E%E7%8E%B0%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%90%97"><span class="toc-text">new 实现需要类型转换吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E5%BA%95%E5%B1%82%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">new 底层是用什么实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">构造函数和析构函数能被声明为虚函数吗，为什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%A4%9A%E6%80%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-text">C++多态，以及怎么实现? 虚函数指针 虚函数表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap"><span class="toc-text">hashmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%87%8F%E5%B0%91%E5%BC%80%E9%94%80"><span class="toc-text">Linux线程并发时，如何改进锁的使用，减少开销?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-text">拷贝构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">移动构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">内存泄露</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">QT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E4%BF%A1%E5%8F%B7%E6%A7%BD-%E5%87%A0%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F-connect%E5%87%BD%E6%95%B0"><span class="toc-text">Qt信号槽?几种连接方式? connect函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Qt"><span class="toc-text">为什么用Qt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E6%8E%A7%E4%BB%B6%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-text">Qt控件，自定义控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PV%E6%93%8D%E4%BD%9C"><span class="toc-text">PV操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9QT%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">对QT的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qt%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%92%8Cjson%E4%BD%BF%E7%94%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="toc-text">qt界面开发和json使用方面的经验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%A7%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">信号槽机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-text">事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="toc-text">Qt三大核心机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">实习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">基于imx6ull的智能家居项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">基于Linux、QT、C++的点餐系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">动量轮平衡自行车</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">整体面试流程</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-color:transparent"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/social/link/">我的朋友</a></li><li><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a></li><li><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.ze520.cn/" title="Xianqi💭"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By Z💭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><script async>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading()),setTimeout((function(){preloader.endLoading()}),5e3),document.getElementById("loading-box").addEventListener("click",(()=>{preloader.endLoading()}))</script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://ze.ze520.cn/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="30" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐵 ZのJava基础笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/hexo/博客/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐶 Zの博客笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🦊 Zの嵌入式笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/单片机/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🦊 Zの嵌入式笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://ze520ze.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(33.333333333333336% - 5px);background:#e9e9e9;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var i=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),i.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/imgg/3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/imgg/9.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9.html&quot;);" href="javascript:void(0);" alt="">hexo butterfly主题博客</a><div class="blog-slider__text">hexo butterfly主题博客 教程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("gitZone").insertAdjacentHTML("afterbegin",'<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>'),console.log("已挂载gitcalendar")}document.getElementById("gitZone")&&"/site/census/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("/api?null",["#d9e0df","#c6e0dc","#a8dcd4","#9adcd2","#89ded1","#77e0d0","#5fdecb","#47dcc6","#39dcc3","#1fdabe","#00dab9"],"null"))</script></body></html>