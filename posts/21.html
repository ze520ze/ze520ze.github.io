<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>c++ | Z💭</title><meta name="keywords" content="c++"><meta name="author" content="Z💭"><meta name="copyright" content="Z💭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="c++"><meta property="og:type" content="article"><meta property="og:title" content="c++"><meta property="og:url" content="https://ze520ze.github.io/posts/21.html"><meta property="og:site_name" content="Z💭"><meta property="og:description" content="c++"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://npm.elemecdn.com/xianqi-hexo/imgg/21.webp"><meta property="article:published_time" content="2025-04-27T02:40:00.000Z"><meta property="article:modified_time" content="2025-04-27T02:51:19.166Z"><meta property="article:author" content="Z💭"><meta property="article:tag" content="c++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://npm.elemecdn.com/xianqi-hexo/imgg/21.webp"><link rel="shortcut icon" href="https://thirdqq.qlogo.cn/g?b=sdk&nk=2287853439&s=140"><link rel="canonical" href="https://ze520ze.github.io/posts/21"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:230},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"var(--theme-color)",bgDark:"#191919",position:"top-right"},source:{justifiedGallery:{js:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js",css:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"c++",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-04-27 10:51:19"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Z💭" type="application/atom+xml"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=sdk&amp;nk=2287853439&amp;s=140" onerror='onerror=null,src="/assets/r1.jpg"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Z💭</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg> <span>搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">c++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span> <time class="post-meta-date-created" datetime="2025-04-27T02:40:00.000Z" title="发表于 2025-04-27 10:40:00">2025-04-27</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-27T02:51:19.166Z" title="更新于 2025-04-27 10:51:19">2025-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>95分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="c++"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>相遇皆是缘分</p><p>从C到C++</p><h3 id="动态内存分配（new）">动态内存分配（new）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用“new”动态分配的内存空间，一定要用“delete”运算符进行释放，否则无法释放，delete会调用析构函数</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure><h3 id="内联函数（了解）">内联函数（了解）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数定义前面加 “inline” 关键字，即可定义内联函数</span></span><br><span class="line"></span><br><span class="line">用于执行只有几条语句的函数，执行非常快，且经常被执行时，更能减少函数调用的开销</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载">函数重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个或多个函数，名字相同，然后参数个数或参数类型不相同，这叫做函数的重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">double</span> fl,<span class="type">double</span> f2)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2,<span class="type">int</span> n3)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【函数的缺省参数】</span><br><span class="line"> <span class="comment">//让最右边的连续若干个参数有缺省值，那么调用函数的时候，相应的位置不写参数，参数就是缺省值</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2=<span class="number">2</span>, <span class="type">int</span> x3=<span class="number">3</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">func</span>(<span class="number">10</span>);   <span class="comment">//等效于 func(10,2,3)</span></span><br><span class="line"> <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">8</span>)  <span class="comment">//等效于 func(10,8,3)</span></span><br><span class="line"> <span class="built_in">func</span>(<span class="number">10</span>,,<span class="number">8</span>) <span class="comment">//不行，只能最右边的连续若干个参数缺省</span></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类和对象">类和对象</h2><h3 id="访问权限">访问权限</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">private: 私有成员，只能在成员函数内访问,可以通过 set , get 来更改</span></span><br><span class="line"><span class="comment">public: 公有成员，可以在任何地方访问</span></span><br><span class="line"><span class="comment">protected: 保护成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//私有的(在主函数中，不可以使用)</span></span><br><span class="line">	<span class="comment">// protected  受保护的(在主函数中，不可以使用)</span></span><br><span class="line">	<span class="type">float</span> money;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//共有的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_money</span><span class="params">()</span> </span>&#123;  <span class="comment">//set方法（函数）</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;money = <span class="number">3.14f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">get_money</span><span class="params">()</span> </span>&#123; <span class="comment">//get方法（函数）</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;money;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数和析构函数">构造函数和析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.名字与类名相同，可以有参数，不能有返回值</span></span><br><span class="line"><span class="comment">2.作用是：对对象进行初始化，如给成员变量赋初值</span></span><br><span class="line"><span class="comment">3.没写构造函数，编译器会生成一个默认无参数构造参数（不做任何操作）</span></span><br><span class="line"><span class="comment">4.自动运行，不需要自己调用</span></span><br><span class="line"><span class="comment">【创建对象时，构造函数一定存在，无论是你写的，还是默认生成的】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">【构造函数无参】</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name2;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name3;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name4;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name5;</span><br><span class="line">	<span class="built_in">Stu</span>() &#123; <span class="comment">// “构造函数” 这个函数很特殊，没有返回值的类型，必须与类的名字相同</span></span><br><span class="line">			<span class="comment">//  自动运行，不需要自己调用</span></span><br><span class="line">			<span class="comment">//  常用来解决初始化问题</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name2 = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name3 = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name4 = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name5 = <span class="literal">NULL</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是构造函数\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Stu</span>() &#123;<span class="comment">// “析构函数” 这个函数很特殊，没有返回值的类型，在类的名字前加 ~</span></span><br><span class="line">			<span class="comment">//  自动运行，不需要自己调用</span></span><br><span class="line">			<span class="comment">//  常用来解决函数中资源进行释放</span></span><br><span class="line">        	 <span class="comment">//  跟构造函数不同，只能有一个</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是析构函数\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Stu</span> boy;  <span class="comment">//1.创建对象</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"> 【析构函数执行多少次？】</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数\n&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	A* p = <span class="keyword">new</span> A[<span class="number">2</span>];</span><br><span class="line">	A* p2 = <span class="keyword">new</span> A;  <span class="comment">// new 需要 用 delete 来释放执行析构函数，没有 delete p2</span></span><br><span class="line">	A a;	      <span class="comment">//执行1次</span></span><br><span class="line">	<span class="keyword">delete</span>[] p;   <span class="comment">//执行2次</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//  析构函数执行共3次</span></span><br><span class="line">--------------------------------------------------------- </span><br><span class="line">    </span><br><span class="line">【构造函数有参】</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">	<span class="built_in">Stu</span>(<span class="type">int</span> n) &#123; </span><br><span class="line">		v=n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">class</span> Stu <span class="title">boy</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">class</span> Stu <span class="title">boy</span><span class="params">()</span></span>;   <span class="comment">//错误，没传参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">    </span><br><span class="line">【多个构造函数有参】</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	<span class="built_in">Stu</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是构造函数Stu()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Stu</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是构造函数Stu1()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Stu</span>(<span class="type">int</span> age,<span class="type">int</span> score) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是构造函数Stu2()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Stu</span> boy;</span><br><span class="line"><span class="comment">//	class Stu boy2(100);</span></span><br><span class="line"><span class="comment">//	class Stu boy3(100,200);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复制构造函数">复制构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义：</span></span><br><span class="line"><span class="comment">1.只有一个参数，即对同类对象的引用</span></span><br><span class="line"><span class="comment">2.没有定义复制构造函数，会默认生成</span></span><br><span class="line"><span class="comment">3.形如 XXX(const XXX &amp;) 或者 XXX( XXX&amp; )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">作用：</span></span><br><span class="line"><span class="comment">1.当用一个对象去初始化同类的另一个对象时</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">stu c1;</span></span><br><span class="line"><span class="comment">stu c2(c1);</span></span><br><span class="line"><span class="comment">stu c2=c1;    //初始化语句，非赋值语句</span></span><br><span class="line"><span class="comment">上面二条语句等价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：对象间赋值不导致复制构造函数被调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">stu c1,c2;</span></span><br><span class="line"><span class="comment">c2=c1;   //对象间赋值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.如果某函数有一个函数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class A</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	public:</span></span><br><span class="line"><span class="comment">	A()&#123;&#125;;</span></span><br><span class="line"><span class="comment">	A(A&amp;a)&#123;</span></span><br><span class="line"><span class="comment">	cout&lt;&lt;&quot;复制构造函数&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void Func(A a1)&#123;&#125;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    A a2;</span></span><br><span class="line"><span class="comment">    Func(a2);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class A</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	public:</span></span><br><span class="line"><span class="comment">	int v;</span></span><br><span class="line"><span class="comment">	A(int n)&#123;v=n;&#125;</span></span><br><span class="line"><span class="comment">	A(const A &amp; a)&#123;</span></span><br><span class="line"><span class="comment">		v=a.v;</span></span><br><span class="line"><span class="comment">		cout&lt;&lt;&quot;复制构造函数&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">A Func()&#123;</span></span><br><span class="line"><span class="comment">	A b(4);</span></span><br><span class="line"><span class="comment">	return b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;Func().v&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">【默认复制构造函数】</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">double</span> real,imag;</span><br><span class="line">&#125;</span><br><span class="line">Stu c1;  <span class="comment">//调用缺省无参构造函数</span></span><br><span class="line"><span class="function">Stu <span class="title">c2</span><span class="params">(c1)</span> <span class="comment">//调用缺省的复制构造函数，将c2初始化成和c1一样</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">---------------------------------------------------------</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">【定义复制构造函数】    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> <span class="keyword">class</span> Stu </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">double</span> real,imag;</span><br><span class="line">     <span class="built_in">stu</span>()&#123;&#125;</span><br><span class="line">     <span class="built_in">stu</span>(<span class="type">const</span> stu &amp; c)&#123;</span><br><span class="line">         real = c.real;</span><br><span class="line">         imag = c.imag;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">Stu c1;  <span class="comment">//调用定义无参构造函数</span></span><br><span class="line"><span class="function">Stu <span class="title">c2</span><span class="params">(c1)</span> <span class="comment">//调用定义的复制构造函数，将c2初始化成和c1一样   </span></span></span><br></pre></td></tr></table></figure><h3 id="类型转换构造函数">类型转换构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.定义转换构造函数的目的是实现类型的自动转换</span></span><br><span class="line"><span class="comment">2.只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数</span></span><br><span class="line"><span class="comment">3.当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="type">double</span> real,imag;</span><br><span class="line">        <span class="built_in">Stu</span>(<span class="type">int</span> i)&#123;    <span class="comment">//类型转换构造函数</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;类型转换构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">            real = i; imag =<span class="number">0</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">stu</span>(<span class="type">double</span> r ,<span class="type">double</span> i)&#123;</span><br><span class="line">            real = r;</span><br><span class="line">            imag = i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stu <span class="title">c1</span><span class="params">(<span class="number">7</span>,<span class="number">8</span>)</span></span>;  </span><br><span class="line">Stu c2=<span class="number">12</span>;   <span class="comment">//初始化语句，非赋值语句</span></span><br><span class="line">	c2=<span class="number">12</span>;   <span class="comment">//12被自动转换成一个临时Stu对象，12现在是一个对象，不是值，12这个对象由类型转换构造函数初始化，初始化的值是real=i,img =0 ; 将初始化的值都赋值给 c2 , 现在c2的值为 real=12,img =0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类和对象提高">类和对象提高</h2><h3 id="静态成员变量">静态成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享，全局。</span><br><span class="line">  <span class="comment">// sizeof 运算符不会计算静态成员变量</span></span><br><span class="line"><span class="number">2.</span>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用与某个对象。</span><br><span class="line"><span class="number">3.</span>因此静态成员不需要通过对象就能访。</span><br><span class="line">    </span><br><span class="line">静态成员：在说明前面加了<span class="type">static</span>关键字的成员</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nTotalArea;    <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintTotal</span><span class="params">()</span>  <span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//必须在定义类的文件中对静态成员变量进行一次说明或初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> obj;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Box::obj = <span class="number">0</span>;  <span class="comment">//初始化类 Box 的静态成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> obj;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Box::obj = <span class="number">0</span>;  <span class="comment">//初始化类 Box 的静态成员</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> cout&lt;&lt;Box::<span class="built_in">getCount</span>()&lt;&lt;endl;  <span class="comment">//静态成员函数即使在类对象不存在的情况下也能被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员对象和封装类">成员对象和封装类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;        </span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;父类A的 无参数构造函数被调用\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> temp) &#123;  <span class="comment">//构造函数重载</span></span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;父类A的 有参数构造函数被调用\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">B</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;父类B的 无参数构造函数被调用\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> temp) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;父类B的 有参数构造函数被调用\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> obj_1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------\n&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">class</span> B <span class="title">obj_2</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">无参构造函数是默认调用有</span></span><br><span class="line"><span class="comment">调用子类B时，会自动调用父类A的无参构造函数，但如果你要求调用父类A的有参构造函数，需要用初始化列表，否则调用不了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">为什么父类A中的构造函数被调用呢？</span></span><br><span class="line"><span class="comment">答：如果父类有Private修饰的成员变量，在子类中是无法使用，</span></span><br><span class="line"><span class="comment">也就是意味子类不能够对这些private成员变量进行初始化，因此就需要调用父类的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化列表</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/680d99f758cb8da5c8cfdd2f.png" alt=""></p><h3 id="初始化列表">初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">【初始化列表调用父类的构造函数】</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> temp) &#123;  <span class="comment">//构造函数重载</span></span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;父类A的 有参数构造函数被调用\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">11</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;子类B的 无参数构造函数被调用\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表，父类没有无参构造体，可以用有参构造体</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> temp) : <span class="built_in">A</span>(<span class="number">22</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;子类B的 有参数构造函数被调用\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> obj_1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------\n&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">class</span> B <span class="title">obj_2</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line">    </span><br><span class="line">【初始化列表-多继承】</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> num) &#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A::A(int num),num=&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;,this=&quot;</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> num) &#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B::B(int num),num=&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;,this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承初始化列表，按继承顺序调用，</span></span><br><span class="line"><span class="comment">// public A,public B 这里先调用父类A的，再调用父类B的</span></span><br><span class="line"><span class="comment">// public B,public A 这里先调用父类B的，再调用父类A的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B &#123;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">C</span>() : <span class="built_in">B</span>(<span class="number">200</span>),<span class="built_in">A</span>(<span class="number">100</span>) &#123;  </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C::C(),this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> num) : <span class="built_in">A</span>(num) , <span class="built_in">B</span>(num + num) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C::C(int num)\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">C</span> boy;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------\n&quot;</span>;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">C</span> girl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量对象-和-常量成员函数">常量对象 和 常量成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">【常量对象】</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">const</span> Stu s;  <span class="comment">//常量对象</span></span><br><span class="line"></span><br><span class="line">【常量成员函数】</span><br><span class="line"><span class="number">1.</span>在类的成员函数后面加 <span class="type">const</span> ，是常量成员函数</span><br><span class="line"><span class="number">2.</span>常用对象执行常量成员函数可行，常量对象不能执行非常量成员函数</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Sa</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stu::Sa</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> Stu o;</span><br><span class="line">    o.a=<span class="number">100</span>;  <span class="comment">//不可被修改</span></span><br><span class="line">    o.<span class="built_in">fun</span>();  <span class="comment">//常量对象不能执行非常量成员函数</span></span><br><span class="line">    o.<span class="built_in">Sa</span>();   <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【注意】</span><br><span class="line"> 两个成员函数，名字和参数表都一样，但是一个是<span class="type">const</span>,一个不是，算重载。</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Sa</span><span class="params">()</span> <span class="type">const</span> </span>&#123;...&#125;;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Sa</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="友元">友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// friend ：允许使用 private（私有）的变量或函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SSSS</span>; <span class="comment">//声明 SSSS 为Car类里的友元类，让其可以使用，同类Car类里面的 private 成员</span></span><br><span class="line">	<span class="built_in">Car</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num = num;    <span class="comment">//类函数本身就可以使用类中private</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display_num</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSSS</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">modify_car</span><span class="params">(Car* p)</span> </span>&#123; <span class="comment">//改装汽车</span></span><br><span class="line">		p-&gt;num = <span class="number">720</span>;    <span class="comment">//友元起作用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">SSSS</span> s;</span><br><span class="line">	<span class="function"><span class="keyword">class</span> Car <span class="title">bmw</span><span class="params">(<span class="number">525</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	bmw.<span class="built_in">display_num</span>();</span><br><span class="line">	s.<span class="built_in">modify_car</span>(&amp;bmw);</span><br><span class="line">	bmw.<span class="built_in">display_num</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载">运算符重载</h2><h3 id="成员函数方式">成员函数方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">定义： <span class="keyword">operator</span> 运算符符号</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line">     <span class="built_in">Student</span>(<span class="type">int</span> age):<span class="built_in">age</span>(age)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     Student <span class="keyword">operator</span>+(Student &amp;s)&#123;    <span class="comment">//重载+</span></span><br><span class="line">         <span class="function">Student <span class="title">temp</span><span class="params">(<span class="keyword">this</span>-&gt;age + s.age)</span></span>;</span><br><span class="line">         <span class="keyword">return</span> temp;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    Student s3 = s1 + s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/680d99f758cb8da5c8cfdd2d.png" alt=""></p><h3 id="全局函数方式">全局函数方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">定义： <span class="keyword">operator</span> 运算符符号</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line">     <span class="built_in">Student</span>(<span class="type">int</span> age):<span class="built_in">age</span>(age)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">  Student <span class="keyword">operator</span>+(Student &amp;s，Student &amp;ss)&#123;    <span class="comment">//重载+  全局函数</span></span><br><span class="line">         <span class="function">Student <span class="title">temp</span><span class="params">(s.age + ss.age)</span></span>;</span><br><span class="line">         <span class="keyword">return</span> temp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    Student s3 = s1 + s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/680d99f758cb8da5c8cfdd2e.png" alt=""></p><h3 id="赋值运算符重载">赋值运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> feet;             <span class="comment">// 0 到无穷</span></span><br><span class="line">      <span class="type">int</span> inches;           <span class="comment">// 0 到 12</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 所需的构造函数</span></span><br><span class="line">      <span class="built_in">Distance</span>()&#123;</span><br><span class="line">         feet = <span class="number">0</span>;</span><br><span class="line">         inches = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Distance</span>(<span class="type">int</span> f, <span class="type">int</span> i)&#123;</span><br><span class="line">         feet = f;</span><br><span class="line">         inches = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Distance &amp;D )</span><br><span class="line">      &#123; </span><br><span class="line">         feet = D.feet;</span><br><span class="line">         inches = D.inches;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 显示距离的方法</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">displayDistance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;F: &quot;</span> &lt;&lt; feet &lt;&lt;  <span class="string">&quot; I:&quot;</span> &lt;&lt;  inches &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Distance <span class="title">D1</span><span class="params">(<span class="number">11</span>, <span class="number">10</span>)</span>, <span class="title">D2</span><span class="params">(<span class="number">5</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;First Distance : &quot;</span>; </span><br><span class="line">   D1.<span class="built_in">displayDistance</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Second Distance :&quot;</span>; </span><br><span class="line">   D2.<span class="built_in">displayDistance</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用赋值运算符  ， 效果类似拷贝构造</span></span><br><span class="line">   D1 = D2;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;First Distance :&quot;</span>; </span><br><span class="line">   D1.<span class="built_in">displayDistance</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承">继承</h2><h3 id="继承和派生">继承和派生</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法   class 派生类名 ： public 基类名</span></span><br><span class="line">    		   子类		      父类</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Studnet</span> : <span class="keyword">public</span> People &#123;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(<span class="type">float</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span> : <span class="keyword">public</span> People &#123;	 </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setMoney</span><span class="params">(<span class="type">float</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;money;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建Studnet学生对象</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Studnet</span> boy;</span><br><span class="line">	boy.<span class="built_in">setName</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">	boy.<span class="built_in">setAge</span>(<span class="number">16</span>);</span><br><span class="line">	boy.<span class="built_in">setScore</span>(<span class="number">95.5f</span>);</span><br><span class="line">	cout &lt;&lt; boy.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;的年龄是&quot;</span> &lt;&lt; boy.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot;,成绩是&quot;</span> &lt;&lt; boy.<span class="built_in">getScore</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建Studnet员工对象</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Staff</span> girl;</span><br><span class="line">	girl.<span class="built_in">setName</span>(<span class="string">&quot;小丽&quot;</span>);</span><br><span class="line">	girl.<span class="built_in">setAge</span>(<span class="number">16</span>);</span><br><span class="line">	girl.<span class="built_in">setMoney</span>(<span class="number">4500.67</span>);</span><br><span class="line">	cout &lt;&lt; girl.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;的年龄是&quot;</span> &lt;&lt; girl.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot;,成绩是&quot;</span> &lt;&lt; girl.<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line">【子类函数中使用父类函数】</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A类中的test()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> num_2;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B类中的test_2()\n&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num_2;</span><br><span class="line">		<span class="comment">//如果想要使用父类中的被继承的成员（变量、函数），那么只需要在子类中，使用this-&gt;xxxx就可以</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;num;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> b;</span><br><span class="line">	b.<span class="built_in">test_2</span>();<span class="comment">//创建了子类对象后，可以通过子类对象直接，调用子类中的成员</span></span><br><span class="line">	b.<span class="built_in">test</span>(); <span class="comment">//也可以直接调用继承的父类中的成员</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h3 id="重写">重写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A类中的test()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A类中的test(int num)\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写：子类定义与父类相同名字的函数，覆盖了父类的这个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;   <span class="comment">// 子类将父类相同名字的函数都覆盖了（包括 void test(int num) ）</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B类中的test()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B类中的test(int num)\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B类中的test(int num, int num2)\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> boy;</span><br><span class="line">	boy.<span class="built_in">test</span>();</span><br><span class="line">	boy.<span class="built_in">test</span>(<span class="number">100</span>); </span><br><span class="line">	boy.<span class="built_in">test</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多层继承">多层继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grandpa</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Grandpa::display()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Grandpa::display_3()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> : <span class="keyword">public</span> Grandpa &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father::display()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father::display_2()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Children::display()&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//可以调用被重写的父类的成员函数，使用父类的名字::函数名();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用父类的成员函数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">display_2</span>();</span><br><span class="line">		<span class="comment">//调用被重写的父类成员函数（调用父类中的display()函数）</span></span><br><span class="line">		Father::<span class="built_in">display</span>();</span><br><span class="line">		<span class="comment">//调用爷爷类中的成员函数</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">display_3</span>();</span><br><span class="line">		<span class="comment">//调用被重写的爷爷类中成员函数（调用爷爷类中的display()函数）</span></span><br><span class="line">		Grandpa::<span class="built_in">display</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Children</span> boy;</span><br><span class="line">	boy.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承">多继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">make_money</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father类的 make_money()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mother</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">make_homework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Mother类的 make_homework()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">make_money</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Mother类的 make_money()\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承，一个子类继承多个父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father, <span class="keyword">public</span> Mother &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">make_money</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Father::<span class="built_in">make_money</span>();</span><br><span class="line">		Mother::<span class="built_in">make_money</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Son</span> s;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">make_money</span>();</span><br><span class="line">	s.<span class="built_in">make_homework</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态">多态</h2><blockquote><p>多态实现的关键—虚函数表</p></blockquote><h3 id="虚函数">虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">前面有 <span class="keyword">virtual</span> 关键字的成员函数就是 虚函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>	<span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  <span class="comment">// virtual,成为一个特殊的函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;father show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;children show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Father</span> *father = <span class="keyword">new</span> <span class="built_in">Father</span>();</span><br><span class="line">	father-&gt;<span class="built_in">show</span>(); <span class="comment">//调用父类的show函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Children</span> *children = <span class="keyword">new</span> <span class="built_in">Children</span>();</span><br><span class="line">	children-&gt;<span class="built_in">show</span>(); <span class="comment">//调用子类的show函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Father</span> *p = <span class="keyword">new</span> <span class="built_in">Children</span>(); </span><br><span class="line">	p-&gt;<span class="built_in">show</span>();	<span class="comment">//通过virtual修饰后，输出右侧（输出指针p指向的）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚函数表">虚函数表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>多态的函数调用语句被编译成一系列根据类指针所指向的对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址并调用虚函数的指令</span><br><span class="line"><span class="number">2.</span>每一个有虚函数的类都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。 </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A:Print&quot;</span>;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B:Print&quot;</span>;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B d;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：8，12    都多了4个字节，第一个虚函数的类都有一个虚函数表，4个字节装有虚函数表</span></span><br></pre></td></tr></table></figure><h3 id="虚析构函数">虚析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a;</span><br><span class="line">    a=<span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：A , 没有执行 子类析构函数</span></span><br><span class="line"></span><br><span class="line">解决：给父类析构函数加了 <span class="keyword">virtual</span> ，成为虚析构函数，子类也会默认成会 虚析构函数，不需要加 <span class="keyword">virtual</span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a;</span><br><span class="line">    a=<span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：B A </span></span><br></pre></td></tr></table></figure><h3 id="纯虚函数、抽象类">纯虚函数、抽象类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> 包括 纯虚函数 的类叫 抽象类</span><br><span class="line">	抽象类 只能作为 基类（父类），不能创建独立的抽象类的对象（只有抽象类作为父类没有子类不能创建，有子类可以创建）</span><br><span class="line">	抽象类的指针和引用可以指向由抽象类派生出来的类的对象</span><br><span class="line">在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数</span><br><span class="line">如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;  <span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数：只有函数名，没有具体过程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">this</span>-&gt;<span class="built_in">test2</span>();&#125;  <span class="comment">//多态，这里是调用的子类B的test2()，调用父类Test的test2()会出错</span></span><br><span class="line">	<span class="built_in">Test</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">test2</span>();      <span class="comment">//不是多态，调用父类Test的test2()会出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚函数 用于子类，父类写一个大概的框架，不写具体过程，子类来重写补充具体过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Test</span> t;   <span class="comment">//一个拥有纯虚函数的类，是不能创建对象的，那么这个类叫 : 抽象类</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> tt;</span><br><span class="line">	tt.<span class="built_in">test2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出和模板">输入输出和模板</h2><h3 id="输入输出相关类">输入输出相关类</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/680d99f758cb8da5c8cfdd30.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">【标准流对象】</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cin 标准输入 用于从键盘读取数据，也可以被 重定向 为从文件中读取数据</span></span><br><span class="line"><span class="comment">cout 标准输出 用于向屏幕输出数据，也可以被 重定向 为向文件写入数据</span></span><br><span class="line"><span class="comment">cerr/clog  用于向屏幕输出出错信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">重定向例子</span><br><span class="line">   【输出】</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); <span class="comment">//将标准输出 重定向 到test.txt文件</span></span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="comment">//除数为0则在屏幕上输出错误信息</span></span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;error.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;x/y; <span class="comment">//输出结果到test.txt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   【输入】</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">double</span> f; <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="comment">//将标准输入 cin被改为从test.txt中读取数据</span></span><br><span class="line">    cin&gt;&gt;f&gt;&gt;n;   </span><br><span class="line">    cout&lt;&lt;f&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="流操纵算子">流操纵算子</h3><blockquote><p>头文件 #include<iomanip></iomanip></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">整数流的基数:流操纵算子 dec（十进制） , oct（八进制） , hex（十六进制） , setbase（任意进制）</span><br><span class="line">浮点数的精度 （precision,setprecision）</span><br><span class="line">设置域宽 （setw,width）</span><br><span class="line">用户自定义的流操纵算子</span><br><span class="line">--------------------------------------------</span><br><span class="line">【整数流的基数-流操纵算子】 dec（十进制） , oct（八进制） , hex（十六进制）</span><br><span class="line"><span class="type">int</span> n =<span class="number">10</span>;</span><br><span class="line">cout &lt;&lt;n &lt;&lt;endl ;</span><br><span class="line">cout &lt;&lt;hex &lt;&lt;n&lt;&lt;<span class="string">&quot;\n&quot;</span></span><br><span class="line">	 &lt;&lt;dec &lt;&lt;n&lt;&lt;<span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt;oct &lt;&lt;n&lt;&lt;endl ;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">a</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">【浮点数的精度-流操纵算子】  precision,setprecision</span><br><span class="line">    </span><br><span class="line"> precision是成员函数，其调用方式为：</span><br><span class="line"> cout.<span class="built_in">precision</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"> setprecision是流操作算子，其调用方式为：</span><br><span class="line"> cout&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">5</span>);<span class="comment">//可以连续输出</span></span><br><span class="line"></span><br><span class="line"> 它们的功能相同</span><br><span class="line"> 指定输出浮点数的有效位数（非定点方式输出时)</span><br><span class="line"> 指定输出浮点数的小数点后的有效位数（定点方式输出时)</span><br><span class="line"> 定点方式:小数点必须出现在个位数后面</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="type">double</span> x=<span class="number">1234567.89</span>;</span><br><span class="line">      <span class="comment">// 有效数字6位，但x有9位，6 &lt; 9 , 非定点方式输出（数学计数法），如果有效数字大于x的位数，则用定点方式输出</span></span><br><span class="line">     cout&lt;&lt; <span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; x &lt;&lt; endl &lt;&lt;  </span><br><span class="line">      <span class="comment">// fixed 以小数点位置固定的方式输出，定点方式输出</span></span><br><span class="line">     fixed &lt;&lt; x &lt;&lt; endl &lt;&lt;</span><br><span class="line">      <span class="comment">// scientific 取消以小数点位置固定的方式输出，非定点方式输出（数学计数法）</span></span><br><span class="line">     scientific &lt;&lt; x &lt;&lt; endl;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">1.234457e+006</span></span><br><span class="line"><span class="number">1234567.890000</span></span><br><span class="line"><span class="number">1.234457e+006</span></span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"> 【设置域宽】 Setw , width   </span><br><span class="line">  两者功能相同，一个成员函数，另一个是流操作算子，调用方式不同：</span><br><span class="line">   cin&gt;&gt;<span class="built_in">setw</span>(<span class="number">4</span>);  或者 cin.<span class="built_in">width</span>(<span class="number">5</span>);</span><br><span class="line">   cout&lt;<span class="built_in">setw</span>(<span class="number">4</span>);  或者 cout.<span class="built_in">width</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   宽度设置有效性是一次性的，在每次读入和输出之前都要设置宽度</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> w = <span class="number">4</span>;</span><br><span class="line">   <span class="type">char</span> string[<span class="number">10</span>];</span><br><span class="line">   cin.<span class="built_in">width</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="keyword">while</span>(cin&gt;&gt;string)&#123;</span><br><span class="line">       cout.<span class="built_in">width</span>(w++);</span><br><span class="line">       cout&lt;&lt;stirng&lt;&lt;endl;</span><br><span class="line">       cin&gt;.<span class="built_in">width</span>(<span class="number">5</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> 输入：<span class="number">1234567890</span></span><br><span class="line"> 输出：</span><br><span class="line"> <span class="number">1234</span>    <span class="comment">//输入的宽为5，包括了 \n , 输出的宽为5</span></span><br><span class="line">  <span class="number">5678</span>   <span class="comment">//输入的宽为5，包括了 \n , 输出的宽为6，5&lt;6, 不够补1空格</span></span><br><span class="line">     <span class="number">90</span>  <span class="comment">//输入的宽为5，实际输入3，包括了 \n , 输出的宽为7，3&lt;7, 不够补4空格 </span></span><br><span class="line">     </span><br><span class="line">------------------------------------------------------------</span><br><span class="line">【快速回顾】</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">141</span>;</span><br><span class="line">	<span class="comment">//1) 分别以十六进制、十进制、八进制先后输出 n</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dec &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; oct &lt;&lt; n &lt;&lt; endl; <span class="type">double</span> x = <span class="number">1234567.89</span>, y = <span class="number">12.34567</span>;</span><br><span class="line">	<span class="comment">//2) 保留5位有效数字</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//3) 保留小数点后面5位</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//4) 科学计数法输出，且保留小数点后面5位</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4) &quot;</span> &lt;&lt; scientific &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//5) 非负数要显示正号，输出宽度为12字符，宽度不足则用&#x27;*&#x27;填补</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5) &quot;</span> &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; <span class="number">12.1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//6) 非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;6) &quot;</span> &lt;&lt; noshowpos &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; left &lt;&lt; <span class="number">12.1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//7) 输出宽度为12字符，宽度不足则左边用填充字符填充</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;7) &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; right &lt;&lt; <span class="number">12.1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//8) 宽度不足时，负号和数值分列左右，中间用填充字符填充</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;8) &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12.1</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;9) &quot;</span> &lt;&lt; <span class="number">12.1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">1</span>) <span class="number">8</span>d <span class="number">141</span> <span class="number">215</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1.2346e+06</span> <span class="number">12.346</span></span><br><span class="line"><span class="number">3</span>) <span class="number">1234567.89000</span> <span class="number">12.34567</span></span><br><span class="line"><span class="number">4</span>) <span class="number">1.23457e+06</span> <span class="number">1.23457e+01</span></span><br><span class="line"><span class="number">5</span>) ***+<span class="number">12.10000</span></span><br><span class="line"><span class="number">6</span>) <span class="number">12.10000</span>****</span><br><span class="line"><span class="number">7</span>) ****<span class="number">12.10000</span></span><br><span class="line"><span class="number">8</span>) -***<span class="number">12.10000</span></span><br><span class="line"><span class="number">9</span>) <span class="number">12.10000</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">-------------------------------------------------</span><br><span class="line">【用户自定义流操纵算子】</span><br><span class="line"> <span class="function">ostream &amp;<span class="title">tab</span><span class="params">(ostream &amp;output)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> output &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;aa&quot;</span>&lt;&lt;tab&lt;&lt;<span class="string">&quot;bb&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">输出: aa   bb</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="文件读写">文件读写</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/680d99f758cb8da5c8cfdd30.png" alt=""></p><blockquote><p>头文件 #include<fstream></fstream></p></blockquote><h4 id="创建文件">创建文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;t.dat&quot;</span>,ios::out|ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">ios::out    文件撕打开方式</span><br><span class="line">    ios::out   输出到文件，删除原有内容</span><br><span class="line">    ios::app   输出到文件，保留原有内容，总是在尾部添加</span><br><span class="line">    ios::ate （at end）文件打开后定位到文件末尾</span><br><span class="line">    ios::in 打开文件用于读取</span><br><span class="line">ios::binary	 以二进制文件格式打开文件</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">方式二：</span><br><span class="line">也可以先创建ofstream对象，再用open函数打开</span><br><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">&quot;test.out&quot;</span>,ios::out|ios::binary);</span><br><span class="line"></span><br><span class="line">判断打开是否成功： </span><br><span class="line"><span class="keyword">if</span>(!fout)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;File open error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件的读写指针">文件的读写指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【写】</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;a1.out&quot;</span>,ios::app)</span></span>; <span class="comment">//以添加方式打开</span></span><br><span class="line"><span class="type">long</span> location = fout.<span class="built_in">tellp</span>(); <span class="comment">//取得写指针的位置</span></span><br><span class="line">location = <span class="number">10</span>;		<span class="comment">//location 可以为负值</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location); 		<span class="comment">// 将写指针移动到第10个字节处</span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location,ios::beg); <span class="comment">//从头数location </span></span><br><span class="line">fout.<span class="built_in">seekp</span>(location,ios::cur); <span class="comment">//从当前位置数</span></span><br><span class="line">location fout.<span class="built_in">seekp</span>(location,ios::end); <span class="comment">//从尾部数location</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------</span><br><span class="line">【读】    </span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(“a1.in”,ios::ate)</span></span>; </span><br><span class="line"><span class="comment">//打开文件，定位文件指针到文件尾</span></span><br><span class="line"><span class="type">long</span> location = fin.<span class="built_in">tellg</span>(); <span class="comment">//取得读指针的位置</span></span><br><span class="line">location = <span class="number">10L</span>;    <span class="comment">//location 可以为负值</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(location); <span class="comment">// 将读指针移动到第10个字节处</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(location,ios::beg); <span class="comment">//从头数location </span></span><br><span class="line">fin.<span class="built_in">seekg</span>(location,ios::cur); <span class="comment">//从当前位置数location </span></span><br><span class="line">fin.<span class="built_in">seekg</span>(location,ios::end); <span class="comment">//从尾部数location</span></span><br></pre></td></tr></table></figure><h4 id="字符-文本文件读写">字符/文本文件读写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">写一个程序，将文件 in.txt 里面的整数排序后，输出到out.txt</span><br><span class="line">例如，若in.txt 的内容为：</span><br><span class="line"><span class="number">1</span> <span class="number">234</span> <span class="number">9</span> <span class="number">45</span> <span class="number">6</span> <span class="number">879</span></span><br><span class="line">则执行本程序后，生成的out.txt的内容为：</span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">9</span> <span class="number">45</span> <span class="number">234</span> <span class="number">879</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;   <span class="comment">//数组容器</span></span><br><span class="line"><span class="function">ifstream <span class="title">srcFile</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>,ios::in)</span></span>; <span class="comment">//以读取方式打开 in.txt </span></span><br><span class="line"><span class="function">ofstream <span class="title">destFile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>,ios::out)</span></span>; <span class="comment">//以写入方式打开 out.txt</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">while</span>( srcFile &gt;&gt; x ) </span><br><span class="line">	v.<span class="built_in">push_back</span>(x);  <span class="comment">//数组添加函数</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>();i ++ )</span><br><span class="line">	destFile &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">destFile.<span class="built_in">close</span>();   <span class="comment">//关闭 out.txt 文件</span></span><br><span class="line">srcFile.<span class="built_in">close</span>();    <span class="comment">//关闭 in.txt 文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二进制文件读写">二进制文件读写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">ifstream 和 fstream的成员函数</span><br><span class="line">  读  <span class="built_in">read</span>(<span class="type">char</span>* s,<span class="type">long</span> n);</span><br><span class="line">	</span><br><span class="line">  写	 <span class="built_in">write</span>(<span class="type">const</span> <span class="type">char</span>* s,<span class="type">long</span> n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在文件中写入和读取一个整数</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;some.dat&quot;</span>, ios::out | ios::binary)</span></span>; <span class="comment">//二进制流写入的方式打开</span></span><br><span class="line">    <span class="type">int</span> x=<span class="number">120</span>;</span><br><span class="line">    fout.<span class="built_in">write</span>( (<span class="type">const</span> <span class="type">char</span> *)(&amp;x), <span class="built_in">sizeof</span>(<span class="type">int</span>) );   <span class="comment">//写入</span></span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;some.dat&quot;</span>,ios::in | ios::binary)</span></span>;  <span class="comment">//二进制流读取的方式打开</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    fin.<span class="built_in">read</span>((<span class="type">char</span> * ) &amp; y,<span class="built_in">sizeof</span>(<span class="type">int</span>));		<span class="comment">//读取</span></span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; y &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line">从键盘输入几个学生的姓名的成绩，并以二进制文件形式保存</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">       <span class="type">char</span> name[<span class="number">20</span>]; </span><br><span class="line">       <span class="type">int</span> score;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    <span class="function">ofstream <span class="title">OutFile</span><span class="params">( <span class="string">&quot;c:\\tmp\\students.dat&quot;</span>,ios::out|ios::binary)</span></span>;   <span class="comment">//二进制流写入的方式打开</span></span><br><span class="line">    <span class="keyword">while</span>( cin &gt;&gt; s.name &gt;&gt; s.score ) </span><br><span class="line">    OutFile.<span class="built_in">write</span>( (<span class="type">char</span> * ) &amp; s, <span class="built_in">sizeof</span>( s) );    <span class="comment">//写入</span></span><br><span class="line">    OutFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">    Tom <span class="number">60</span> </span><br><span class="line">    Jack <span class="number">80</span> </span><br><span class="line">    Jane <span class="number">40</span></span><br><span class="line">    则形成的 students.dat 为 <span class="number">72</span>字节</span><br><span class="line">----------------------------------------------------</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">     <span class="type">char</span> name[<span class="number">20</span>]; </span><br><span class="line">     <span class="type">int</span> score;</span><br><span class="line">  &#125;;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">	<span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>,ios::in | ios::binary )</span></span>;   </span><br><span class="line">    <span class="keyword">if</span>(!inFile) &#123;		<span class="comment">//文件打开是否成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="keyword">while</span>( inFile.<span class="built_in">read</span>( (<span class="type">char</span>* ) &amp; s, <span class="built_in">sizeof</span>(s) ) ) &#123;   <span class="comment">//读到文件尾 </span></span><br><span class="line">        <span class="type">int</span> readedBytes = inFile.<span class="built_in">gcount</span>(); <span class="comment">//看刚才读了多少字节</span></span><br><span class="line">        cout &lt;&lt; s.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.score &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        inFile.<span class="built_in">close</span>(); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line">将students.dat文件的Jane的名字改成Mike</span><br><span class="line">	Tom <span class="number">60</span> </span><br><span class="line">    Jack <span class="number">80</span> </span><br><span class="line">    Jane <span class="number">40</span></span><br><span class="line">    则形成的 students.dat 为 <span class="number">72</span>字节</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">     <span class="type">char</span> name[<span class="number">20</span>]; </span><br><span class="line">     <span class="type">int</span> score;</span><br><span class="line">     &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    <span class="function">fstream <span class="title">iofile</span><span class="params">( <span class="string">&quot;c:\\tmp\\students.dat&quot;</span>, ios::in|ios::out|ios::binary)</span></span>;  <span class="comment">//fstream 可读可写  </span></span><br><span class="line">    <span class="keyword">if</span>( !iofile) &#123;  <span class="comment">//文件打开是否成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    iofile.<span class="built_in">seekp</span>( <span class="number">2</span> * <span class="built_in">sizeof</span>(s),ios::beg);  <span class="comment">//定位写指针到第三个记录（Jane下标位置）</span></span><br><span class="line">    iofile.<span class="built_in">write</span>(<span class="string">&quot;Mike&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;Mike&quot;</span>)+<span class="number">1</span>);   <span class="comment">//重写Mike，需要多一个位置\0</span></span><br><span class="line">    iofile.<span class="built_in">seekg</span>(<span class="number">0</span>,ios::beg); <span class="comment">//定位读指针到开头</span></span><br><span class="line">    <span class="keyword">while</span>( iofile.<span class="built_in">read</span>( (<span class="type">char</span>* ) &amp; s, <span class="built_in">sizeof</span>(s)) ) </span><br><span class="line">    cout &lt;&lt; s.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.score &lt;&lt; endl; </span><br><span class="line">    iofile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    输出：</span><br><span class="line">      Tom <span class="number">60</span> </span><br><span class="line">      Jack <span class="number">80</span> </span><br><span class="line">      Mike <span class="number">40</span></span><br></pre></td></tr></table></figure><h3 id="函数模板">函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> 类型参数<span class="number">1</span>,<span class="keyword">class</span> 类型参数<span class="number">2</span>，...&gt;</span><br><span class="line">返回值类型 模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;;</span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp; X,T &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp  =x ;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.imgdb.cn/item/680d99f758cb8da5c8cfdd31.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">【求数组最大元素】    通过参数实例化函数模板 </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxElement</span><span class="params">(T a[],<span class="type">int</span> size)</span> <span class="comment">//size是数组元素个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tepMax = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;size;++i)</span><br><span class="line">        <span class="keyword">if</span>(tmpMax &lt; a[i])</span><br><span class="line">            tepMax = a[i];</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">MaxElement</span>(a[],<span class="number">10</span>);   <span class="comment">// 通过参数实例化函数模板</span></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">不通过参数实例化函数模板  </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">inc</span><span class="params">(T n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cout&lt;&lt; <span class="built_in">inc</span>&lt;<span class="type">double</span>&gt;(<span class="number">4</span>)/<span class="number">2</span>;   <span class="comment">//不通过参数实例化函数模板  double代替T -&gt;  double inc(double n)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//输出 2.5   </span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">函数模板可以重载，只要它们的 形参表 或 类型参数表 不同即可</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;   <span class="comment">//类型参数表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T1 arg1, T2 arg2)</span> </span>&#123; <span class="comment">//形参表</span></span><br><span class="line">	cout&lt;&lt; arg1 &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; arg2&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;			<span class="comment">//类型参数表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg1, T arg2)</span> </span>&#123;  <span class="comment">//形参表</span></span><br><span class="line">	cout&lt;&lt; arg1 &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; arg2&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;	 <span class="comment">//类型参数表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg1, T arg2)</span> </span>&#123;  <span class="comment">//形参表</span></span><br><span class="line">	cout&lt;&lt; arg1 &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; arg2&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">有多个函数和函数模板名字相同的情况下</span><br><span class="line"><span class="number">1</span>)	先找参数完全匹配的普通函数(非由模板实例化而得的函数)。</span><br><span class="line"><span class="number">2</span>)	再找参数完全匹配的模板函数。</span><br><span class="line"><span class="number">3</span>)	再找实参数经过自动类型转换后能够匹配的普通函数。</span><br><span class="line"><span class="number">4</span>)	上面的都找不到，则报错。 </span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 函数模板示例：Map</span><br><span class="line"> 将某个区间的数，通过某种方法后，用另一个数组写入</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Pred&gt; </span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">Map</span><span class="params">(T s, T e, T x, Pred op)</span></span>&#123; <span class="comment">// s:区间起始位置   e:区间终止位置  x:数组起始位置  op:方法(函数)</span></span><br><span class="line">      <span class="keyword">for</span>(; s != e; ++s,++x)&#123;</span><br><span class="line">          *x = <span class="built_in">op</span>(*s);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Cube</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x * x; &#125; 	    <span class="comment">//方法函数：立方</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;   <span class="comment">//方法函数：平方</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, b[<span class="number">5</span>];</span><br><span class="line">    <span class="type">double</span> d[<span class="number">5</span>] = &#123; <span class="number">1.1</span>,<span class="number">2.1</span>,<span class="number">3.1</span>,<span class="number">4.1</span>,<span class="number">5.1</span>&#125; , c[<span class="number">5</span>]; </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="built_in">Map</span>(a,a+<span class="number">5</span>,b,Square);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">5</span>; ++i) cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Map</span>(a,a+<span class="number">5</span>,b,Cube);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">5</span>; ++i) cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Map</span>(d,d+<span class="number">5</span>,c,Square);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; <span class="number">5</span>; ++i) cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="类模板">类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> 类型参数<span class="number">1</span>,<span class="keyword">class</span> 类型参数<span class="number">2</span>，...&gt;  <span class="comment">//类型参数表</span></span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">   成员函数和成员变量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板成员函数的写法：</span></span><br><span class="line">返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用类模板定义对象的写法：</span></span><br><span class="line">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实参表);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">类模板示例： Pair类模板</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 key;  <span class="comment">//关键字</span></span><br><span class="line">	T2 value;     <span class="comment">//值</span></span><br><span class="line">	<span class="built_in">Pair</span>(T1 k,T2 v):<span class="built_in">key</span>(k),<span class="built_in">value</span>(v) &#123; &#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; ( <span class="type">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="type">const</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="type">bool</span> Pair&lt;T1,T2&gt;::<span class="keyword">operator</span> &lt; ( <span class="type">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="type">const</span> </span><br><span class="line"><span class="comment">//Pair的成员函数 operator</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> key &lt; p.key;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Pair&lt;string,<span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">19</span>)</span></span>; </span><br><span class="line">	<span class="comment">//实例化出一个类 Pair&lt;string,int&gt;</span></span><br><span class="line">	cout &lt;&lt; student.key &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; student.value; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">函数模版作为类模板成员</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T2&gt;  </span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">Func</span><span class="params">( T2 t)</span> </span>&#123; cout &lt;&lt; t; &#125; <span class="comment">//成员函数模板</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	a.<span class="built_in">Func</span>(<span class="string">&#x27;K&#x27;</span>); <span class="comment">//成员函数模板 Func被实例化</span></span><br><span class="line">	a.<span class="built_in">Func</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//成员函数模板 Func再次被实例化</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">输出：KHello</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">类模板与非类型参数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CArray</span>&#123;</span><br><span class="line">    T  array[size]; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>;i &lt; size; ++i)</span><br><span class="line">            cout &lt;&lt; array[i] &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CArray&lt;<span class="type">double</span>,<span class="number">40</span>&gt; a2; </span><br><span class="line">CArray&lt;<span class="type">int</span>,<span class="number">50</span>&gt; a3; </span><br></pre></td></tr></table></figure><h4 id="类模板与派生-友元-静态成员变量">类模板与派生/友元/静态成员变量</h4><p><a href="8_%E6%A8%A1%E6%9D%BF.pdf">8_模板.pdf</a></p><h2 id="标准模板库STL">标准模板库STL</h2><h3 id="String类">String类</h3><blockquote><p>头文件<string></string></p></blockquote><h4 id="常见构造">常见构造</h4><table><thead><tr><th>函数名称</th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td><code>string()</code></td><td>构造空的string类对象，即空字符串</td></tr><tr><td><code>string(const char* s)</code></td><td>用C风格字符串string来构造string类对象</td></tr><tr><td><code>string(size_t n, char c)</code></td><td>string类对象中包含n个字符c</td></tr><tr><td><code>string(const string&amp;s)</code></td><td>拷贝构造函数</td></tr><tr><td><code>string(const string&amp;s, size_t n)</code></td><td>用s中的前n个字符构造新的string类对象</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestString</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s1; 				<span class="comment">// 构造空的string类对象s1</span></span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;giturtle&quot;</span>)</span></span>; 	<span class="comment">// 用C格式字符串构造string类对象s2</span></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;	    <span class="comment">// 用10个字符&#x27;a&#x27;构造string类对象s3</span></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(s2)</span></span>; 			<span class="comment">// 拷贝构造s4</span></span><br><span class="line">	<span class="function">string <span class="title">s5</span><span class="params">(s3, <span class="number">5</span>)</span></span>; 		<span class="comment">// 用s3中第5个字符起、字符串结尾止的字符串构造string对象s5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容量操作"><strong>容量操作</strong></h4><table><thead><tr><th><strong>函数名称</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td><strong>size</strong> （重点）</td><td><strong>返回字符串有效字符长度</strong></td></tr><tr><td><strong>length</strong></td><td><strong>返回字符串有效字符长度</strong></td></tr><tr><td><strong>empty</strong> （重点）</td><td><strong>检测字符串释放为空串，是返回<strong><strong>true</strong></strong>，否则返回****false</strong></td></tr><tr><td><strong>clear</strong> （重点）</td><td><strong>清空有效字符</strong></td></tr><tr><td><strong>reserve</strong> （重点）</td><td><strong>为字符串预留空间</strong></td></tr><tr><td><strong>resize</strong> （重点）</td><td><strong>将有效字符的个数该成</strong> <strong>n</strong> <strong>个，多出的空间用字符</strong> <strong>c</strong> <strong>填充</strong></td></tr><tr><td><strong>capacity</strong></td><td><strong>返回空间总大小</strong></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试string容量相关的接口</span></span><br><span class="line"><span class="comment">// size/clear/resize</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teststring1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// string类对象支持直接用cin和cout进行输入和输出</span></span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello, world&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 将s中的字符串清空，注意清空时只是将size清0，不改变底层空间的大小</span></span><br><span class="line">	s.<span class="built_in">clear</span>();</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 将s中有效字符个数增加到10个，多出位置用&#x27;a&#x27;进行填充</span></span><br><span class="line">	<span class="comment">// “aaaaaaaaaa”</span></span><br><span class="line">	s.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 将s中有效字符个数增加到15个，多出位置用缺省值&#x27;\0&#x27;进行填充</span></span><br><span class="line">	<span class="comment">// &quot;aaaaaaaaaa\0\0\0\0\0&quot;</span></span><br><span class="line">	<span class="comment">// 注意此时s中有效字符个数已经增加到15个</span></span><br><span class="line">	s.<span class="built_in">resize</span>(<span class="number">15</span>);</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 将s中有效字符个数缩小到5个</span></span><br><span class="line">	s.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问及遍历操作"><strong>访问及遍历操作</strong></h4><table><thead><tr><th><strong>函数名称</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td><strong>operator[ ]</strong> （重点）</td><td><strong>返回</strong> <strong>pos</strong> <strong>位置的字符，</strong> <strong>const string</strong> <strong>类对象调用</strong></td></tr><tr><td><strong>begin</strong> + <strong>end</strong></td><td><strong>begin</strong> <strong>获取一个字符的迭代器</strong> + <strong>end</strong> <strong>获取最后一个字符下一个位置的迭代器</strong></td></tr><tr><td><strong>rbegin</strong> + <strong>rend</strong></td><td><strong>begin</strong> <strong>获取一个字符的迭代器</strong> + <strong>end</strong> <strong>获取最后一个字符下一个位置的迭</strong>代器****</td></tr><tr><td><strong>范围</strong> <strong>for</strong></td><td><strong>C++11</strong> <strong>支持更简洁的范围</strong> <strong>for</strong> <strong>的新遍历方式</strong></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string的遍历</span></span><br><span class="line"><span class="comment">// begin()+end()   for+[]  范围for</span></span><br><span class="line"><span class="comment">// 注意：string遍历时使用最多的还是for+下标 或者 范围for(C++11后才支持)</span></span><br><span class="line"><span class="comment">// begin()+end()大多数使用在需要使用STL提供的算法操作string时，比如：采用reverse逆置string</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teststring</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello string&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 3种遍历方式：</span></span><br><span class="line">	<span class="comment">// 需要注意的以下三种方式除了遍历string对象，还可以遍历是修改string中的字符，</span></span><br><span class="line">	<span class="comment">// 另外以下三种方式对于string而言，第一种使用最多</span></span><br><span class="line">	<span class="comment">// 1. for+operator[]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 2.迭代器</span></span><br><span class="line">	string::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// string::reverse_iterator rit = s.rbegin();</span></span><br><span class="line">	<span class="comment">// C++11之后，直接使用auto定义迭代器，让编译器推到迭代器的类型</span></span><br><span class="line">	<span class="keyword">auto</span> rit = s.<span class="built_in">rbegin</span>();</span><br><span class="line">	<span class="keyword">while</span> (rit != s.<span class="built_in">rend</span>())</span><br><span class="line">		cout &lt;&lt; *rit &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 3.范围for</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)</span><br><span class="line">		cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改操作">修改操作</h4><table><thead><tr><th><strong>函数名称</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td><strong>push_back</strong></td><td><strong>在字符串后尾插字符</strong> <strong>c</strong></td></tr><tr><td><strong>append</strong></td><td><strong>在字符串后追加一个字符串</strong></td></tr><tr><td><strong>operator+=</strong> ( 重点 )</td><td><strong>在字符串后追加字符串</strong> <strong>str</strong></td></tr><tr><td><strong>c_str</strong> ( 重点 )</td><td><strong>返回</strong> <strong>C</strong> <strong>格式字符串</strong></td></tr><tr><td><strong>find</strong> + <strong>npos</strong> ( 重点 )</td><td><strong>从字符串</strong> <strong>pos</strong> <strong>位置开始往后找字符</strong> <strong>c</strong> <strong>，返回该字符在字符串中的位置</strong></td></tr><tr><td><strong>rfind</strong></td><td><strong>从字符串</strong> <strong>pos</strong> <strong>位置开始往前找字符</strong> <strong>c</strong> <strong>，返回该字符在字符串中的位置</strong></td></tr><tr><td><strong>substr</strong></td><td><strong>在</strong> <strong>str</strong> <strong>中从</strong> <strong>pos</strong> <strong>位置开始，截取</strong> <strong>n</strong> <strong>个字符，然后将其返回</strong></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teststring5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	str.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);   <span class="comment">// 在str后插入空格</span></span><br><span class="line">	str.<span class="built_in">append</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 在str后追加一个字符&quot;hello&quot;</span></span><br><span class="line">	str += <span class="string">&#x27;wo&#x27;</span>;           <span class="comment">// 在str后追加一个字符&#x27;wo&#x27;   </span></span><br><span class="line">	str += <span class="string">&quot;rld&quot;</span>;          <span class="comment">// 在str后追加一个字符串&quot;rld&quot;</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;   <span class="comment">// 以C语言的方式打印字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用方法">常用方法</h4><p>[C++string类常用方法_c++ string类的常用方法-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40644809/article/details/108977918?ops_request_misc=%7B%22request%5Fid%22%3A%22171297534816800178590165%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171297534816800178590165&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-108977918-null-null.142%5Ev100%5Epc_search_result_base3&amp;utm_term=c%2B%2B">https://blog.csdn.net/qq_40644809/article/details/108977918?ops_request_misc={&quot;request_id&quot;%3A&quot;171297534816800178590165&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334.pc_all.&quot;}&amp;request_id=171297534816800178590165&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-108977918-null-null.142^v100^pc_search_result_base3&amp;utm_term=c%2B%2B</a> string&amp;spm=1018.2226.3001.4187)</p><p>[C++中的String的常用函数用法总结_string函数-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37941471/article/details/82107077?ops_request_misc=%7B%22request%5Fid%22%3A%22171297534816800178590165%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171297534816800178590165&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-11-82107077-null-null.142%5Ev100%5Epc_search_result_base3&amp;utm_term=c%2B%2B">https://blog.csdn.net/qq_37941471/article/details/82107077?ops_request_misc={&quot;request_id&quot;%3A&quot;171297534816800178590165&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334.pc_all.&quot;}&amp;request_id=171297534816800178590165&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-11-82107077-null-null.142^v100^pc_search_result_base3&amp;utm_term=c%2B%2B</a> string&amp;spm=1018.2226.3001.4187)</p><h3 id="标准模板库STL概述">标准模板库STL概述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器：可容纳各种数据类型的通用数据结构,是类模板</span><br><span class="line">迭代器：可用于依次存取容器中元素，类似于指针</span><br><span class="line">算法：用来操作容器中的元素的函数模板</span><br><span class="line">	<span class="built_in">sort</span>()来对一个 vector 中的数据进行排序</span><br><span class="line">	<span class="built_in">find</span>()来搜索一个list中的对象</span><br></pre></td></tr></table></figure><h4 id="容器">容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是类模版,分为三种：</span><br><span class="line"><span class="number">1</span>)顺序容器</span><br><span class="line">vector, deque,list</span><br><span class="line"><span class="number">2</span>)关联容器</span><br><span class="line">set, multiset, map, multimap </span><br><span class="line"><span class="number">3</span>)容器适配器</span><br><span class="line">stack, queue, priority_queue</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="comment">//顺序容器</span></span><br><span class="line">【vector】  </span><br><span class="line">头文件 &lt;vector&gt;</span><br><span class="line">动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能（大部分情况下是常数时间）。</span><br><span class="line">    </span><br><span class="line">【deque】</span><br><span class="line">头文件 &lt;deque&gt;    </span><br><span class="line">双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（但次于vector)。在两端增删元素具有较佳的性能(大部分情况下是常数时间）。</span><br><span class="line">                                                           </span><br><span class="line">【list】</span><br><span class="line">头文件 &lt;list&gt;</span><br><span class="line">双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</span><br><span class="line">                                                           </span><br><span class="line">-----------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关联容器      </span></span><br><span class="line">	元素是排序的</span><br><span class="line">	插入任何元素，都按相应的排序规则来确定其位置</span><br><span class="line">	在查找时具有非常好的性能</span><br><span class="line">	通常以平衡二叉树方式实现，插入和检索的时间都是 <span class="built_in">O</span>(<span class="built_in">log</span>(N))</span><br><span class="line"></span><br><span class="line">【set/multiset】</span><br><span class="line">头文件 &lt;set&gt;</span><br><span class="line">set 即集合。set中不允许相同元素，multiset 中允许存在相同的元素。</span><br><span class="line">                               </span><br><span class="line">multiset（mou t）</span><br><span class="line">                                                           </span><br><span class="line">【map/multimap】</span><br><span class="line">头文件 &lt;map&gt;</span><br><span class="line">map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。</span><br><span class="line">map同multimap的不同在于是否允许相同first值的元素。</span><br><span class="line">                                                           </span><br><span class="line">【stack】</span><br><span class="line">头文件 &lt;stack&gt;</span><br><span class="line">栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。<span class="string">&quot;后进先出&quot;</span>。</span><br><span class="line">                                                           </span><br><span class="line">                   出栈         入栈                                 </span><br><span class="line">    			   ↖	    ↗</span><br><span class="line">                       \    /                                    </span><br><span class="line">                    ___________</span><br><span class="line">         top——&gt;     |   an    |</span><br><span class="line">                    ———————————                                                       </span><br><span class="line">                    |   ...   |   </span><br><span class="line">                    ———————————                                          </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">      bottom——&gt;     |    a1   |   </span><br><span class="line">                    ———————————       </span><br><span class="line"></span><br><span class="line">【queue】</span><br><span class="line">头文件 &lt;queue&gt;</span><br><span class="line">队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。<span class="string">&quot;先进先出&quot;</span>。</span><br><span class="line">                                                           </span><br><span class="line">                    入队                                       </span><br><span class="line">    				\	    </span><br><span class="line">                       ↘                                      </span><br><span class="line">                    ___________</span><br><span class="line">         rear——&gt;    |   an    |</span><br><span class="line">                    ———————————                                                       </span><br><span class="line">                    |   ...   |   </span><br><span class="line">                    ———————————                                          </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">       front——&gt;     |    a1   |   </span><br><span class="line">                    ———————————  </span><br><span class="line">                         \</span><br><span class="line">                          ↘   </span><br><span class="line">                            出队                 </span><br><span class="line">                                                           </span><br><span class="line">                                                           </span><br><span class="line">【priority_queue】      </span><br><span class="line">头文件 &lt;queue&gt;</span><br><span class="line">优先级队列。最高优先级元素总是第一个出列</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="顺序容器和关联容器中都有的成员函数">顺序容器和关联容器中都有的成员函数</h5><table><thead><tr><th>begin</th><th>返回指向容器中第一个元素的迭代器</th></tr></thead><tbody><tr><td>end</td><td>返回指向容器中最后一个元素后面的位置的迭代器</td></tr><tr><td>rbegin</td><td>返回指向容器中最后一个元素的迭代器</td></tr><tr><td>rend</td><td>返回指向容器中第一个元素前面的位置的迭代器</td></tr><tr><td>erase</td><td>从容器中删除一个或几个元素</td></tr><tr><td>clear</td><td>从容器中删除所有元素</td></tr></tbody></table><h5 id="顺序容器的常用成员函数">顺序容器的常用成员函数</h5><table><thead><tr><th>front</th><th>返回容器中第一个元素的引用</th></tr></thead><tbody><tr><td>back</td><td>返回容器中最后一个元素的引用</td></tr><tr><td>push_back</td><td>在容器末尾增加新元素</td></tr><tr><td>pop_back</td><td>删除容器末尾的元素</td></tr><tr><td>erase</td><td>删除迭代器指向的元素(可能会使该迭代器失效），或删除一个区间，返回被删除元素后面的那个元素的迭代器</td></tr></tbody></table><h4 id="迭代器">迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	用于指向顺序容器和关联容器中的元素</span><br><span class="line">	迭代器用法和指针类似</span><br><span class="line">	有<span class="type">const</span> 和非 <span class="type">const</span>两种</span><br><span class="line">	通过迭代器可以读取它指向的元素</span><br><span class="line">	通过非<span class="type">const</span>迭代器还能修改其指向的元素</span><br><span class="line">   </span><br><span class="line">定义一个容器类的迭代器的方法可以是：</span><br><span class="line"><span class="comment">// 容器类名::iterator   变量名;</span></span><br><span class="line">或：</span><br><span class="line"><span class="comment">// 容器类名::const_iterator 变量名;</span></span><br><span class="line">访问一个迭代器指向的元素：</span><br><span class="line"><span class="comment">// * 迭代器变量名</span></span><br><span class="line">    </span><br><span class="line">iterator（一特端特） </span><br><span class="line">-----------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//一个存放int元素的数组，一开始里面没有元素</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);  v.<span class="built_in">push_back</span>(<span class="number">2</span>);   v.<span class="built_in">push_back</span>(<span class="number">3</span>);  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator i;  <span class="comment">//常量迭代器</span></span><br><span class="line">    <span class="keyword">for</span>( i = v.<span class="built_in">begin</span>();i != v.<span class="built_in">end</span>();++i ) <span class="comment">//（v.end() 指向数组v未尾数的后面的一个位置）</span></span><br><span class="line">		cout &lt;&lt; * i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::reverse_iterator r;   <span class="comment">//反向迭代器</span></span><br><span class="line">    <span class="keyword">for</span>( r = v.<span class="built_in">rbegin</span>();r != v.<span class="built_in">rend</span>();r++ )   <span class="comment">//从后往前走</span></span><br><span class="line">        cout &lt;&lt; * r &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    cout  &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator j;  <span class="comment">//非常量迭代器</span></span><br><span class="line">    <span class="keyword">for</span>( j = v.<span class="built_in">begin</span>();j != v.<span class="built_in">end</span>();j ++ ) </span><br><span class="line">        * j =  <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>( i = v.<span class="built_in">begin</span>();i != v.<span class="built_in">end</span>();i++ ) </span><br><span class="line">        cout &lt;&lt; * i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;双向迭代器&#x27;</span></span><br><span class="line">若p和p1都是双向迭代器，则可对p、p1可进行以下操作：</span><br><span class="line">++p, p++             使p指向容器中下一个元素</span><br><span class="line">--p, p--             使p指向容器中上一个元素</span><br><span class="line">* p  		        取p指向的元素</span><br><span class="line">p = p1 		   		赋值</span><br><span class="line">p == p1 , p!= p1     判断是否相等、不等</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;随机访问迭代器&#x27;</span></span><br><span class="line">若p和p1都是随机访问迭代器，则可对p、p1可进行以下操作：</span><br><span class="line">	双向迭代器的所有操作</span><br><span class="line">	p += i 将p向后移动i个元素</span><br><span class="line">	p -= i 将p向向前移动i个元素</span><br><span class="line">	p + i 值为: 指向 p 后面的第i个元素的迭代器</span><br><span class="line">	p - i 值为: 指向 p 前面的第i个元素的迭代器</span><br><span class="line">	p[i] 值为: p后面的第i个元素的引用</span><br><span class="line">	p &lt; p1, p &lt;= p1, p &gt; p1, p&gt;= p1   		    <span class="comment">//p &lt; p1 : p所指向的元素在p1所指向的元素的前面</span></span><br><span class="line">	p – p1  : p1和p之间的元素个数</span><br><span class="line">     部分算法（例如：sort , binary_search ）</span><br></pre></td></tr></table></figure><table><thead><tr><th>容器</th><th>容器上的迭代器类别</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set/multiset</td><td>双向</td></tr><tr><td>map/multimap</td><td>双向</td></tr><tr><td></td><td></td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector的迭代器是随机迭代器，</span><br><span class="line">遍历 vector 可以有以下几种做法(deque亦然)：</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>() ; i ++)</span><br><span class="line">    cout &lt;&lt; v[i]; <span class="comment">//根据下标随机访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator ii;</span><br><span class="line"><span class="keyword">for</span>( ii = v.<span class="built_in">begin</span>(); ii != v.<span class="built_in">end</span> ();++ii)</span><br><span class="line">	cout &lt;&lt; * ii;</span><br><span class="line"><span class="keyword">for</span>( ii = v.<span class="built_in">begin</span>(); ii &lt; v.<span class="built_in">end</span> ();++ii )</span><br><span class="line">    cout &lt;&lt; * ii;</span><br><span class="line"></span><br><span class="line"><span class="comment">//间隔一个输出：</span></span><br><span class="line">ii = v.<span class="built_in">begin</span>(); <span class="keyword">while</span>( ii &lt; v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">	cout &lt;&lt; * ii;</span><br><span class="line">    ii = ii + <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">    </span><br><span class="line">list 的迭代器是双向迭代器，正确的遍历list的方法：</span><br><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator ii;</span><br><span class="line"><span class="keyword">for</span>( ii = v.<span class="built_in">begin</span>(); ii != v.<span class="built_in">end</span> ();++ii )</span><br><span class="line">    cout &lt;&lt; * ii;</span><br><span class="line"></span><br><span class="line">错误的做法：</span><br><span class="line">    <span class="keyword">for</span>( ii = v.<span class="built_in">begin</span>(); ii &lt; v.<span class="built_in">end</span> ();++ii )</span><br><span class="line">        	cout &lt;&lt; * ii;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//双向迭代器不支持 &lt;,list没有 [] 成员函数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>() ; i ++)</span><br><span class="line">        	cout &lt;&lt; v[i]; </span><br></pre></td></tr></table></figure><h4 id="算法">算法</h4><blockquote><p>头文件：<algorithm></algorithm></p></blockquote><h5 id="find">find()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InIt, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InIt <span class="title">find</span><span class="params">(InIt first, InIt last, <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"></span><br><span class="line">first 和 last 这两个参数都是容器的迭代器</span><br><span class="line">查找区间起点和终点[first,last)   <span class="comment">//first包含，last不包含</span></span><br><span class="line"><span class="string">&#x27;find在[first,last)查找等于val的元素&#x27;</span></span><br><span class="line">函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last</span><br><span class="line">          </span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;        </span><br><span class="line">    <span class="type">int</span> array[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator p;</span><br><span class="line">	p = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">3</span>); <span class="comment">//在容器里查找 3</span></span><br><span class="line">    <span class="keyword">if</span>( p != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; * p &lt;&lt; endl; <span class="comment">//输出3</span></span><br><span class="line">    p = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">9</span>); <span class="comment">//在容器里查找 9，不到等于p=last=4</span></span><br><span class="line">    <span class="keyword">if</span>( p == v.<span class="built_in">end</span>())    </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not found &quot;</span> &lt;&lt; endl;</span><br><span class="line">    p = <span class="built_in">find</span>(v.<span class="built_in">begin</span>()+<span class="number">1</span>,v.<span class="built_in">end</span>()<span class="number">-2</span>,<span class="number">1</span>); </span><br><span class="line">    <span class="comment">//整个容器：[1,2,3,4]， 查找区间：[2,3)</span></span><br><span class="line">    <span class="keyword">if</span>( p != v.<span class="built_in">end</span>()) 		</span><br><span class="line">        cout &lt;&lt; * p &lt;&lt; endl;   <span class="comment">//在容器里查找 9，不到等于p=last=3</span></span><br><span class="line">    <span class="type">int</span> * pp = <span class="built_in">find</span>( array,array+<span class="number">4</span>,<span class="number">20</span>);<span class="comment">//数组名是迭代器</span></span><br><span class="line">    cout &lt;&lt; * pp &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="相等">相等</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  &#123;</span><br><span class="line">    <span class="type">int</span> v; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">v</span>(n) &#123; &#125;</span><br><span class="line">    	<span class="type">bool</span> <span class="keyword">operator</span> &lt; ( <span class="type">const</span> A &amp; a2) <span class="type">const</span> &#123;  <span class="comment">//重载 &lt; 运算符，</span></span><br><span class="line">            <span class="comment">//必须为常量成员函数</span></span><br><span class="line">		   cout &lt;&lt; v &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; a2.v &lt;&lt; <span class="string">&quot;?&quot;</span> &lt;&lt; endl; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> A &amp; a2) <span class="type">const</span> &#123;</span><br><span class="line">            cout &lt;&lt; v &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; a2.v &lt;&lt; <span class="string">&quot;?&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> v == a2.v;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">   	 A a [] = &#123; <span class="built_in">A</span>(<span class="number">1</span>),<span class="built_in">A</span>(<span class="number">2</span>),<span class="built_in">A</span>(<span class="number">3</span>),<span class="built_in">A</span>(<span class="number">4</span>),<span class="built_in">A</span>(<span class="number">5</span>) &#125;;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">binary_search</span>(a,a+<span class="number">4</span>,<span class="built_in">A</span>(<span class="number">9</span>));       <span class="comment">//折半查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">3</span>&lt;<span class="number">9</span>?</span><br><span class="line"><span class="number">2</span>&lt;<span class="number">9</span>?</span><br><span class="line"><span class="number">1</span>&lt;<span class="number">9</span>?</span><br><span class="line"><span class="number">9</span>&lt;<span class="number">1</span>?</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="vector-deque-和-list">vector / deque 和 list</h3><h4 id="vector">vector</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">【vector】  </span><br><span class="line">头文件 &lt;vector&gt;</span><br><span class="line">动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能（大部分情况下是常数时间）。                                                                                                </span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">( T s, T e)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>(; s != e; ++s)</span><br><span class="line">		cout &lt;&lt; * s &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(a,a+<span class="number">5</span>)</span></span>; <span class="comment">//将数组a的内容放入v</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; v.<span class="built_in">end</span>() - v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//两个随机迭代器可以相减，输出 1) 5</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;2) &quot;</span>; <span class="built_in">PrintVector</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()); </span><br><span class="line">    <span class="comment">//2) 1 2 3 4 5</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">13</span>); <span class="comment">//在begin()+2位置插入 13</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;3) &quot;</span>; <span class="built_in">PrintVector</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()); </span><br><span class="line">    <span class="comment">//3) 1 2 13 3 4 5</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">//删除位于 begin() + 2的元素</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;4) &quot;</span>; <span class="built_in">PrintVector</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()); </span><br><span class="line">    <span class="comment">//4) 1 2 3 4 5</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">v2</span><span class="params">(<span class="number">4</span>,<span class="number">100</span>)</span></span>;  <span class="comment">//v2 有4个元素，都是100</span></span><br><span class="line">    v2.<span class="built_in">insert</span>(v2.<span class="built_in">begin</span>(),v.<span class="built_in">begin</span>()+ <span class="number">1</span>,v.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//在v2插入v的一个区间</span></span><br><span class="line">	<span class="comment">//将v的一段插入v2开头</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5) v2: &quot;</span>; <span class="built_in">PrintVector</span>(v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>()); </span><br><span class="line">    <span class="comment">//5) v2: 2 3 100 100 100</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">	<span class="comment">//删除 v 上的一个区间,即 2,3</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;6) &quot;</span>; <span class="built_in">PrintVector</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()); </span><br><span class="line">    <span class="comment">//6) 1 4 5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">                                                           </span><br><span class="line">------------------------------------------------------</span><br><span class="line">【vector实现二维数组】</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">v</span>(<span class="number">3</span>);    </span><br><span class="line">	<span class="comment">//v有3个元素，每个元素都是vector&lt;int&gt; 容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            cout &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出结果：</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="deque">deque</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【deque】</span><br><span class="line">头文件 &lt;deque&gt;    </span><br><span class="line">双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（但次于vector)。在两端增删元素具有较佳的性能(大部分情况下是常数时间）。</span><br><span class="line"></span><br><span class="line">所有适用于 vector的操作都适用于 deque。</span><br><span class="line">deque还有 push_front（将元素插入到前面） 和<span class="built_in">pop_front</span>(删除最前面的元素）操作，复杂度是<span class="built_in">O</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="list">list</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">【list】</span><br><span class="line">头文件 &lt;list&gt;</span><br><span class="line">双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</span><br><span class="line">除了具有所有顺序容器都有的成员函数以外，还支持<span class="number">8</span>个成员函数：</span><br><span class="line">push_front:  在前面插入</span><br><span class="line">pop_front:   删除前面的元素</span><br><span class="line">sort:    排序 (list 不支持 STL 的算法 sort)</span><br><span class="line">remove:  删除和指定值相等的所有元素</span><br><span class="line">unique:  删除所有和前一个元素相同的元素(要做到元素不重复，则unique之前还需要 sort)</span><br><span class="line">merge:   合并两个链表，并清空被合并的那个</span><br><span class="line">reverse: 颠倒链表</span><br><span class="line">splice:  在指定位置前面插入另一链表中的一个或多个元素,并在另一链表中删除被插入的元素</span><br><span class="line">    </span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> n; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>( <span class="type">int</span> n_ ) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;( <span class="type">const</span> A &amp; a1, <span class="type">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==( <span class="type">const</span> A &amp; a1, <span class="type">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="type">const</span> A &amp; a);</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;( <span class="type">const</span> A &amp; a1, <span class="type">const</span> A &amp; a2) &#123;</span><br><span class="line">	<span class="keyword">return</span> a1.n &lt; a2.n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==( <span class="type">const</span> A &amp; a1, <span class="type">const</span> A &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1.n == a2.n; &#125;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt;(ostream &amp; o, <span class="type">const</span> A &amp; a)&#123;</span><br><span class="line">    o&lt;&lt; a.n;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;T&gt; &amp; lst)</span> </span>&#123;</span><br><span class="line"><span class="comment">//不推荐的写法，还是用两个迭代器作为参数更好</span></span><br><span class="line">    <span class="type">int</span> tmp = lst.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>( tmp &gt; <span class="number">0</span>  ) &#123;</span><br><span class="line">        <span class="keyword">typename</span> list&lt;T&gt;::const_iterator i; </span><br><span class="line">		i = lst.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">for</span>( i = lst.<span class="built_in">begin</span>();i != lst.<span class="built_in">end</span>(); i ++)</span><br><span class="line">            cout &lt;&lt; * i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;<span class="comment">// typename用来说明 list&lt;T&gt;::const_iterator是个类型 </span></span><br><span class="line"><span class="comment">//在vs中不写也可以</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	list&lt;A&gt; lst1,lst2;</span><br><span class="line">    lst1.<span class="built_in">push_back</span>(<span class="number">1</span>);lst1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    lst1.<span class="built_in">push_back</span>(<span class="number">2</span>);lst1.<span class="built_in">push_back</span>(<span class="number">4</span>);  </span><br><span class="line">    lst1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	lst2.<span class="built_in">push_back</span>(<span class="number">10</span>);lst2.<span class="built_in">push_front</span>(<span class="number">20</span>);</span><br><span class="line">    lst2.<span class="built_in">push_back</span>(<span class="number">30</span>);lst2.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    lst2.<span class="built_in">push_back</span>(<span class="number">30</span>);lst2.<span class="built_in">push_front</span>(<span class="number">40</span>); </span><br><span class="line">    lst2.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1) &quot;</span>; <span class="built_in">PrintList</span>( lst1); cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 1) 1,3,2,4,2,</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2) &quot;</span>; <span class="built_in">PrintList</span>( lst2); cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 2) 40,20,10,30,30,30,40,</span></span><br><span class="line">    lst2.<span class="built_in">sort</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;3) &quot;</span>; <span class="built_in">PrintList</span>( lst2); cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//3) 10,20,30,30,30,40,40,</span></span><br><span class="line">    lst2.<span class="built_in">pop_front</span>(); </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;4) &quot;</span>; <span class="built_in">PrintList</span>( lst2); cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//4) 20,30,30,30,40,40,</span></span><br><span class="line">    lst1.<span class="built_in">remove</span>(<span class="number">2</span>); <span class="comment">//删除所有和A(2)相等的元素</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;5) &quot;</span>; <span class="built_in">PrintList</span>( lst1); cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//5) 1,3,4,</span></span><br><span class="line">    lst2.<span class="built_in">unique</span>(); <span class="comment">//删除所有和前一个元素相等的元素</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;6) &quot;</span>; <span class="built_in">PrintList</span>( lst2); cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//6) 20,30,40,</span></span><br><span class="line">    lst2.<span class="built_in">push_back</span> (<span class="number">100</span>);lst2.<span class="built_in">push_back</span> (<span class="number">200</span>); </span><br><span class="line">    lst2.<span class="built_in">push_back</span> (<span class="number">300</span>);lst2.<span class="built_in">push_back</span> (<span class="number">400</span>);</span><br><span class="line">    list&lt;A&gt;::iterator p1,p2,p3;</span><br><span class="line">    p1 = <span class="built_in">find</span>(lst1.<span class="built_in">begin</span>(),lst1.<span class="built_in">end</span>(),<span class="number">3</span>);</span><br><span class="line">    p2 = <span class="built_in">find</span>(lst2.<span class="built_in">begin</span>(),lst2.<span class="built_in">end</span>(),<span class="number">200</span>);</span><br><span class="line">    p3 =  <span class="built_in">find</span>(lst2.<span class="built_in">begin</span>(),lst2.<span class="built_in">end</span>(),<span class="number">400</span>);</span><br><span class="line">    lst1.<span class="built_in">splice</span>(p1,lst2,p2, p3);  </span><br><span class="line">	<span class="comment">//将[p2,p3)插入p1之前，并从lst2中删除[p2,p3)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;10) &quot;</span>; <span class="built_in">PrintList</span>( lst1); cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//10) 40,30,20,4,200,300,3,1,</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;11) &quot;</span>; <span class="built_in">PrintList</span>( lst2); cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//11) 100,400, </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数对象">函数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">是个对象，但是用起来看上去像函数调用，实际上也执行了函数调用。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyAverage</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3 )</span> </span>&#123; </span><br><span class="line">	<span class="comment">//重载 () 运算符</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(a1 + a2+a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CMyAverage average;  <span class="comment">//函数对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">average</span>(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// average.operator()(3,2,3) 用起来看上去像函数调用 输出 2.66667</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyLess</span></span><br><span class="line">&#123;   </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a1,<span class="type">int</span> a2)</span></span>&#123;   <span class="comment">//个位数大的大</span></span><br><span class="line">         <span class="keyword">if</span>( ( a1 % <span class="number">10</span> ) &lt; (a2%<span class="number">10</span>) )   </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(<span class="type">int</span> a1,<span class="type">int</span> a2)</span></span>&#123;		 <span class="comment">//个位数大的小</span></span><br><span class="line">    <span class="keyword">if</span>( ( a1 % <span class="number">10</span> ) &lt; (a2%<span class="number">10</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">35</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">19</span>,<span class="number">12</span>&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">MyMax</span>(a,<span class="number">5</span>,<span class="built_in">MyLess</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyMax</span>(a,<span class="number">5</span>,MyCompare) &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br><span class="line">输出:</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> 【写出 MyMax模板】</span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Pred</span>&gt;</span><br><span class="line">     <span class="function">T <span class="title">MyMax</span><span class="params">( T * p, <span class="type">int</span> n, Pred myless)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     T tmpmax = p[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++ )</span><br><span class="line">         <span class="keyword">if</span>( <span class="built_in">myless</span>(tmpmax,p[i]))</span><br><span class="line">             tmpmax = p[i]; </span><br><span class="line">     <span class="keyword">return</span> tmpmax;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关联容器">关联容器</h3><blockquote><p><b>关联容器适合用于不断更新容器，不断查询容器</b></p></blockquote><h4 id="set和multiset">set和multiset</h4><blockquote><p>头文件<set></set></p></blockquote><table><thead><tr><th>multiset的成员函数</th><th></th></tr></thead><tbody><tr><td>iterator find(const T &amp; val);</td><td>在容器中查找值为val的元素，返回其迭代器。如果找不到，返回end()。</td></tr><tr><td>iterator insert(const T &amp; val);</td><td>将val插入到容器中并返回其迭代器。</td></tr><tr><td>void insert( iterator first,iterator last);</td><td>将区间[first,last)插入容器。</td></tr><tr><td>int count(const T &amp; val);</td><td>统计有多少个元素的值和val相等。</td></tr><tr><td>iterator lower_bound(const T &amp; val);</td><td>查找一个最大的位置 it,使得[begin(),it) 中所有的元素都比 val 小。</td></tr><tr><td>iterator upper_bound(const T &amp; val);</td><td>查找一个最小的位置 it,使得[it,end()) 中所有的元素都比 val 大。</td></tr><tr><td>pair&lt;iterator,iterator&gt; equal_range(const T &amp; val);</td><td>同时求得lower_bound和upper_bound。</td></tr><tr><td>iterator erase(iterator it);</td><td>删除it指向的元素，返回其后面的元素的迭代器(Visual studio 2010上如此，但是在C++标准和Dev C++中，返回值不是这样)。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;multiset的用法</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">#include &lt;set&gt;</span></span><br><span class="line"><span class="string">using namespace std; class A &#123;  &#125;;</span></span><br><span class="line"><span class="string">int main()  &#123;</span></span><br><span class="line"><span class="string">    multiset&lt;A&gt; a;   //就等价于  multiset&lt;A, less&lt;A&gt;&gt; a;</span></span><br><span class="line"><span class="string">    a.insert( A());  //错误</span></span><br><span class="line"><span class="string">    //插入元素时，multiset会将被插入元素和已有元素进行比较。</span></span><br><span class="line"><span class="string">	//由于less模板是用 &lt; 进行比较的，所以,这都要求 A 的对象能用 &lt; 比较，即适当重载了 &lt; </span></span><br><span class="line"><span class="string">    //没有 &lt; 运算符的重载函数</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--------------------------------------------</span></span><br><span class="line"><span class="string">//multiset用法示例</span></span><br><span class="line"><span class="string">template &lt;class T&gt;</span></span><br><span class="line"><span class="string">void Print(T first, T last)   </span></span><br><span class="line"><span class="string">&#123;    for(;first != last ; ++first) cout &lt;&lt; * first &lt;&lt; &quot; &quot;;  </span></span><br><span class="line"><span class="string">cout &lt;&lt; endl; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class A    &#123;</span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string"> 	int n; </span></span><br><span class="line"><span class="string"> public:</span></span><br><span class="line"><span class="string">    A(int n_ ) &#123; n = n_; &#125;</span></span><br><span class="line"><span class="string"> friend bool operator&lt; ( const A &amp; a1, const A &amp; a2 )   &#123; return a1.n &lt; a2.n; &#125;</span></span><br><span class="line"><span class="string"> friend ostream &amp;  operator&lt;&lt; ( ostream &amp; o, const A &amp; a2 )  &#123; o &lt;&lt; a2.n;    return o; &#125; </span></span><br><span class="line"><span class="string"> friend class MyLess;  </span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">struct MyLess   &#123;</span></span><br><span class="line"><span class="string">    bool operator()( const A &amp; a1, const A &amp; a2) //按个位数比大小</span></span><br><span class="line"><span class="string">    &#123;  return ( a1.n % 10 ) &lt; (a2.n % 10);  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">typedef multiset&lt;A&gt; MSET1;    //MSET1用 &quot;&lt;&quot;比较大小</span></span><br><span class="line"><span class="string">typedef multiset&lt;A,MyLess&gt; MSET2;  //MSET2用 MyLess::operator()比较大小</span></span><br><span class="line"><span class="string">int main()  </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    const int SIZE = 6;</span></span><br><span class="line"><span class="string">    A a[SIZE] = &#123; 4,22,19,8,33,40 &#125;;</span></span><br><span class="line"><span class="string">    MSET1 m1;   </span></span><br><span class="line"><span class="string">    m1.insert(a,a+SIZE);   //插入元素时，multiset会将被插入元素和已有元素进行比较。</span></span><br><span class="line"><span class="string">    m1.insert(22);    //插入元素时，multiset会将被插入元素和已有元素进行比较。</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;1) &quot; &lt;&lt; m1.count(22) &lt;&lt; endl;       //输出 1) 2</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;2) &quot;; Print(m1.begin(),m1.end());   //输出 2) 4 8 19 22 22 33 40</span></span><br><span class="line"><span class="string">    //m1元素：4 8 19 22 22 33 40 </span></span><br><span class="line"><span class="string">    MSET1::iterator pp =  m1.find(19);</span></span><br><span class="line"><span class="string">	if( pp != m1.end() ) //条件为真说明找到</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;found&quot; &lt;&lt; endl; </span></span><br><span class="line"><span class="string">    out &lt;&lt; &quot;3) &quot;; cout &lt;&lt; * m1.lower_bound(22) &lt;&lt; &quot;,&quot;  //查找一个最大的位置 it,使得[begin(),it) 中所有的元素都比 val 小</span></span><br><span class="line"><span class="string">        										   // 4，8，19    [4,22) 在此区间内所有元素都比22小</span></span><br><span class="line"><span class="string">        &lt;&lt;* m1.upper_bound(22)&lt;&lt; endl;  //查找一个最小的位置 it,使得[it,end()) 中所有的元素都比 val 大。</span></span><br><span class="line"><span class="string">    								 // 33   [33,40) 在些区间内所有元素都比22大</span></span><br><span class="line"><span class="string">    //输出 3) 22,33</span></span><br><span class="line"><span class="string">    pp = m1.erase(m1.lower_bound(22),m1.upper_bound(22)); // 22,22,33  [22,33)</span></span><br><span class="line"><span class="string">    //pp指向被删元素的下一个元素</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;4) &quot;; Print(m1.begin(),m1.end()); //输出 4) 4 8 19 33 40 cout &lt;&lt; &quot;5) &quot;; </span></span><br><span class="line"><span class="string">    cout &lt;&lt; * pp &lt;&lt; endl;           //输出 5) 33</span></span><br><span class="line"><span class="string">    MSET2 m2;    // m2里的元素按n的个位数从小到大排</span></span><br><span class="line"><span class="string">    m2.insert(a,a+SIZE);</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;6) &quot;; Print(m2.begin(),m2.end()); //输出 6) 40 22 33 4 8 19</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--------------------------------------------</span></span><br><span class="line"><span class="string">//set用法示例</span></span><br><span class="line"><span class="string">  set不会有重复元素</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  int main() &#123;</span></span><br><span class="line"><span class="string">    typedef set&lt;int&gt;::iterator IT;</span></span><br><span class="line"><span class="string">    int a[5] = &#123; 3,4,6,1,2 &#125;;</span></span><br><span class="line"><span class="string">    set&lt;int&gt; st(a,a+5);    // st里是 1 2 3 4 6 </span></span><br><span class="line"><span class="string">    pair&lt; IT,bool&gt; result;</span></span><br><span class="line"><span class="string">    result = st.insert(5);  // st变成 1 2 3 4 5 6</span></span><br><span class="line"><span class="string">    if( result.second )     //插入成功则输出被插入元素</span></span><br><span class="line"><span class="string">        cout &lt;&lt; * result.first  &lt;&lt; &quot; inserted&quot; &lt;&lt; endl; //输出: 5 inserted</span></span><br><span class="line"><span class="string">    if( st.insert(5).second )    </span></span><br><span class="line"><span class="string">        cout &lt;&lt; * result.first  &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">    	cout &lt;&lt; * result.first &lt;&lt; &quot; already exists&quot; &lt;&lt; endl; //输出 5 already exists </span></span><br><span class="line"><span class="string">    pair&lt;IT,IT&gt; bounds =st.equal_range(4);   //同时求得lower_bound和upper_bound。</span></span><br><span class="line"><span class="string">    cout &lt;&lt; * bounds.first &lt;&lt; &quot;,&quot; &lt;&lt; * bounds.second ;     //输出：4,5</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="map和multimap">map和multimap</h4><blockquote><p>头文件<set></set></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">map/multimap容器里放着的都是pair模版类的对象，且按first从小到大排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	multimap中的元素由 &lt;关键字,值&gt;组成，每个元素是一个pair对象，关键字就是first成员变量,其类型是Key</span><br><span class="line">	multimap中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用 less&lt;Key&gt; 定义关键字的“小于”关系。</span><br><span class="line"></span><br><span class="line"><span class="comment">//multimap用法示例   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">    <span class="comment">//           成员变量 成员变量  比大小规则（用&lt;比大小）</span></span><br><span class="line">    <span class="keyword">typedef</span> multimap&lt;<span class="type">int</span>,<span class="type">double</span>,less&lt;<span class="type">int</span>&gt; &gt; mmid;</span><br><span class="line">	mmid pairs;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; pairs.<span class="built_in">count</span>(<span class="number">15</span>) &lt;&lt; endl;   <span class="comment">//多少个关键字的值等于15</span></span><br><span class="line">	pairs.<span class="built_in">insert</span>(mmid::<span class="built_in">value_type</span>(<span class="number">15</span>,<span class="number">2.7</span>));		<span class="comment">//typedef pair&lt;const Key, T&gt; value_type; </span></span><br><span class="line">    pairs.<span class="built_in">insert</span>(mmid::<span class="built_in">value_type</span>(<span class="number">15</span>,<span class="number">99.3</span>));</span><br><span class="line">	cout &lt;&lt; “<span class="number">2</span>) ” &lt;&lt; pairs.<span class="built_in">count</span>(<span class="number">15</span>) &lt;&lt; endl;   <span class="comment">//求关键字等于某值的元素个数</span></span><br><span class="line">	pairs.<span class="built_in">insert</span>(mmid::<span class="built_in">value_type</span>(<span class="number">30</span>,<span class="number">111.11</span>));</span><br><span class="line">    pairs.<span class="built_in">insert</span>(mmid::<span class="built_in">value_type</span>(<span class="number">10</span>,<span class="number">22.22</span>));</span><br><span class="line">    pairs.<span class="built_in">insert</span>(mmid::<span class="built_in">value_type</span>(<span class="number">25</span>,<span class="number">33.333</span>)); </span><br><span class="line">    pairs.<span class="built_in">insert</span>(mmid::<span class="built_in">value_type</span>(<span class="number">20</span>,<span class="number">9.3</span>));</span><br><span class="line">    <span class="keyword">for</span>( mmid::const_iterator i = pairs.<span class="built_in">begin</span>();</span><br><span class="line">        i != pairs.<span class="built_in">end</span>() ;i ++ ) </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span>)	<span class="number">0</span></span><br><span class="line"><span class="number">2</span>)	<span class="number">2</span></span><br><span class="line">(<span class="number">10</span>,<span class="number">22.22</span>),(<span class="number">15</span>,<span class="number">2.7</span>),(<span class="number">15</span>,<span class="number">99.3</span>),(<span class="number">20</span>,<span class="number">9.3</span>),(<span class="number">25</span>,<span class="number">33.333</span>),(<span class="number">30</span>,<span class="number">111.11</span>)</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">//multimap例题</span></span><br><span class="line">一个学生成绩录入和查询系统，接受以下两种输入：</span><br><span class="line"> Add name id score    输入学生信息 name学生姓名，id学号，score分数。学号不会重复，分数和姓名都可以重复</span><br><span class="line"> Query score	查询，输出已有信息中分数比score低的最高分获得者的学生信息，多个学生满足条件，就输出学号最大的，则输出”Noboy“</span><br><span class="line">    </span><br><span class="line">输入样例：</span><br><span class="line">Add Jack <span class="number">12</span>  <span class="number">78</span> </span><br><span class="line">Query <span class="number">78</span> </span><br><span class="line">Query <span class="number">81</span></span><br><span class="line">Add Percy <span class="number">9</span>  <span class="number">81</span> </span><br><span class="line">Add Marry <span class="number">8</span>  <span class="number">81</span> </span><br><span class="line">Query <span class="number">82</span></span><br><span class="line">Add Tom <span class="number">11</span> <span class="number">79</span> </span><br><span class="line">Query <span class="number">80</span> </span><br><span class="line">Query <span class="number">81</span></span><br><span class="line">    </span><br><span class="line">输出果样例：</span><br><span class="line">Nobody</span><br><span class="line">Jack <span class="number">12</span> <span class="number">78</span> </span><br><span class="line">Percy <span class="number">9</span> <span class="number">81</span> </span><br><span class="line">Tom <span class="number">11</span> <span class="number">79</span> </span><br><span class="line">Tom <span class="number">11</span> <span class="number">79</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStudent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CInfo</span> <span class="comment">//类的内部还可以定义类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id; </span><br><span class="line">        string name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    CInfo info; <span class="comment">//学生的其他信息</span></span><br><span class="line">&#125;;</span><br><span class="line">	   <span class="comment">//       分数       类的内部类 使用要加外部类的名称（学生的id,和学生的名称）</span></span><br><span class="line"><span class="keyword">typedef</span> multimap&lt;<span class="type">int</span>, CStudent::CInfo&gt; MAP_STD;  <span class="comment">//没有指定的比大小的规则，默认为less &lt;  分数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">    MAP_STD mp; </span><br><span class="line">    CStudent st;</span><br><span class="line">    string cmd;</span><br><span class="line">    <span class="keyword">while</span>( cin &gt;&gt; cmd ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( cmd == <span class="string">&quot;Add&quot;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score ;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//mp.insert(make_pair(st.score,st.info )); 也可以      make_pair 指向pair模版类</span></span><br><span class="line">		    mp.<span class="built_in">insert</span>(MAP_STD::<span class="built_in">value_type</span>(st.score,st.info )); </span><br><span class="line">          &#125;</span><br><span class="line">		  <span class="keyword">else</span> <span class="keyword">if</span>( cmd == <span class="string">&quot;Query&quot;</span> )&#123;</span><br><span class="line">              <span class="type">int</span> score;</span><br><span class="line">			 cin &gt;&gt; score;</span><br><span class="line">              <span class="comment">//查找一个最大的位置 it,使得[begin(),it) 中所有的元素都比 val 小</span></span><br><span class="line">			 MAP_STD::iterator p = mp.<span class="built_in">lower_bound</span> (score);</span><br><span class="line">              <span class="keyword">if</span>( p!= mp.<span class="built_in">begin</span>()) &#123; </span><br><span class="line">                  --p;</span><br><span class="line">				score = p-&gt;first; <span class="comment">//比要查询分数低的最高分</span></span><br><span class="line">                  MAP_STD::iterator maxp = p; </span><br><span class="line">				<span class="type">int</span> maxId = p-&gt;second.id; </span><br><span class="line">                  <span class="keyword">for</span>( ; p != mp.<span class="built_in">begin</span>() &amp;&amp; p-&gt;first == score; --p) &#123;</span><br><span class="line">				<span class="comment">//遍历所有成绩和score相等的学生</span></span><br><span class="line">                  <span class="keyword">if</span>( p-&gt;second.id &gt; maxId ) &#123;</span><br><span class="line">                      maxp = p;</span><br><span class="line">					maxId = p-&gt;second.id ;</span><br><span class="line">                  &#125;</span><br><span class="line">             &#125;</span><br><span class="line">			<span class="keyword">if</span>( p-&gt;first == score) &#123; </span><br><span class="line">			<span class="comment">//如果上面循环是因为 p == mp.begin()</span></span><br><span class="line">             <span class="comment">// 而终止，则p指向的元素还要处理	</span></span><br><span class="line">                <span class="keyword">if</span>( p-&gt;second.id  &gt; maxId ) &#123;</span><br><span class="line">                    maxp = p;</span><br><span class="line">				   maxId = p-&gt;second.id ;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                  cout &lt;&lt; maxp-&gt;second.name &lt;&lt;</span><br><span class="line">                  <span class="string">&quot; “ &lt;&lt; maxp-&gt;second.id &lt;&lt; &quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">                      &lt;&lt; maxp-&gt;first &lt;&lt; endl;</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">			 else </span></span><br><span class="line"><span class="string">//lower_bound的结果就是 begin，说明没人分数比查询分数低</span></span><br><span class="line"><span class="string">              		cout &lt;&lt; &quot;</span>Nobody<span class="string">&quot; &lt;&lt; endl; </span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">		return 0;</span></span><br><span class="line"><span class="string">  &#125;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--------------------------------------------------------</span></span><br><span class="line"><span class="string">map 中的元素都是pair模板类对象。关键字(first成员变量)各不相同。元素按照关键字从小到大排列，缺省情况下用 less&lt;Key&gt;,即“&lt;” 定义“小于”。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">template &lt;class Key,class Value&gt;</span></span><br><span class="line"><span class="string">ostream &amp; operator &lt;&lt;( ostream &amp; o, const pair&lt;Key,Value&gt; &amp; p) //重载，pair对象的内容输出</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    o &lt;&lt; &quot;</span>(<span class="string">&quot; &lt;&lt; p.first &lt;&lt; &quot;</span>,<span class="string">&quot; &lt;&lt; p.second &lt;&lt; &quot;</span>)<span class="string">&quot;;  //输出方式</span></span><br><span class="line"><span class="string">    return o;</span></span><br><span class="line"><span class="string">&#125;  </span></span><br><span class="line"><span class="string">int main()  &#123;</span></span><br><span class="line"><span class="string">    //    关键字  		   比大小方式（&lt;）</span></span><br><span class="line"><span class="string">typedef map&lt;int, double,less&lt;int&gt; &gt; mmid;</span></span><br><span class="line"><span class="string">mmid pairs;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;</span><span class="number">1</span>) <span class="string">&quot; &lt;&lt; pairs.count(15) &lt;&lt; endl;</span></span><br><span class="line"><span class="string">pairs.insert(mmid::value_type(15,2.7));  //插入元素</span></span><br><span class="line"><span class="string">pairs.insert(make_pair(15,99.3)); //make_pair生成一个pair对象</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;</span><span class="number">2</span>) <span class="string">&quot; &lt;&lt; pairs.count(15) &lt;&lt; endl; </span></span><br><span class="line"><span class="string">pairs.insert(mmid::value_type(20,9.3));</span></span><br><span class="line"><span class="string">mmid::iterator i; </span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;</span><span class="number">3</span>) <span class="string">&quot;; 1)</span></span><br><span class="line"><span class="string">for( i = pairs.begin(); i != pairs.end();i ++ ) </span></span><br><span class="line"><span class="string"> 	cout &lt;&lt; * i  &lt;&lt; &quot;</span>,<span class="string">&quot;;</span></span><br><span class="line"><span class="string">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;</span><span class="number">4</span>) <span class="string">&quot;;</span></span><br><span class="line"><span class="string">int n =  pairs[40];//如果没有关键字为40的元素，则插入一个</span></span><br><span class="line"><span class="string">for( i = pairs.begin(); i != pairs.end();i ++ )</span></span><br><span class="line"><span class="string">    cout &lt;&lt; * i  &lt;&lt; &quot;</span>,<span class="string">&quot;;</span></span><br><span class="line"><span class="string">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;</span><span class="number">5</span>) <span class="string">&quot;;</span></span><br><span class="line"><span class="string">pairs[15] = 6.28; //把关键字为15的元素值改成6.28 </span></span><br><span class="line"><span class="string">for( i = pairs.begin(); i != pairs.end();i ++ )</span></span><br><span class="line"><span class="string">	cout &lt;&lt; * i  &lt;&lt; &quot;</span>,<span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="容器适配器">容器适配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">【stack】</span><br><span class="line">头文件 &lt;stack&gt;</span><br><span class="line">栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。<span class="string">&quot;后进先出&quot;</span>。</span><br><span class="line">                                                           </span><br><span class="line">                   出栈         入栈                                 </span><br><span class="line">    			   ↖	    ↗</span><br><span class="line">                       \    /                                    </span><br><span class="line">                    ___________</span><br><span class="line">         top——&gt;     |   an    |</span><br><span class="line">                    ———————————                                                       </span><br><span class="line">                    |   ...   |   </span><br><span class="line">                    ———————————                                          </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">      bottom——&gt;     |    a1   |   </span><br><span class="line">                    ———————————       </span><br><span class="line">    </span><br><span class="line">stack 是后进先出的数据结构，只能插入，删除，访问栈顶的元素。</span><br><span class="line">可用 vector,  list, deque来实现。缺省情况下，用deque实现。用 vector和deque实现，比用list实现性能好。</span><br><span class="line">    </span><br><span class="line">stack 上可以进行以下操作：</span><br><span class="line">push     插入元素</span><br><span class="line">pop      弹出元素</span><br><span class="line">top      返回栈顶元素的引用</span><br><span class="line"> </span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line">【queue】</span><br><span class="line">头文件 &lt;queue&gt;</span><br><span class="line">队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。<span class="string">&quot;先进先出&quot;</span>。</span><br><span class="line">                                                           </span><br><span class="line">                    入队                                       </span><br><span class="line">    				\	    </span><br><span class="line">                       ↘                                      </span><br><span class="line">                    ___________</span><br><span class="line">         rear——&gt;    |   an    |</span><br><span class="line">                    ———————————                                                       </span><br><span class="line">                    |   ...   |   </span><br><span class="line">                    ———————————                                          </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">                    |   ...   |</span><br><span class="line">                    ———————————    </span><br><span class="line">       front——&gt;     |    a1   |   </span><br><span class="line">                    ———————————  </span><br><span class="line">                         \</span><br><span class="line">                          ↘   </span><br><span class="line">                            出队                 </span><br><span class="line">    </span><br><span class="line">和stack 基本类似，可以用 list和deque实现。缺省情况下用deque实现。</span><br><span class="line">同样也有push, pop, top函数。但是push发生在队尾；pop, top发生在队头。先进先出。</span><br><span class="line">有 back 成员函数可以返回队尾元素的引用               </span><br><span class="line">    </span><br><span class="line">---------------------------------------------------------------------                                                    </span><br><span class="line">【priority_queue】      </span><br><span class="line">头文件 &lt;queue&gt;</span><br><span class="line">优先级队列。最高优先级元素总是第一个出列</span><br><span class="line"></span><br><span class="line">和 queue类似，可以用vector和deque实现。缺省情况下用vector实现。</span><br><span class="line">priority_queue 通常用堆排序技术实现，保证最大的元素总是在最前面。即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的常引用。默认的元素比较器是less&lt;T&gt;。</span><br><span class="line">    </span><br><span class="line">push、pop 时间复杂度<span class="built_in">O</span>(logn)</span><br><span class="line"><span class="built_in">top</span>()时间复杂度<span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">double</span>&gt; pq1;</span><br><span class="line">	pq1.<span class="built_in">push</span>(<span class="number">3.2</span>); pq1.<span class="built_in">push</span>(<span class="number">9.8</span>); pq1.<span class="built_in">push</span>(<span class="number">9.8</span>); pq1.<span class="built_in">push</span>(<span class="number">5.4</span>); </span><br><span class="line">    <span class="keyword">while</span>( !pq1.<span class="built_in">empty</span>() ) &#123;   <span class="comment">//判断是否为空</span></span><br><span class="line">		cout &lt;&lt; pq1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//队头元素输出（最大的）</span></span><br><span class="line">		pq1.<span class="built_in">pop</span>();			<span class="comment">//队头元素删除（最大的），剩下的元素中最大的到队头</span></span><br><span class="line">	&#125; <span class="comment">//上面输出 9.8 9.8 5.4 3.2</span></span><br><span class="line">    cout &lt;&lt; endl;					    <span class="comment">//小的反而大，小的排前面</span></span><br><span class="line">	priority_queue&lt;<span class="type">double</span>,vector&lt;<span class="type">double</span>&gt;,greater&lt;<span class="type">double</span>&gt; &gt; pq2; pq2.<span class="built_in">push</span>(<span class="number">3.2</span>); pq2.<span class="built_in">push</span>(<span class="number">9.8</span>); pq2.<span class="built_in">push</span>(<span class="number">9.8</span>); 		pq2.<span class="built_in">push</span>(<span class="number">5.4</span>); </span><br><span class="line">    <span class="keyword">while</span>( !pq2.<span class="built_in">empty</span>() ) &#123;</span><br><span class="line">        cout &lt;&lt; pq2.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">        pq2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上面输出 3.2 5.4 9.8 9.8 return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>stack , queue , priority_queue 都有的成员函数</th><th></th></tr></thead><tbody><tr><td>empty()</td><td>成员函数用于判断适配器是否为空</td></tr><tr><td>size()</td><td>成员函数返回适配器中元素个数</td></tr></tbody></table><h3 id="算法-2">算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">STL中的算法大致可以分为以下七类：</span><br><span class="line"><span class="number">1</span>)	不变序列算法</span><br><span class="line"><span class="number">2</span>)	变值算法</span><br><span class="line"><span class="number">3</span>)	删除算法</span><br><span class="line"><span class="number">4</span>)	变序算法</span><br><span class="line"><span class="number">5</span>)	排序算法</span><br><span class="line"><span class="number">6</span>)	有序区间算法</span><br><span class="line"><span class="number">7</span>)	数值算法</span><br><span class="line">    </span><br><span class="line">大多重载的算法都是有两个版本的</span><br><span class="line"><span class="number">1.</span>其中一个是用“==”判断元素是否相等，或用“&lt;”来比较大小；</span><br><span class="line"><span class="number">2.</span>而另一个版本多出来一个类型参数“Pred”，以及函数形参“Pred op”,该版本通过表达式“<span class="built_in">op</span>(x,y)”的返回值是ture还是<span class="literal">false</span>，来判断x是否“等于”y，或者x是否“小于”y。</span><br><span class="line">    </span><br><span class="line">如下面的有两个版本的min_element:</span><br><span class="line">iterate <span class="built_in">min_element</span>(iterate first,iterate last);</span><br><span class="line"><span class="function">iterate <span class="title">min_element</span><span class="params">(iterate first,iterate last, Pred op)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="1-不变序列算法">1. 不变序列算法</h4><table><thead><tr><th>算法名称</th><th>功能</th></tr></thead><tbody><tr><td>min</td><td>求两个对象中较小的(可自定义比较器)</td></tr><tr><td>max</td><td>求两个对象中较大的(可自定义比较器)</td></tr><tr><td>min_element</td><td>求区间中的最小值(可自定义比较器)</td></tr><tr><td>max_element</td><td>求区间中的最大值(可自定义比较器)</td></tr><tr><td>for_each</td><td>对区间中的每个元素都做某种操作</td></tr><tr><td>count</td><td>计算区间中等于某值的元素个数</td></tr><tr><td>count_if</td><td>计算区间中符合某种条件的元素个数</td></tr><tr><td>find</td><td>在区间中查找等于某值的元素</td></tr><tr><td>find_if</td><td>在区间中查找符合某条件的元素</td></tr><tr><td>find_end</td><td>在区间中查找另一个区间最后一次出现的位置(可自定义比较器)</td></tr><tr><td>find_first_of</td><td>在区间中查找第一个出现在另一个区间中的元素 (可自定义比较器)</td></tr><tr><td>adjacent_find</td><td>在区间中寻找第一次出现连续两个相等元素的位置(可自定义比较器)</td></tr><tr><td>search</td><td>在区间中查找另一个区间第一次出现的位置(可自定义比较器)</td></tr><tr><td>search_n</td><td>在区间中查找第一次出现等于某值的连续n个元素(可自定义比较器)</td></tr><tr><td>equal</td><td>判断两区间是否相等(可自定义比较器)</td></tr><tr><td>mismatch</td><td>逐个比较两个区间的元素，返回第一次发生不相等的两个元素的位置( 可自定义比较器)</td></tr><tr><td>lexicographical_compare</td><td>按字典序比较两个区间的大小(可自定义比较器)</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>此类算法不会修改算法所作用的容器或对象</span><br><span class="line"><span class="number">2.</span>适用于所有容器</span><br><span class="line"><span class="number">3.</span>时间复杂度都是O（n）的</span><br></pre></td></tr></table></figure><h4 id="2-变值算法">2. 变值算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此类算法会修改源区间或目标区间元素的值。</span><br><span class="line">值被修改的那个区间，不可以是属于关联容器的。</span><br></pre></td></tr></table></figure><table><thead><tr><th>算法名称</th><th>功能</th></tr></thead><tbody><tr><td>for_each</td><td>对区间中的每个元素都做某种操作</td></tr><tr><td>copy</td><td>复制一个区间到别处</td></tr><tr><td>copy_backward</td><td>复制一个区间到别处，但目标区前是从后往前被修改的</td></tr><tr><td>transform</td><td>将一个区间的元素变形后拷贝到另一个区间</td></tr><tr><td>swap_ranges</td><td>交换两个区间内容</td></tr><tr><td>fill</td><td>用某个值填充区间</td></tr><tr><td>fill_n</td><td>用某个值替换区间中的n个元素</td></tr><tr><td>generate</td><td>用某个操作的结果填充区间</td></tr><tr><td>generate_n</td><td>用某个操作的结果替换区间中的n个元素</td></tr><tr><td>replace</td><td>将区间中的某个值替换为另一个值</td></tr><tr><td>replace_if</td><td>将区间中符合某种条件的值替换成另一个值</td></tr><tr><td>replace_copy</td><td>将一个区间拷贝到另一个区间，拷贝时某个值要换成新值拷过去</td></tr><tr><td>replace_copy_if</td><td>将一个区间拷贝到另一个区间，拷贝时符合某条件的值要换成新值拷过去</td></tr></tbody></table><h4 id="3-删除算法">3. 删除算法</h4><table><thead><tr><th>算法名称</th><th>功能</th></tr></thead><tbody><tr><td>remove</td><td>删除区间中等于某个值的元素</td></tr><tr><td>remove_if</td><td>删除区间中满足某种条件的元素</td></tr><tr><td>remove_copy</td><td>拷贝区间到另一个区间。等于某个值的元素不拷贝</td></tr><tr><td>remove_copy_if</td><td>拷贝区间到另一个区间。符合某种条件的元素不拷贝</td></tr><tr><td>unique</td><td>删除区间中连续相等的元素，只留下一个(可自定义比较器)</td></tr><tr><td>unique_copy</td><td>拷贝区间到另一个区间。连续相等的元素，只拷贝第一个到目标区间 (可自定义比较器)</td></tr></tbody></table><h4 id="4-变序算法">4. 变序算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变序算法改变容器中元素的顺序，但是不改变元素的值。</span><br><span class="line">变序算法不适用于关联容器。此类算法复杂度都是O（n）的。</span><br></pre></td></tr></table></figure><table><thead><tr><th>算法名称</th><th>功能</th></tr></thead><tbody><tr><td>reverse</td><td>颠倒区间的前后次序</td></tr><tr><td>reverse_copy</td><td>把一个区间颠倒后的结果拷贝到另一个区间，源区间不变</td></tr><tr><td>rotate</td><td>将区间进行循环左移</td></tr><tr><td>rotate_copy</td><td>将区间以首尾相接的形式进行旋转后的结果拷贝到另一个区间，源区间不变</td></tr><tr><td>next_permutation</td><td>将区间改为下一个排列(可自定义比较器)</td></tr><tr><td>prev_permutation</td><td>将区间改为上一个排列(可自定义比较器)</td></tr><tr><td>random_shuffle</td><td>随机打乱区间内元素的顺序</td></tr><tr><td>partition</td><td>把区间内满足某个条件的元素移到前面，不满足该条件的移到后面</td></tr><tr><td>stable_patition</td><td>把区间内满足某个条件的元素移到前面，不满足该条件的移到后面。而且对这两部分元素，分别保持它们原来的先后次序不变</td></tr><tr><td>random_shuffle</td><td>template<class ranit><br>void random_shuffle(RanIt first, RanIt last);<br>随机打乱[first,last) 中的元素，适用于能随机访问的容器。</class></td></tr><tr><td>reverse</td><td>template<class bidit><br>void reverse(BidIt first, BidIt last);<br>颠倒区间[first,last)顺序</class></td></tr><tr><td>next_permutation</td><td>template<class init><br>bool next_permutaion (Init first,Init last);<br>求下一个排列</class></td></tr></tbody></table><h4 id="5-排序算法">5. 排序算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序算法比前面的变序算法复杂度更高，一般是<span class="built_in">O</span>(n×<span class="built_in">log</span>(n))。排序算法需要随机访问迭代器的支持，因而不适用于关联容器和list。</span><br></pre></td></tr></table></figure><table><thead><tr><th>算法名称</th><th>功能</th></tr></thead><tbody><tr><td>sort</td><td>将区间从小到大排序(可自定义比较器)。</td></tr><tr><td>stable_sort</td><td>将区间从小到大排序，并保持相等元素间的相对次序(可自定义比较器)。</td></tr><tr><td>partial_sort</td><td>对区间部分排序，直到最小的n个元素就位(可自定义比较器)。</td></tr><tr><td>partial_sort_copy</td><td>将区间前n个元素的排序结果拷贝到别处。源区间不变(可自定义比较器)。</td></tr><tr><td>nth_element</td><td>对区间部分排序，使得第n小的元素（n从0开始算）就位，而且比它小的都在它前面，比它大的都在它后面(可自定义比较器)。</td></tr><tr><td>make_heap</td><td>使区间成为一个“堆”(可自定义比较器)。</td></tr><tr><td>push_heap</td><td>将元素加入一个是“堆”区间(可自定义比较器)。</td></tr><tr><td>pop_heap</td><td>从 “堆”区间删除堆顶元素(可自定义比较器)。</td></tr><tr><td>sort_heap</td><td>将一个“堆”区间进行排序，排序结束后，该区间就是普通的有序区间，不再是 “堆”了(可自定义比较器)。</td></tr><tr><td>partial_sort</td><td>部分排序，直到 前 n 个元素就位即可。</td></tr><tr><td>nth_element</td><td>排序，直到第 n个元素就位，并保证比第n个元素小的元素都在第 n 个元素之前即可。</td></tr><tr><td>partition</td><td>改变元素次序，使符合某准则的元素放在前面</td></tr></tbody></table><h4 id="6-有序区间算法">6. 有序区间算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序区间算法要求所操作的区间是已经从小到大排好序的，而且需要随机访问迭代器的支持。所以有序区间算法不能用于关联容器和list。</span><br></pre></td></tr></table></figure><table><thead><tr><th>算法名称</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td>binary_search</td><td style="text-align:left">判断区间中是否包含某个元素。</td></tr><tr><td>includes</td><td style="text-align:left">判断是否一个区间中的每个元素，都在另一个区间中。</td></tr><tr><td>lower_bound</td><td style="text-align:left">查找最后一个不小于某值的元素的位置。</td></tr><tr><td>upper_bound</td><td style="text-align:left">查找第一个大于某值的元素的位置。</td></tr><tr><td>equal_range</td><td style="text-align:left">同时获取lower_bound和upper_bound。</td></tr><tr><td>merge</td><td style="text-align:left">合并两个有序区间到第三个区间。</td></tr><tr><td>set_union</td><td style="text-align:left">将两个有序区间的并拷贝到第三个区间</td></tr><tr><td>set_intersection</td><td style="text-align:left">将两个有序区间的交拷贝到第三个区间</td></tr><tr><td>set_difference</td><td style="text-align:left">将两个有序区间的差拷贝到第三个区间</td></tr><tr><td>set_symmetric_difference</td><td style="text-align:left">将两个有序区间的对称差拷贝到第三个区间</td></tr><tr><td>inplace_merge</td><td style="text-align:left">将两个连续的有序区间原地合并为一个有序区间</td></tr><tr><td>lower_bound</td><td style="text-align:left">template&lt;class FwdIt, class T&gt;<br>FwdIt lower_bound(FwdIt first, FwdIt last, const T&amp; val);<br>要求[first,last)是有序的，<br>查找[first,last)中的,最大的位置 FwdIt,使得[first,FwdIt) 中所有的元素都比 val 小</td></tr><tr><td>upper_bound</td><td style="text-align:left">template&lt;class FwdIt, class T&gt;<br>FwdIt upper_bound(FwdIt first, FwdIt last, const T&amp; val);<br>要求[first,last)是有序的，<br>查找[first,last)中的,最小的位置 FwdIt,使得[FwdIt,last) 中所有的元素都比 val 大</td></tr><tr><td>equal_range</td><td style="text-align:left">template&lt;class FwdIt, class T&gt;<br>pair&lt;FwdIt, FwdIt&gt; equal_range(FwdIt first, FwdIt last, const T&amp; val);<br>要求[first,last)是有序的，<br>返回值是一个pair, 假设为 p, 则：<br>[first,p.first) 中的元素都比 val 小<br>[p.second,last)中的所有元素都比 val 大<br>p.first 就是lower_bound的结果<br>p.last 就是 upper_bound的结果</td></tr></tbody></table><h4 id="7-数值算法">7. 数值算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitset</span> </span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">实际使用的时候，N是个整型常数</span><br><span class="line">如：</span><br><span class="line">    bitset&lt;40&gt; bst;</span><br><span class="line">	bst是一个由<span class="number">40</span>位组成的对象，用bitset的函数可以方便地访问任何一位。</span><br><span class="line">        </span><br><span class="line">bitset&lt;N&gt;&amp; <span class="keyword">operator</span>&amp;=(<span class="type">const</span> bitset&lt;N&gt;&amp; rhs); </span><br><span class="line">bitset&lt;N&gt;&amp; <span class="keyword">operator</span>|=(<span class="type">const</span> bitset&lt;N&gt;&amp; rhs); </span><br><span class="line">bitset&lt;N&gt;&amp; <span class="keyword">operator</span>^=(<span class="type">const</span> bitset&lt;N&gt;&amp; rhs);</span><br><span class="line">bitset&lt;N&gt;&amp; <span class="keyword">operator</span>&lt;&lt;=(<span class="type">size_t</span> num); </span><br><span class="line">bitset&lt;N&gt;&amp; <span class="keyword">operator</span>&gt;&gt;=(<span class="type">size_t</span> num); </span><br><span class="line"><span class="function">bitset&lt;N&gt;&amp; <span class="title">set</span><span class="params">()</span></span>; <span class="comment">//全部设成1</span></span><br><span class="line"><span class="function">bitset&lt;N&gt;&amp; <span class="title">set</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">bool</span> val = <span class="literal">true</span>)</span></span>; <span class="comment">//设置某位</span></span><br><span class="line"><span class="function">bitset&lt;N&gt;&amp; <span class="title">reset</span><span class="params">()</span></span>; <span class="comment">//全部设成0</span></span><br><span class="line"><span class="function">bitset&lt;N&gt;&amp; <span class="title">reset</span><span class="params">(<span class="type">size_t</span> pos)</span></span>; <span class="comment">//某位设成0</span></span><br><span class="line"><span class="function">bitset&lt;N&gt;&amp; <span class="title">flip</span><span class="params">()</span></span>; <span class="comment">//全部翻转</span></span><br><span class="line"><span class="function">bitset&lt;N&gt;&amp; <span class="title">flip</span><span class="params">(<span class="type">size_t</span> pos)</span></span>; <span class="comment">//翻转某位</span></span><br><span class="line">reference <span class="keyword">operator</span>[](<span class="type">size_t</span> pos); <span class="comment">//返回对某位的引用</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span>; <span class="comment">//判断某位是否为1 </span></span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="type">size_t</span> pos)</span></span>; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">at</span><span class="params">(<span class="type">size_t</span> pos)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">to_ulong</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//转换成整数</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//转换成字符串</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//计算1的个数</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> bitset&lt;N&gt;&amp; rhs) <span class="type">const</span>; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> bitset&lt;N&gt;&amp; rhs) <span class="type">const</span>; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">size_t</span> pos)</span> <span class="type">const</span></span>;  <span class="comment">//测试某位是否为 1 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">any</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//是否有某位为1 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">none</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//是否全部为0</span></span><br><span class="line">bitset&lt;N&gt; <span class="keyword">operator</span>&lt;&lt;(<span class="type">size_t</span> pos) <span class="type">const</span>;</span><br><span class="line">bitset&lt;N&gt; <span class="keyword">operator</span>&gt;&gt;(<span class="type">size_t</span> pos) <span class="type">const</span>;</span><br><span class="line">bitset&lt;N&gt; <span class="keyword">operator</span>~(); </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> bitset_size = N; </span><br><span class="line">注意：第<span class="number">0</span>位在最右边</span><br></pre></td></tr></table></figure><h2 id="c-11特性">c++ 11特性</h2><h4 id="成员变量默认初始值">成员变量默认初始值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m = <span class="number">1234</span>; <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">	cout &lt;&lt; b.m &lt;&lt; endl;   <span class="comment">//输出 1234</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="auto关键字">auto关键字</h4><blockquote><p>用于定义变量，编译起可以自动判断变量的类型,需要初始化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">100</span>;      <span class="comment">// i 是 int</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">A</span>();  <span class="comment">// p 是 A *</span></span><br><span class="line"><span class="keyword">auto</span> k = <span class="number">34343LL</span>;  <span class="comment">// k 是 long long </span></span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line">    </span><br><span class="line">map&lt;string,<span class="type">int</span>,greater&lt;string&gt; &gt; mp;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> i = mp.<span class="built_in">begin</span>(); i != mp.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; i-&gt;second ;</span><br><span class="line"><span class="comment">//i的类型是： map&lt;string,int,greater&lt;string&gt; &gt;::iterator  </span></span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line">A <span class="keyword">operator</span> + ( <span class="type">int</span> n,<span class="type">const</span> A &amp; a)</span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">    <span class="comment">//函数的返回值写在函数的后面用 -&gt;  </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span>&#123;  <span class="comment">// decltype确定x+y的类型，将该类型返回给 auto 确定函数类型</span></span><br><span class="line">	<span class="keyword">return</span> x+y;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> d = <span class="built_in">add</span>(<span class="number">100</span>,<span class="number">1.5</span>); <span class="comment">// d是double d=101.5</span></span><br><span class="line"><span class="keyword">auto</span> k = <span class="built_in">add</span>(<span class="number">100</span>,<span class="built_in">A</span>()); <span class="comment">// k是A类型</span></span><br></pre></td></tr></table></figure><h4 id="decltype-关键字">decltype 关键字</h4><blockquote><p>求表达式的类型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="type">double</span> t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">double</span> x; &#125;;</span><br><span class="line"><span class="type">const</span> A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">decltype</span>(a)   x1;         <span class="comment">//x1 是 A* 类型</span></span><br><span class="line"><span class="keyword">decltype</span>(i)   x2;  	      <span class="comment">//x2 是 int 类型</span></span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x)   x3;   	  <span class="comment">//x3 是 double 类型</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x))  x4 = t; <span class="comment">//x4 是 double&amp; 类型   用括号（），包括，就是&amp;</span></span><br></pre></td></tr></table></figure><h4 id="基于范围的for循环">基于范围的for循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">int</span> n; <span class="built_in">A</span>(<span class="type">int</span> i):<span class="built_in">n</span>(i) &#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ary[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp; e: ary)  <span class="comment">// 遍历，&amp;e,就是arr[]里面每一个值，e改变那么arr里面对应的值就改变</span></span><br><span class="line">        e*= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e  : ary)  <span class="comment">// 遍历，e,复制arr[]里面每一个值来使用，e不会改变arr里面的值</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; <span class="string">&quot;,&quot;</span>; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="function">vector&lt;A&gt; <span class="title">st</span><span class="params">(ary,ary+<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(  <span class="keyword">auto</span> &amp; it: st) </span><br><span class="line">        it.n *= <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span>(  A it: st) </span><br><span class="line">		cout &lt;&lt; it.n &lt;&lt; <span class="string">&quot;,&quot;</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右值引用和MOVE语义">右值引用和MOVE语义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 右值：一般来说，不能取地址的表达式，就是右值，能取地址的，就是左值</span><br><span class="line">     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line">A &amp; r = <span class="built_in">A</span>(); <span class="comment">// error , A()是无名变量，是右值</span></span><br><span class="line">A &amp;&amp; r = <span class="built_in">A</span>(); <span class="comment">//ok, r 是右值引用</span></span><br><span class="line"></span><br><span class="line">主要目的是提高程序运行的效率，减少需要进行深拷贝的对象进行深拷贝的次数。</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;move 将左值变为右值&#x27;</span></span><br><span class="line">    </span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> * str;</span><br><span class="line">	<span class="built_in">String</span>():<span class="built_in">str</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>]) &#123; str[<span class="number">0</span>] = <span class="number">0</span>;&#125; </span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> * s) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s)+<span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">strcpy</span>(str,s);</span><br><span class="line">     &#125;</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String &amp; s) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor called&quot;</span> &lt;&lt; endl; </span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">	    <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">     &#125;</span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="type">const</span> String &amp; s) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy operator= called&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>( str != s.str) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] str;</span><br><span class="line">		   str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>]; </span><br><span class="line">            <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// move constructor</span></span><br><span class="line">	<span class="built_in">String</span>(String &amp;&amp; s):<span class="built_in">str</span>(s.str) &#123; </span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move constructor called&quot;</span>&lt;&lt;endl; </span><br><span class="line">        s.str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">	    s.str[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String &amp; <span class="keyword">operator</span> = (String &amp;&amp;s) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move operator= called&quot;</span>&lt;&lt;endl; </span><br><span class="line">        <span class="keyword">if</span> (str!= s.str) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] str;</span><br><span class="line">		   		str = s.str; </span><br><span class="line">            s.str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            s.str[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span> [] str; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveSwap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(move(a))</span></span>;   <span class="comment">// std::move(a)为右值，这里会调用moveconstructor </span></span><br><span class="line">    a = <span class="built_in">move</span>(b);	 <span class="comment">//move(b)为右值，因此这里会调用move assigment</span></span><br><span class="line">    b = <span class="built_in">move</span>(tmp);   <span class="comment">// move(tmp)为右值，因此这里会调用move assigment</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//String &amp; r = String(&quot;this&quot;); // error</span></span><br><span class="line">    String s;</span><br><span class="line">    s = <span class="built_in">String</span>(<span class="string">&quot;ok&quot;</span>); <span class="comment">// String(&quot;ok&quot;)是右值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;******&quot;</span> &lt;&lt; endl;</span><br><span class="line">    String  &amp;&amp; r = <span class="built_in">String</span>(<span class="string">&quot;this&quot;</span>);</span><br><span class="line">    cout &lt;&lt; r.str &lt;&lt; endl;</span><br><span class="line">    String s1 = <span class="string">&quot;hello&quot;</span>,s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">MoveSwap</span>(s1,s2);</span><br><span class="line">	cout &lt;&lt; s2.str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无序容器（哈希表）">无序容器（哈希表）</h4><blockquote><p>头文件 &lt;unordered_map&gt;</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; turingWinner; <span class="comment">//图灵奖获奖名单</span></span><br><span class="line">    turingWinner.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Dijkstra&quot;</span>,<span class="number">1972</span>)); 	</span><br><span class="line">    turingWinner.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Scott&quot;</span>,<span class="number">1976</span>)); </span><br><span class="line">    turingWinner.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Wilkes&quot;</span>,<span class="number">1967</span>)); </span><br><span class="line">    turingWinner.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Hamming&quot;</span>,<span class="number">1968</span>)); </span><br><span class="line">    turingWinner[<span class="string">&quot;Ritchie&quot;</span>] = <span class="number">1983</span>;</span><br><span class="line">	string name;</span><br><span class="line">	cin &gt;&gt; name; <span class="comment">//输入姓名</span></span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt;::iterator p = turingWinner.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="comment">//据姓名查获奖时间</span></span><br><span class="line">	<span class="keyword">if</span>( p != turingWinner.<span class="built_in">end</span>())</span><br><span class="line">         cout &lt;&lt; p-&gt;second;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希表插入和查询的时间复杂度几乎是常数</span><br></pre></td></tr></table></figure><h4 id="正则表达式">正则表达式</h4><blockquote><p>头文件<regex></regex></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;b.?p.*k&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;bopggk&quot;</span>,reg) &lt;&lt;endl;<span class="comment">//输出 1, 表示匹配成功</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;boopgggk&quot;</span>,reg) &lt;&lt;endl;<span class="comment">//输出 0, 匹配失败</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;b pk&quot;</span>,reg) &lt;&lt;endl; <span class="comment">//输出 1, 表示匹配成功</span></span><br><span class="line">    <span class="function">regex <span class="title">reg2</span><span class="params">(<span class="string">&quot;\\d&#123;3&#125;([a-zA-Z]+).(\\d&#123;2&#125;|N/A)\\s\\1&quot;</span>)</span></span>; </span><br><span class="line">    string correct=<span class="string">&quot;123Hello N/A Hello&quot;</span>;</span><br><span class="line">	string incorrect=<span class="string">&quot;123Hello 12 hello&quot;</span>; </span><br><span class="line">	cout &lt;&lt; <span class="built_in">regex_match</span>(correct,reg2) &lt;&lt;endl; <span class="comment">//输出 1,匹配成功</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_match</span>(incorrect,reg2) &lt;&lt; endl; <span class="comment">//输出 0, 失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda表达式">Lambda表达式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">形式：</span><br><span class="line">[外部变量访问方式说明符](参数表) -&gt;返回值类型</span><br><span class="line">&#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[]				不使用任何外部变量</span><br><span class="line">[=]				以传值的形式使用所有外部变量</span><br><span class="line">[&amp;]			    以引用形式使用所有外部变量</span><br><span class="line">[x, &amp;y] 		x 以传值形式使用，y 以引用形式使用</span><br><span class="line">[=,&amp;x,&amp;y]		x,y 以引用形式使用，其余变量以传值形式使用</span><br><span class="line">[&amp;,x,y] 		x,y 以传值的形式使用，其余变量以引用形式使用</span><br><span class="line"></span><br><span class="line">------------------------------------------------------    </span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>() &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>,y=<span class="number">200</span>,z=<span class="number">300</span>;</span><br><span class="line">	cout &lt;&lt; [](<span class="type">double</span> a,<span class="type">double</span> b) &#123; <span class="keyword">return</span> a + b; &#125;(<span class="number">1.2</span>,<span class="number">2.5</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">auto</span> ff  = [=,&amp;y,&amp;z](<span class="type">int</span> n) &#123; </span><br><span class="line">         cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">         y++; z++; </span><br><span class="line">		<span class="keyword">return</span> n*n; </span><br><span class="line">     &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ff</span>(<span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">33</span>&#125;; </span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">4</span>,[ ](<span class="type">int</span> x,<span class="type">int</span> y)-&gt;<span class="type">bool</span> &#123; <span class="keyword">return</span> x%<span class="number">10</span> &lt; y%<span class="number">10</span>; &#125;);</span><br><span class="line">for_each(a,a+<span class="number">4</span>,[ ](<span class="type">int</span> x) &#123;cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> ;&#125; ) ;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line">    </span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;fib=[&amp;fib](<span class="type">int</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> n &lt;=<span class="number">2</span> ? <span class="number">1</span>:<span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);&#125;;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">fib</span>(<span class="number">5</span>)&lt;&lt;endl;       <span class="comment">//输出5</span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; 表示返回值为 <span class="type">int</span>,有一个 <span class="type">int</span> 参数的函数</span><br></pre></td></tr></table></figure><h4 id="强制类型转换">强制类型转换</h4><h5 id="static-cast">static_cast</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>用来进用行比较“自然”和低风险的转换，比如整型和实数型、字符型之间互相转换。</span><br><span class="line"><span class="keyword">static_cast</span>不能来在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，也不能用于不同类型的引用之间的转换。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">char</span> * ()&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">	<span class="type">int</span> n; <span class="type">char</span> * p = <span class="string">&quot;New Dragon Inn&quot;</span>; </span><br><span class="line">	n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">3.14</span>);  <span class="comment">// n 的值变为 3</span></span><br><span class="line">	n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a); <span class="comment">//调用a.operator int, n的值变为 1</span></span><br><span class="line">    p = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(a); </span><br><span class="line">    <span class="comment">//调用a.operator int *,p的值变为 NULL</span></span><br><span class="line">    n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt; (p);  </span><br><span class="line">    <span class="comment">//编译错误，static_cast不能将指针转换成整型</span></span><br><span class="line">    p = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(n); </span><br><span class="line">    <span class="comment">//编译错误，static_cast不能将整型转换成指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="reinterpret-cast">reinterpret_cast</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reinterpret_cast</span>用来进行各种不同类型的指针之间的转换、不同类型的引用之间转换、以及指针和能容纳得下指针的整数类型之间的转换。转换的时候，执行的是逐个比特拷贝的操作。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">i</span>(n),<span class="built_in">j</span>(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> &amp; r = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a </span></span><br><span class="line">    r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">	cout &lt;&lt; a.i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.j &lt;&lt; endl;   <span class="comment">// 输出 200,100 </span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A * pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt; ( &amp; n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;  			<span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>; 			<span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl; 		<span class="comment">// 输出 400</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> la = <span class="number">0x12345678abcd</span>LL; </span><br><span class="line">    pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt;(la); </span><br><span class="line">	<span class="comment">// la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(pa);</span><br><span class="line">    <span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="type">int</span>,<span class="type">char</span> *)</span></span>; </span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="built_in">reinterpret_cast</span>&lt;PF2&gt;(pf1); </span><br><span class="line">	<span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="const-cast">const_cast</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用来进行去除<span class="type">const</span>属性的转换。将<span class="type">const</span>引用转换成同类型的非<span class="type">const</span>引用，将<span class="type">const</span>指针转换为同类型的非<span class="type">const</span>指针时用它。例如：</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string s = “Inception”;</span><br><span class="line">string &amp; p = <span class="built_in">const_cast</span>&lt;string&amp;&gt;(s);</span><br><span class="line">string * ps = <span class="built_in">const_cast</span>&lt;string*&gt;(&amp;s);  <span class="comment">// &amp;s的类型是const string *</span></span><br></pre></td></tr></table></figure><h5 id="dynamic-cast">dynamic_cast</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>专门用于将多态基类的指针或引用，强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回<span class="literal">NULL</span>指针。</span><br><span class="line"><span class="keyword">dynamic_cast</span>不能用于将非多态基类的指针或引用，强制转换为派生类的指针或引用</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123; <span class="comment">//有虚函数，因此是多态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; &#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Base b;</span><br><span class="line">	Derived d;</span><br><span class="line">	Derived * pd;</span><br><span class="line">	pd = <span class="built_in">reinterpret_cast</span>&lt;Derived*&gt; ( &amp;b);	</span><br><span class="line">    <span class="keyword">if</span>( pd == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="comment">//此处pd不会为NULL。reinterpret_cast不检查安全性，总是进行转换</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe reinterpret_cast&quot;</span> &lt;&lt; endl; <span class="comment">//不会执行</span></span><br><span class="line">    pd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt; ( &amp;b);</span><br><span class="line">    <span class="keyword">if</span>( pd == <span class="literal">NULL</span>) </span><br><span class="line">   <span class="comment">//结果会是NULL，因为 &amp;b不是指向派生类对象，此转换不安全</span></span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast1&quot;</span> &lt;&lt; endl;  <span class="comment">//会执行</span></span><br><span class="line">    pd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt; ( &amp;d); <span class="comment">//安全的转换</span></span><br><span class="line">    <span class="keyword">if</span>( pd == <span class="literal">NULL</span>)<span class="comment">//此处pd 不会为NULL</span></span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast2&quot;</span> &lt;&lt; endl; <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常处理">异常处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>一个函数运行期间可能产生异常。在函数内部对异常进行处理未必合适。因为函数设计者无法知道函数调用者希望如何处理异常。</span><br><span class="line"><span class="number">2.</span>告知函数调用者发生了异常，让函数调用者处理比较好</span><br><span class="line"><span class="number">3.</span>用函数返回值告知异常不方便</span><br></pre></td></tr></table></figure><h5 id="用try、catch进行异常处理">用try、catch进行异常处理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> m ,n; </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">//抛出int类型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">double</span> d) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch(double) &quot;</span> &lt;&lt; d &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">int</span> e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch(int) &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	    cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl; </span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line">    </span><br><span class="line"> 【捕获任何异常的<span class="keyword">catch</span>块】</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> m ,n; </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">//抛出整型异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( m == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">-1.0</span>; <span class="comment">//抛出double型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">double</span> d) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch(double) &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">catch</span>(...) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;catch(...) &quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：<span class="keyword">try</span>块中定义的局部对象，发生异常时会析构！</span><br><span class="line">    </span><br><span class="line">程序运行结果：</span><br><span class="line"><span class="number">9</span> <span class="number">0</span>↙</span><br><span class="line">before dividing.</span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">finished</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span> <span class="number">6</span>↙</span><br><span class="line">before dividing.</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">double</span>) <span class="number">-1</span></span><br><span class="line">finished</span><br><span class="line">----------------------------------------------------</span><br><span class="line">【异常的再抛出】</span><br><span class="line">如果一个函数在执行的过程中，抛出的异常在本函数内就被<span class="keyword">catch</span>块捕获并处理了，那么该异常就不会抛给这个函数的调用者（也称“上一层的函数”）；如果异常在本函数中没被处理，就会被抛给上一层的函数。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CException</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    string msg;</span><br><span class="line">	<span class="built_in">CException</span>(string s):<span class="built_in">msg</span>(s) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Devide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">CException</span>(<span class="string">&quot;devided by zero&quot;</span>); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in Devide&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountTax</span><span class="params">(<span class="type">int</span> salalry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(salary &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;countiong tax&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;salary &lt; 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tax counted&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">0.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> f = <span class="number">1.2</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">CountTax</span>(<span class="number">-1</span>);</span><br><span class="line">		f = <span class="built_in">Devide</span>(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;end of try block&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">catch</span>(CException e) &#123;</span><br><span class="line">		cout &lt;&lt; e.msg &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f=&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">salary &lt; <span class="number">0</span></span><br><span class="line">tax counted</span><br><span class="line">devided by zero f=<span class="number">1.2</span></span><br><span class="line">finished</span><br></pre></td></tr></table></figure><h5 id="bad-cast">bad_cast</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">在用<span class="keyword">dynamic_cast</span> 进行从多态基类对象（或引用），到派生类的引用强制类型转换时</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintObj</span><span class="params">( Base &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>  &#123;</span><br><span class="line">        Derived &amp; rd = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(b);</span><br><span class="line">        <span class="comment">//此转换若不安全，会抛出bad_cast异常</span></span><br><span class="line">		rd.<span class="built_in">Print</span>();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">catch</span> (bad_cast&amp; e) &#123;</span><br><span class="line">            cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="built_in">PrintObj</span>(b); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Bad <span class="keyword">dynamic_cast</span>!</span><br></pre></td></tr></table></figure><h5 id="bad-alloc">bad_alloc</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在用<span class="keyword">new</span>运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span>  &#123;</span><br><span class="line">        <span class="type">char</span> * p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">0x7fffffff</span>];</span><br><span class="line">    <span class="comment">//无法分配这么多空间，会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">catch</span> (bad_alloc &amp; e)&#123;</span><br><span class="line">       cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">bad allocation</span><br></pre></td></tr></table></figure><h5 id="out-of-range">out_of_range</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">用vector或string的at成员函数根据下标访问元素时，如果下标越界，就会抛出此异常。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        v.<span class="built_in">at</span>(<span class="number">100</span>)=<span class="number">100</span>;  <span class="comment">//抛出out_of_range异常</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="built_in">catch</span> (out_of_range&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">char</span> c = s.<span class="built_in">at</span>(<span class="number">100</span>); <span class="comment">//鎶涘嚭out_of_range寮傚父</span></span><br><span class="line">     &#125;</span><br><span class="line">	<span class="built_in">catch</span> (out_of_range&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">invalid vector&lt;T&gt; subscript </span><br><span class="line">invalid string position</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>c++</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ze520ze.github.io/posts/21.html">https://ze520ze.github.io/posts/21.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Z💭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-04-27</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-04-27</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>c++</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://npm.elemecdn.com/xianqi-hexo/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/img/reward/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/xianqi-hexo/img/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/img/reward/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/20.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/imgg/20.webp" onerror='onerror=null,src="/assets/r2.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">c/c++/嵌入式面经</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:700">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%88new%EF%BC%89"><span class="toc-text">动态内存分配（new）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">内联函数（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">函数重载</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">复制构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">类型转换构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8F%90%E9%AB%98"><span class="toc-text">类和对象提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85%E7%B1%BB"><span class="toc-text">成员对象和封装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1-%E5%92%8C-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">常量对象 和 常量成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text">友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">成员函数方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">全局函数方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">赋值运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F"><span class="toc-text">继承和派生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-text">重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%BB%A7%E6%89%BF"><span class="toc-text">多层继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">多继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-text">虚函数表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">纯虚函数、抽象类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E6%A8%A1%E6%9D%BF"><span class="toc-text">输入输出和模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-text">输入输出相关类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%93%8D%E7%BA%B5%E7%AE%97%E5%AD%90"><span class="toc-text">流操纵算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-text">文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%8C%87%E9%92%88"><span class="toc-text">文件的读写指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-text">字符&#x2F;文本文件读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-text">二进制文件读写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B4%BE%E7%94%9F-%E5%8F%8B%E5%85%83-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">类模板与派生&#x2F;友元&#x2F;静态成员变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL"><span class="toc-text">标准模板库STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0"><span class="toc-text">常见构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">容量操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="toc-text">访问及遍历操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">修改操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%E6%A6%82%E8%BF%B0"><span class="toc-text">标准模板库STL概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E5%92%8C%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B8%AD%E9%83%BD%E6%9C%89%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">顺序容器和关联容器中都有的成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">顺序容器的常用成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#find"><span class="toc-text">find()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89"><span class="toc-text">相等</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector-deque-%E5%92%8C-list"><span class="toc-text">vector &#x2F; deque 和 list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-text">deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list"><span class="toc-text">list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%92%8Cmultiset"><span class="toc-text">set和multiset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E5%92%8Cmultimap"><span class="toc-text">map和multimap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">容器适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-2"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8D%E5%8F%98%E5%BA%8F%E5%88%97%E7%AE%97%E6%B3%95"><span class="toc-text">1. 不变序列算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%98%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-text">2. 变值算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">3. 删除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%98%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">4. 变序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">5. 排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%E7%AE%97%E6%B3%95"><span class="toc-text">6. 有序区间算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-text">7. 数值算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11%E7%89%B9%E6%80%A7"><span class="toc-text">c++ 11特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">成员变量默认初始值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">auto关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">decltype 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8CMOVE%E8%AF%AD%E4%B9%89"><span class="toc-text">右值引用和MOVE语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-text">无序容器（哈希表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static-cast"><span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reinterpret-cast"><span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const-cast"><span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8try%E3%80%81catch%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">用try、catch进行异常处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bad-cast"><span class="toc-text">bad_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bad-alloc"><span class="toc-text">bad_alloc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#out-of-range"><span class="toc-text">out_of_range</span></a></li></ol></li></ol></li></div></div></div></div></main><footer id="footer" style="background-color:transparent"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/social/link/">我的朋友</a></li><li><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a></li><li><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.ze520.cn/" title="Xianqi💭"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By Z💭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><script async>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading()),setTimeout((function(){preloader.endLoading()}),5e3),document.getElementById("loading-box").addEventListener("click",(()=>{preloader.endLoading()}))</script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://ze.ze520.cn/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="30" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐵 ZのJava基础笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/hexo/博客/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐶 Zの博客笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🦊 Zの嵌入式笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ze520ze.github.io/categories/单片机/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🦊 Zの嵌入式笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://ze520ze.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(33.333333333333336% - 5px);background:#e9e9e9;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var i=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),i.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/imgg/3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/xianqi-hexo/imgg/9.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9.html&quot;);" href="javascript:void(0);" alt="">hexo butterfly主题博客</a><div class="blog-slider__text">hexo butterfly主题博客 教程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("gitZone").insertAdjacentHTML("afterbegin",'<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>'),console.log("已挂载gitcalendar")}document.getElementById("gitZone")&&"/site/census/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("/api?null",["#d9e0df","#c6e0dc","#a8dcd4","#9adcd2","#89ded1","#77e0d0","#5fdecb","#47dcc6","#39dcc3","#1fdabe","#00dab9"],"null"))</script></body></html>